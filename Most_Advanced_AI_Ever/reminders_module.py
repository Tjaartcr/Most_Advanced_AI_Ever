
#     LAST WORKING BEST BAD DESCRIPTION 2026_01_27__00h50
#
# reminders_module.py (fixed)
from __future__ import annotations
import re
import os
import json
import base64
import ast
import uuid
import time
import threading
from typing import List, Optional, Tuple, Dict, Any
import datetime as dt
import calendar
from GUI import gui

# try to reuse your project's speech/listen objects if available
try:
    from speech import speech
except Exception:
    speech = None
try:
    from listen import listen
except Exception:
    listen = None

# ---------- small helpers ----------
def safe_str(val) -> str:
    if val is None:
        return ""
    if isinstance(val, str):
        return val.strip()
    try:
        return str(val)
    except Exception:
        return ""

def _speak(text: str):
    try:
        if speech is not None and hasattr(speech, "AlfredSpeak"):
            speech.AlfredSpeak(str(text))
            return
    except Exception:
        pass
    print("[ALFRED SPEAK]", text)

def _send_bluetooth(text: str):
    try:
        if listen is not None and hasattr(listen, "send_bluetooth"):
            listen.send_bluetooth(str(text))
    except Exception:
        pass

# ---------- reminder-speaking flag (thread-safe) ----------
REMINDER_SPEAKING_DONT_LISTEN = False
_REMINDER_SPEAKING_LOCK = threading.Lock()

def _set_reminder_speaking(flag: bool):
    global REMINDER_SPEAKING_DONT_LISTEN
    try:
        with _REMINDER_SPEAKING_LOCK:
            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
    except Exception:
        # best-effort only; swallow errors
        pass

def get_reminder_speaking_flag() -> bool:
    try:
        with _REMINDER_SPEAKING_LOCK:
            return bool(REMINDER_SPEAKING_DONT_LISTEN)
    except Exception:
        return False

# ---------- listen helpers ----------
import time as _time

def _wait_for_tts_to_finish(max_wait: int = 6):
    try:
        if speech is not None:
            is_speaking_fn = getattr(speech, "is_speaking", None)
            if callable(is_speaking_fn):
                start = _time.time()
                while _time.time() - start < max_wait:
                    try:
                        if not bool(is_speaking_fn()):
                            break
                    except Exception:
                        break
                    _time.sleep(0.12)
                return
            if getattr(speech, "_currently_speaking", False):
                start = _time.time()
                while _time.time() - start < max_wait:
                    if not getattr(speech, "_currently_speaking", False):
                        break
                    _time.sleep(0.12)
    except Exception:
        pass

def _listen_once(timeout: int = 20) -> str:
    _wait_for_tts_to_finish(max_wait=3)
    end_time = _time.time() + max(1, int(timeout))
    while _time.time() < end_time:
        try:
            if listen is not None and hasattr(listen, "listen"):
                got = listen.listen()
            else:
                try:
                    # debug fallback when running module directly
                    got = input("(debug) type response (or empty): ")
                except Exception:
                    got = ""
            if got:
                print("[listen] Heard:", got)
                return got
        except Exception as e:
            print("_listen_once listen() error:", e)
        _time.sleep(0.18)
    return ""

def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
    for attempt in range(attempts):
        _speak(question)
        _send_bluetooth(question)
        _time.sleep(0.28)
        resp = _listen_once(timeout=timeout_per_attempt)
        if resp:
            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
            return resp
        if attempt + 1 < attempts:
            _speak("I didn't catch that. Please say it again.")
            _send_bluetooth("I didn't catch that. Please say it again.")
            _time.sleep(0.12)
    print("_ask_question_and_get_response: no reply after attempts")
    return ""

# --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
def _resp_to_text(resp) -> str:
    """
    Normalize responses returned by listen() or other sources into a plain string.
    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
    """
    try:
        # If it's already a dict or looks like a dict/stringified dict, use extractor
        if isinstance(resp, dict):
            text, _, _, _, _ = extract_text_from_query(resp)
            return safe_str(text)
        if isinstance(resp, str):
            # extract_text_from_query safely handles stringified dicts and plain strings
            text, _, _, _, _ = extract_text_from_query(resp)
            return safe_str(text)
        return safe_str(resp)
    except Exception:
        try:
            return safe_str(resp)
        except Exception:
            return ""

def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
    for i in range(attempts):
        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
        if not resp:
            if i + 1 < attempts:
                continue
            return False
        resp_text = _resp_to_text(resp).lower()
        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
            return True
        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
            return False
        # fallback: first token
        tokens = re.findall(r"[a-z]+", resp_text)
        if tokens:
            if tokens[0] in yes_words: return True
            if tokens[0] in no_words: return False
        if i + 1 < attempts:
            _speak("I didn't understand. Please answer yes or no.")
            _send_bluetooth("I didn't understand. Please answer yes or no.")
            _time.sleep(0.12)
    return False

# ---------- words -> numbers ----------
_UNITS = {
    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
    "seventeen":17,"eighteen":18,"nineteen":19
}
_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}

def words_to_number(phrase: str) -> Optional[int]:
    if phrase is None: return None
    if not isinstance(phrase, str): phrase = str(phrase)
    words = re.findall(r"[a-z]+", phrase.lower())
    if not words: return None
    total = 0; current = 0; valid = False
    for w in words:
        if w in _UNITS:
            current += _UNITS[w]; valid = True
        elif w in _TENS:
            current += _TENS[w]; valid = True
        elif w in _SCALES:
            scale = _SCALES[w]
            if current == 0: current = 1
            current *= scale
            if scale >= 1000:
                total += current; current = 0
            valid = True
        elif w == "and":
            continue
        else:
            return None
    return (total + current) if valid else None

def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
    i = 0; n = len(words); nums: List[int] = []
    while i < n:
        parsed = None; parsed_len = 0
        for window in range(max_window, 0, -1):
            if i + window > n: continue
            phrase = " ".join(words[i:i+window])
            val = words_to_number(phrase)
            if val is not None:
                parsed = val; parsed_len = window; break
        if parsed is not None:
            nums.append(parsed); i += parsed_len
        else:
            token = words[i]
            if re.fullmatch(r"\d+", token):
                nums.append(int(token)); i += 1
            else:
                i += 1
    return nums

# ---------- extractor that accepts dicts & stringified dicts ----------


def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
    """
    Returns: (message, speaker/username, score, gender, gender_conf)

    Behavior:
      - dict: uses keys text/query/message/q and username/speaker/user
      - strings:
        * will detect and extract triple-single-quote wrappers '''...''' (or ``` fences)
        * will try to parse stringified dicts (ast.literal_eval / json.loads)
        * will find trailing metadata like:
            : 'username':ITF : 'score':None : 'gender':None : 'gender_conf':None
        * returns safe_str(text), speaker (or None), score(float or None),
          gender (or None), gender_conf(float or None)
    """
    if query is None:
        return "", None, None, None, None

    # Helper to parse numeric-or-None strings
    def _to_float_or_none(v):
        if v is None:
            return None
        if isinstance(v, (float, int)):
            return float(v)
        s = str(v).strip()
        if s.lower() in ("none", "null", ""):
            return None
        try:
            return float(s)
        except Exception:
            return None

    # dict input -> straightforward extraction
    if isinstance(query, dict):
        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
        score_ = query.get("score")
        gender_ = query.get("gender")
        gender_conf_ = query.get("gender_conf")
        if isinstance(speaker_, str):
            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
            if s.lower().startswith("none "): s = s[5:].strip()
            speaker_ = None if s.lower() == "none" else s
        try: score_f = float(score_) if score_ is not None else None
        except: score_f = None
        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
        except: gconf_f = None
        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f

    # string input -> robust handling
    if isinstance(query, str):
        original = query
        s = query.strip()

        # If it looks like a stringified dict, attempt to parse it first
        if s.startswith("{"):
            try:
                parsed = ast.literal_eval(s)
                if isinstance(parsed, dict):
                    return extract_text_from_query(parsed)
            except Exception:
                try:
                    parsed = json.loads(s)
                    if isinstance(parsed, dict):
                        return extract_text_from_query(parsed)
                except Exception:
                    pass

        # try base64 decode if it looks like base64
        try:
            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
                try:
                    decoded = base64.b64decode(s).decode('utf-8')
                    if decoded:
                        s = decoded.strip()
                except Exception:
                    pass
        except Exception:
            pass

        # strip some timestamp wrappers (if present)
        try:
            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
            if not dt_match:
                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
            if not dt_match:
                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
            if dt_match:
                s = s[dt_match.end():].lstrip()
        except Exception:
            pass

        # stronger meta-key detection (no word-boundary; handles quotes and no-quotes)
        kv_key = re.compile(r"(?:'|\")?(?:username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]", flags=re.I)
        m = kv_key.search(s)
        meta_idx = m.start() if m else None

        meta_part = ""
        body = s
        if meta_idx is not None:
            # cut so we also drop any preceding " : " separators
            cut = meta_idx
            while cut > 0 and s[cut-1] in " :":
                cut -= 1
            body = s[:cut].rstrip(" :")
            meta_part = s[cut:].lstrip(" :")

        score_val = None
        gender_val = None
        gender_conf_val = None
        speaker_val = None

        if meta_part:
            # generic key:value regex for the keys we care about
            kv_pattern = re.compile(
                r"(?:'|\")?(?P<k>username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]\s*(?:'(?P<vq>[^']*)'|\"(?P<vqq>[^\"]*)\"|(?P<vn>[^:\n]+))",
                flags=re.I
            )
            parsed_meta = {}
            for mm in kv_pattern.finditer(meta_part):
                k = mm.group('k').lower()
                v = mm.group('vq') if mm.group('vq') is not None else (mm.group('vqq') if mm.group('vqq') is not None else mm.group('vn'))
                if v is not None:
                    parsed_meta[k] = v.strip()

            if 'score' in parsed_meta:
                score_val = _to_float_or_none(parsed_meta.get('score'))
            if 'gender' in parsed_meta:
                gv = parsed_meta.get('gender')
                gender_val = None if (gv is None or gv.strip().lower() in ('none','null','')) else safe_str(gv)
            if 'gender_conf' in parsed_meta:
                gender_conf_val = _to_float_or_none(parsed_meta.get('gender_conf'))
            if 'username' in parsed_meta:
                speaker_val = parsed_meta.get('username')
            elif 'user' in parsed_meta:
                speaker_val = parsed_meta.get('user')
            elif 'speaker' in parsed_meta:
                speaker_val = parsed_meta.get('speaker')

            # leftover tokens fallback -> pick last leftover as speaker if not set
            try:
                meta_clean = kv_pattern.sub('', meta_part)
                leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
                if leftovers and not speaker_val:
                    for token in reversed(leftovers):
                        if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
                            speaker_val = token
                            break
            except Exception:
                pass

        # fallback: try to pick up score/gender/gender_conf inside the body if not already parsed
        if score_val is None:
            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
                    or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
            if m_score2:
                score_val = _to_float_or_none(m_score2.group("v"))
                body = body[:m_score2.start()].rstrip(" :")

        if gender_val is None:
            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I) \
                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', body, flags=re.I)
            if m_gender2:
                gv = m_gender2.group("v").strip()
                gender_val = None if gv.lower() == "none" else safe_str(gv)
                body = body[:m_gender2.start()].rstrip(" :")

        if gender_conf_val is None:
            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
            if m_gconf2:
                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
                body = body[:m_gconf2.start()].rstrip(" :")

        # if body itself is a dict-like string (even without 'text' key) try to parse it
        if body.strip().startswith("{"):
            try:
                parsed = ast.literal_eval(body)
                if isinstance(parsed, dict):
                    return extract_text_from_query(parsed)
            except Exception:
                try:
                    parsed = json.loads(body)
                    if isinstance(parsed, dict):
                        return extract_text_from_query(parsed)
                except Exception:
                    pass

        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
        text_val = safe_str(m_text.group("t")) if m_text else body.rstrip(" :")

        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
        if m_speaker and not speaker_val:
            speaker_val = safe_str(m_speaker.group("s"))

        # normalize speaker 'none' and remove device suffixes
        if isinstance(speaker_val, str):
            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
            if speaker_val.lower() == "none": speaker_val = None

        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val

    # final fallback
    return safe_str(query), None, None, None, None



######def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
######    """
######    Returns: (message, speaker/username, score, gender, gender_conf)
######
######    Behavior:
######      - dict: uses keys text/query/message/q and username/speaker/user
######      - strings:
######        * will detect and extract triple-single-quote wrappers '''...''' (or ``` fences)
######        * will find trailing metadata like:
######            : 'username':ITF : 'score':None : 'gender':None : 'gender_conf':None
######        * returns safe_str(text), speaker (or None), score(float or None),
######          gender (or None), gender_conf(float or None)
######    """
######    if query is None:
######        return "", None, None, None, None
######
######    # Helper to parse numeric-or-None strings
######    def _to_float_or_none(v):
######        if v is None:
######            return None
######        if isinstance(v, (float, int)):
######            return float(v)
######        s = str(v).strip()
######        if s.lower() in ("none", "null", ""):
######            return None
######        try:
######            return float(s)
######        except Exception:
######            return None
######
######    if isinstance(query, dict):
######        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
######        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
######        score_ = query.get("score")
######        gender_ = query.get("gender")
######        gender_conf_ = query.get("gender_conf")
######        if isinstance(speaker_, str):
######            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
######            if s.lower().startswith("none "): s = s[5:].strip()
######            speaker_ = None if s.lower() == "none" else s
######        try: score_f = float(score_) if score_ is not None else None
######        except: score_f = None
######        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
######        except: gconf_f = None
######        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
######
######    if isinstance(query, str):
######        original = query
######        s = query.strip()
######
######        # --- try base64 decode if it looks like base64 (unchanged) ---
######        try:
######            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
######                try:
######                    decoded = base64.b64decode(s).decode('utf-8')
######                    if decoded:
######                        s = decoded.strip()
######                except Exception:
######                    pass
######        except Exception:
######            pass
######
######        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
######        try:
######            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
######            if not dt_match:
######                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
######            if not dt_match:
######                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
######            if dt_match:
######                s = s[dt_match.end():].lstrip()
######        except Exception:
######            pass
######
######        # --- detect trailing metadata start (score/gender/gender_conf/username) and split ---
######        meta_idx = None
######        m = re.search(r"\b(?:username|user|speaker|score|gender|gender_conf)\b\s*[:=]", s, flags=re.I)
######        if m:
######            meta_idx = m.start()
######
######        meta_part = ""
######        body = s
######        if meta_idx is not None:
######            body = s[:meta_idx].rstrip(" :")
######            meta_part = s[meta_idx:].lstrip(" :")
######
######        # If meta_part present parse score/gender/gender_conf and final speaker token
######        score_val = None
######        gender_val = None
######        gender_conf_val = None
######        speaker_val = None
######
######        if meta_part:
######            # generic key:value regex for the keys we care about
######            kv_pattern = re.compile(
######                r"(?:'|\")?(?P<k>username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]\s*(?:'(?P<vq>[^']*)'|\"(?P<vqq>[^\"]*)\"|(?P<vn>[^:\n]+))",
######                flags=re.I
######            )
######            parsed_meta = {}
######            for mm in kv_pattern.finditer(meta_part):
######                k = mm.group('k').lower()
######                v = mm.group('vq') if mm.group('vq') is not None else (mm.group('vqq') if mm.group('vqq') is not None else mm.group('vn'))
######                if v is not None:
######                    parsed_meta[k] = v.strip()
######
######            # extract values if present
######            if 'score' in parsed_meta:
######                score_val = _to_float_or_none(parsed_meta.get('score'))
######            if 'gender' in parsed_meta:
######                gv = parsed_meta.get('gender')
######                gender_val = None if (gv is None or gv.strip().lower() in ('none','null','')) else safe_str(gv)
######            if 'gender_conf' in parsed_meta:
######                gender_conf_val = _to_float_or_none(parsed_meta.get('gender_conf'))
######            if 'username' in parsed_meta:
######                speaker_val = parsed_meta.get('username')
######            elif 'user' in parsed_meta:
######                speaker_val = parsed_meta.get('user')
######            elif 'speaker' in parsed_meta:
######                speaker_val = parsed_meta.get('speaker')
######
######            # fallback: leftover tokens in meta_part that aren't known keys -> speaker
######            try:
######                meta_clean = kv_pattern.sub('', meta_part)
######                leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
######                if leftovers and not speaker_val:
######                    for token in reversed(leftovers):
######                        if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
######                            speaker_val = token
######                            break
######            except Exception:
######                pass
######
######        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
######        if score_val is None:
######            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
######                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
######                    or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
######            if m_score2:
######                score_val = _to_float_or_none(m_score2.group("v"))
######                body = body[:m_score2.start()].rstrip(" :")
######
######        if gender_val is None:
######            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
######                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I) \
######                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', body, flags=re.I)
######            if m_gender2:
######                gv = m_gender2.group("v").strip()
######                gender_val = None if gv.lower() == "none" else safe_str(gv)
######                body = body[:m_gender2.start()].rstrip(" :")
######
######        if gender_conf_val is None:
######            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
######                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
######                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
######            if m_gconf2:
######                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
######                body = body[:m_gconf2.start()].rstrip(" :")
######
######        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
######        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
######        if looks_like_dict:
######            try:
######                parsed = ast.literal_eval(body)
######                if isinstance(parsed, dict):
######                    return extract_text_from_query(parsed)
######            except Exception:
######                try:
######                    parsed = json.loads(body)
######                    if isinstance(parsed, dict):
######                        return extract_text_from_query(parsed)
######                except Exception:
######                    pass
######
######        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
######        text_val = safe_str(m_text.group("t")) if m_text else body
######
######        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
######        if m_speaker and not speaker_val:
######            speaker_val = safe_str(m_speaker.group("s"))
######
######        # post-process speaker found earlier (trim device suffixes and "none")
######        if isinstance(speaker_val, str):
######            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
######            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
######            if speaker_val.lower() == "none": speaker_val = None
######
######        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
######
######    # final fallback
######    return safe_str(query), None, None, None, None



##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    """
##    Returns: (message, speaker/username, score, gender, gender_conf)
##
##    Behavior:
##      - dict: uses keys text/query/message/q and username/speaker/user
##      - strings:
##        * will detect and extract triple-single-quote wrappers '''...''' (or ``` fences)
##        * will find trailing metadata like:
##            : 'username':ITF : 'score':None : 'gender':None : 'gender_conf':None
##        * returns safe_str(text), speaker (or None), score(float or None),
##          gender (or None), gender_conf(float or None)
##    """
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() in ("none", "null", ""):
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf/username) and split ---
##        meta_idx = None
##        m = re.search(r"\b(?:username|user|speaker|score|gender|gender_conf)\b\s*[:=]", s, flags=re.I)
##        if m:
##            meta_idx = m.start()
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # generic key:value regex for the keys we care about
##            kv_pattern = re.compile(
##                r"(?:'|\")?(?P<k>username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]\s*(?:'(?P<vq>[^']*)'|\"(?P<vqq>[^\"]*)\"|(?P<vn>[^:\n]+))",
##                flags=re.I
##            )
##            parsed_meta = {}
##            for mm in kv_pattern.finditer(meta_part):
##                k = mm.group('k').lower()
##                v = mm.group('vq') if mm.group('vq') is not None else (mm.group('vqq') if mm.group('vqq') is not None else mm.group('vn'))
##                if v is not None:
##                    parsed_meta[k] = v.strip()
##
##            # extract values if present
##            if 'score' in parsed_meta:
##                score_val = _to_float_or_none(parsed_meta.get('score'))
##            if 'gender' in parsed_meta:
##                gv = parsed_meta.get('gender')
##                gender_val = None if (gv is None or gv.strip().lower() in ('none','null','')) else safe_str(gv)
##            if 'gender_conf' in parsed_meta:
##                gender_conf_val = _to_float_or_none(parsed_meta.get('gender_conf'))
##            if 'username' in parsed_meta:
##                speaker_val = parsed_meta.get('username')
##            elif 'user' in parsed_meta:
##                speaker_val = parsed_meta.get('user')
##            elif 'speaker' in parsed_meta:
##                speaker_val = parsed_meta.get('speaker')
##
##            # fallback: leftover tokens in meta_part that aren't known keys -> speaker
##            try:
##                meta_clean = kv_pattern.sub('', meta_part)
##                leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##                if leftovers and not speaker_val:
##                    for token in reversed(leftovers):
##                        if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                            speaker_val = token
##                            break
##            except Exception:
##                pass
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
##                    or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker and not speaker_val:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None

# ---------- date/time parsing helpers ----------
_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
_WEEKDAYS = _WEEKDAY_MAP.copy()

_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}

def _token_to_number(token: str) -> Optional[int]:
    token = safe_str(token).lower()
    if not token: return None
    if re.fullmatch(r"\d+", token):
        try: return int(token)
        except: return None
    if token in _UNITS: return _UNITS[token]
    if token in _TENS: return _TENS[token]
    if "-" in token:
        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
        if all(v is not None for v in vals): return sum(vals)
    return words_to_number(token)

def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
    s0 = safe_str(s).lower()
    ampm = None
    for w in _AM_WORDS:
        if re.search(r"\b" + re.escape(w) + r"\b", s0):
            ampm = "am"
            break
    if ampm is None:
        for w in _PM_WORDS:
            if re.search(r"\b" + re.escape(w) + r"\b", s0):
                ampm = "pm"
                break
    if re.search(r"\bnoon\b", s0): ampm = "pm"
    if re.search(r"\bmidnight\b", s0): ampm = "am"
    if ampm:
        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
        s0 = re.sub(pattern, " ", s0)
        s0 = re.sub(r"\s+", " ", s0).strip()
    return s0, ampm

def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
    """
    Robust spoken time -> (hour, minute) parser.
    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
    """
    if spoken is None: return None
    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)

    s_orig = safe_str(spoken)
    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
    # quick special words
    if re.search(r"\bnoon\b", s): return (12, 0)
    if re.search(r"\bmidnight\b", s): return (0, 0)

    # detect am/pm using the whole phrase and remove those tokens
    s_no_ampm, ampm = _detect_ampm_and_remove(s)

    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
    if m_colon:
        try:
            hh = int(m_colon.group(1)) % 24
            mm = int(m_colon.group(2)) % 60
            hour = hh
            minute = mm
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)
        except Exception:
            pass

    # 2) 'half past X'
    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
    if m_half:
        token = m_half.group(1).strip()
        h = _token_to_number(token)
        if h is not None:
            hour = int(h) % 24
            minute = 30
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)

    # 3) 'quarter past/to X'
    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
    if m_quarter:
        typ = m_quarter.group(1)
        hour_token = m_quarter.group(2).strip()
        h = _token_to_number(hour_token)
        if h is not None:
            hour = int(h) % 24
            if typ == "past":
                minute = 15
            else:
                minute = 45
                hour = (hour - 1) % 24
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)

    # 4) 'X minutes past Y'
    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
    if m_past:
        try:
            mins = int(m_past.group(1))
            htoken = m_past.group(2)
            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
            if h is not None:
                hour = int(h) % 24
                minute = mins % 60
                if ampm == "pm" and hour < 12: hour += 12
                if ampm == "am" and hour == 12: hour = 0
                return (hour, minute)
        except Exception:
            pass

    # 5) 'X minutes to Y' -> compute
    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
    if m_to:
        try:
            mins = int(m_to.group(1))
            htoken = m_to.group(2)
            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
            if h is not None:
                hour = (int(h) - 1) % 24
                minute = (60 - (mins % 60)) % 60
                if ampm == "pm" and hour < 12: hour += 12
                if ampm == "am" and hour == 12: hour = 0
                return (hour, minute)
        except Exception:
            pass

    # 6) 'X o'clock'
    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
    if m_oclock:
        try:
            hour = int(m_oclock.group(1)) % 24
            minute = 0
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)
        except Exception:
            pass

    # 7) two-number tokens e.g., 'ten thirty'
    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
    if len(tokens) >= 2:
        h_candidate = _token_to_number(tokens[0])
        m_candidate = _token_to_number(tokens[1])
        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
            hour = int(h_candidate) % 24
            minute = int(m_candidate) % 60
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)

    # 8) single number token -> hour
    if len(tokens) == 1:
        h = _token_to_number(tokens[0])
        if h is not None:
            hour = int(h) % 24
            minute = 0
            if ampm == "pm" and hour < 12: hour += 12
            if ampm == "am" and hour == 12: hour = 0
            return (hour, minute)

    # 9) digits cluster like 930
    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
    if digits_cluster:
        cluster = digits_cluster.group(1)
        try:
            if len(cluster) == 3:
                h = int(cluster[0]); m = int(cluster[1:])
            else:
                h = int(cluster[:2]); m = int(cluster[2:])
            if 0 <= h < 24 and 0 <= m < 60:
                hour = h; minute = m
                if ampm == "pm" and hour < 12: hour += 12
                if ampm == "am" and hour == 12: hour = 0
                return (hour, minute)
        except Exception:
            pass

    return None

def spoken_time_to_str(spoken) -> Optional[str]:
    hm = spoken_time_to_hm(spoken)
    if not hm: return None
    return f"{hm[0]:02d}:{hm[1]:02d}"

# -------------------------
# NEW HELPER: extract small time fragment from full utterance
# -------------------------
# Reason: passing the entire utterance (which may include "for the next two weeks")
# into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
# This helper finds a concise time-like substring and returns it.
def _extract_time_fragment(text: str) -> str:
    if not text:
        return ""
    t = safe_str(text).lower()
    patterns = [
        r"\bhalf past [a-z0-9 ]{1,20}\b",
        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
        r"\b(?:noon|midnight)\b",
        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
    ]
    for pat in patterns:
        m = re.search(pat, t, flags=re.I)
        if m:
            return m.group(0)
    # fallback: try to find a short "X Y" token near "at" or near start
    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
    if m_at:
        frag = m_at.group(1).strip()
        # keep only first few words
        frag = " ".join(frag.split()[:4])
        return frag
    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
    return t

# ---------- simple persistence/organizer ----------
ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
os.makedirs(ORGANIZER_DIR, exist_ok=True)
ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
organizer_events: List[dict] = []

def _load_organizer_events():
    global organizer_events
    try:
        if os.path.exists(ORGANIZER_DB):
            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
                organizer_events = json.load(f)
        else:
            organizer_events = []
    except Exception as e:
        print("Organizer load failed:", e); organizer_events = []

def _save_organizer_events():
    try:
        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
            json.dump(organizer_events, f, indent=2, default=str)
    except Exception as e:
        print("Organizer save failed:", e)

def _write_ics_file(ev: dict) -> Optional[str]:
    try:
        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
        uid = ev['id']
        # include metadata in DESCRIPTION so ICS contains it
        metadata_desc = []
        if ev.get("username") is not None:
            metadata_desc.append(f"username:{ev.get('username')}")
        metadata_desc.append(f"score:{ev.get('score')!s}")
        metadata_desc.append(f"gender:{ev.get('gender')!s}")
        metadata_desc.append(f"gender_conf:{ev.get('gender_conf')!s}")
        description = ev.get('description','') + " | " + " ; ".join(metadata_desc)
        ics_text = "\r\n".join([
            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{description}",
            "END:VEVENT","END:VCALENDAR",""
        ])
        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
            f.write(ics_text)
        return ics_path
    except Exception as e:
        print("Error writing ics:", e); return None

# ---------- compute notify times ----------
def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
    uniq = {}
    for t in times:
        try:
            iso = t.replace(second=0, microsecond=0).isoformat()
            uniq[iso] = t
        except Exception:
            pass
    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
    return out

def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
    now = now or dt.datetime.now()
    event_date = dtstart.date()
    candidates: List[dt.datetime] = []
    for hh in (7, 10, 12):
        try:
            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
            if cand < dtstart and cand > now:
                candidates.append(cand)
        except Exception:
            continue
    for minutes_before in (60, 30, 15, 0):
        try:
            cand = dtstart - dt.timedelta(minutes=minutes_before)
            if cand > now and cand <= dtstart:
                candidates.append(cand)
        except Exception:
            continue
    return _unique_sorted_times(candidates)

# ---------- add event ----------
def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
                        duration_minutes: int = 60, reminder_minutes: int = 15,
                        description: str = "", event_type: str = "reminder",
                        username: Optional[str] = None, score: Optional[float] = None,
                        gender: Optional[str] = None, gender_conf: Optional[float] = None) -> dict:
    """
    Create an event and store metadata fields username/score/gender/gender_conf inside the event dict.
    """
    try:
        if isinstance(date_text, str):
            ymd = dt.date.fromisoformat(date_text)
        elif isinstance(date_text, dt.date):
            ymd = date_text
        else:
            raise ValueError("Invalid date_text")
        hh, mm = 9, 0
        try:
            if isinstance(time_text, str) and ":" in time_text:
                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
            elif isinstance(time_text, dt.time):
                hh = time_text.hour; mm = time_text.minute
        except Exception:
            pass
        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
        ev_id = uuid.uuid4().hex
        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
              "description": description, "ics_path": None, "notified": False,
              # store the metadata requested
              "username": (safe_str(username) if username is not None else None),
              "score": (float(score) if score is not None else None),
              "gender": (safe_str(gender) if gender is not None else None),
              "gender_conf": (float(gender_conf) if gender_conf is not None else None),
              }
        notify_list = _compute_notify_times_for_event(dtstart)
        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
        ics = _write_ics_file(ev)
        if ics: ev['ics_path'] = ics
        organizer_events.append(ev)
        _save_organizer_events()
        return ev
    except Exception as e:
        print("add_organizer_event failed:", e)
        raise

def _migrate_loaded_events():
    changed = False
    now = dt.datetime.now()
    for ev in organizer_events:
        try:
            ds = ev.get("dtstart")
            if not ds:
                continue
            dtstart = dt.datetime.fromisoformat(ds)
            if not ev.get("notify_times"):
                nts = _compute_notify_times_for_event(dtstart, now=now)
                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
                changed = True
            else:
                new_nts = []
                for item in ev.get("notify_times", []):
                    if isinstance(item, dict) and item.get("t"):
                        try:
                            dt.datetime.fromisoformat(item["t"])
                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
                        except Exception:
                            continue
                if not new_nts:
                    nts = _compute_notify_times_for_event(dtstart, now=now)
                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
                    changed = True
                else:
                    ev["notify_times"] = new_nts
            # ensure metadata keys exist (migration-friendly)
            if "username" not in ev:
                ev["username"] = ev.get("username", None)
                changed = True
            if "score" not in ev:
                ev["score"] = ev.get("score", None)
                changed = True
            if "gender" not in ev:
                ev["gender"] = ev.get("gender", None)
                changed = True
            if "gender_conf" not in ev:
                ev["gender_conf"] = ev.get("gender_conf", None)
                changed = True
        except Exception:
            continue
    if changed: _save_organizer_events()

# -------------------------
# NEW: cleanup fired events
# -------------------------
def _cleanup_fired_events():
    """
    Remove events that have already had all their notify_times fired.
    Also delete associated ICS files when removing.
    """
    global organizer_events
    try:
        with _NOTIFIER_THREAD_LOCK:
            now = dt.datetime.now()
            kept = []
            removed_any = False
            for ev in organizer_events:
                try:
                    nts = ev.get("notify_times", [])
                    # if there are notify times and all are fired -> remove
                    if nts and all(bool(item.get("fired", False)) for item in nts):
                        # delete ICS if present
                        ics = ev.get("ics_path")
                        try:
                            if ics and os.path.exists(ics):
                                os.remove(ics)
                        except Exception:
                            pass
                        removed_any = True
                        continue
                    # fallback: if no notify_times but 'notified' True and dtstart in past -> remove
                    if (not nts or len(nts) == 0) and ev.get("notified", False):
                        try:
                            dtstart = dt.datetime.fromisoformat(ev.get("dtstart"))
                            if dtstart < now:
                                ics = ev.get("ics_path")
                                try:
                                    if ics and os.path.exists(ics):
                                        os.remove(ics)
                                except Exception:
                                    pass
                                removed_any = True
                                continue
                        except Exception:
                            pass
                    # otherwise keep
                    kept.append(ev)
                except Exception:
                    kept.append(ev)
            if removed_any:
                organizer_events = kept
                _save_organizer_events()
    except Exception as e:
        print("_cleanup_fired_events error:", e)

# ---------- quick reminders ----------
_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
    if not lines: return
    try:
        with open(path, "a", encoding="utf-8") as f:
            for ln in lines:
                f.write(safe_str(ln).rstrip() + "\n")
    except Exception as e:
        print("Failed to save quick reminders:", e)

def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
    try:
        if not os.path.exists(path): return []
        with open(path, "r", encoding="utf-8") as f:
            return [ln.strip() for ln in f.readlines() if ln.strip()]
    except Exception as e:
        print("Failed to read reminders:", e); return []

# ---------- title extraction ----------
def extract_title_from_text(text: str) -> str:
    s = safe_str(text)
    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
    s = s.strip(" ,.")
    return s or "Reminder"

# ---------- NEW: clean subject helper ----------
_TRIGGER_LEADING_RE = re.compile(
    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
)

_DATE_TIME_CUES = [
    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
    r'\bday after tomorrow\b',
    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
    r'\b\d{1,2}\s?(?:am|pm)\b'
]
_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]

def clean_reminder_subject(text: str) -> str:
    """
    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
    and trim away trailing date/time phrases so the returned text is just the reminder subject.
    """
    if not text:
        return ""
    t = safe_str(text)
    # remove leading trigger
    t = _TRIGGER_LEADING_RE.sub("", t).strip()
    if not t:
        return ""
    # find earliest date/time cue and cut there
    earliest = None
    for cre in _DATE_TIME_CUES_COMPILED:
        m = cre.search(t)
        if m:
            idx = m.start()
            if earliest is None or idx < earliest:
                earliest = idx
    if earliest is not None and earliest > 0:
        t = t[:earliest].strip(" ,:-")
    # final cleanup
    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
    return t

# ---------- recurrence parsing & expansion helpers ----------
def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
    """Add months safely to a datetime (preserves day where possible)."""
    year = date_obj.year + (date_obj.month - 1 + months) // 12
    month = (date_obj.month - 1 + months) % 12 + 1
    # find last day of target month
    last_day = calendar.monthrange(year, month)[1]
    day = min(date_obj.day, last_day)
    try:
        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
    except Exception:
        # fallback simple approximation
        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)

def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
    s = safe_str(text).lower()
    # explicit tomorrow
    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
        out["explicit_tomorrow"] = True
    # everyday / daily
    if re.search(r'\bevery (day|everyday)\b', s):
        out["type"] = "daily"
        out["interval"] = 1
    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
        out["type"] = "every_n_days"; out["interval"] = 2
    # every N days like 'every 3 days'
    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
    if m3:
        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
        except: pass
    # weekly / every X weeks
    if re.search(r'\bevery (week|weekly)\b', s):
        out["type"] = "weekly"; out["interval"] = 1
    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
    if m4:
        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
        except: pass
    # fix: check for 'every second week' / 'every 2 weeks' correctly using s
    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
        out["type"] = "every_n_weeks"; out["interval"]=2
    # weekday like "every Monday"
    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
    if mwd:
        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1).lower()]
        out["interval"] = 1
    # "for the month" or span days hints
    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
        out["span_days"] = 30
    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
    if m_next:
        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
        if n:
            out["span_days"] = int(n)*7
    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
    if m_nextd:
        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
        if n:
            out["span_days"] = int(n)
    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
        out["type"] = "monthly"
        out["months"] = 12 if 'of the year' in s else 1
    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
        today = dt.date.today()
        days_left = 7 - today.weekday()
        out["span_days"] = days_left
        out["type"] = "daily"
    return out

def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
    out: List[dt.datetime] = []
    if base_dt is None:
        return out
    span_days = rec_spec.get("span_days", 30)
    end_date = base_dt + dt.timedelta(days=span_days)
    typ = rec_spec.get("type", "none")
    interval = int(rec_spec.get("interval", 1) or 1)

    # always include base_dt as first occurrence
    out.append(base_dt)

    if rec_spec.get("explicit_tomorrow"):
        tomorrow_dt = base_dt + dt.timedelta(days=1)
        out.append(tomorrow_dt)

    if typ in ("daily",) and typ != "none":
        day = base_dt
        while True:
            day = day + dt.timedelta(days=interval)
            if day <= end_date:
                out.append(day)
            else:
                break
    elif typ == "every_n_days":
        day = base_dt
        while True:
            day = day + dt.timedelta(days=interval)
            if day <= end_date:
                out.append(day)
            else:
                break
    elif typ in ("weekly","every_n_weeks"):
        day = base_dt
        while True:
            day = day + dt.timedelta(weeks=interval)
            if day <= end_date:
                out.append(day)
            else:
                break
    elif typ == "weekday" and rec_spec.get("weekday") is not None:
        wd = int(rec_spec.get("weekday"))
        candidate = base_dt
        if candidate.weekday() != wd:
            days_ahead = (wd - candidate.weekday()) % 7
            candidate = candidate + dt.timedelta(days=days_ahead)
        while candidate <= end_date:
            if candidate >= base_dt:
                out.append(candidate)
            candidate = candidate + dt.timedelta(weeks=1)
    elif typ == "monthly":
        months_to_create = int(rec_spec.get("months", 1) or 1)
        current = base_dt
        for i in range(1, months_to_create):
            current = add_months(current, 1)
            if current <= end_date + dt.timedelta(days=1):
                out.append(current)

    # dedupe & sort
    uniq = {}
    for d in out:
        try:
            iso = d.replace(second=0, microsecond=0).isoformat()
            uniq[iso] = d
        except Exception:
            continue
    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
    return final

# ---------- notification/snooze handling ----------
def _parse_snooze_minutes(resp: str) -> Optional[int]:
    if not resp: return None
    resp = resp.lower()
    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
    if m:
        n = int(m.group(1))
        unit = m.group(2)
        if "hour" in unit or unit == "h":
            return n * 60
        return n
    n = words_to_number(resp)
    if isinstance(n, int):
        if "hour" in resp:
            return n * 60
        return n
    if "five" in resp or "5" in resp: return 5
    if "ten" in resp or "10" in resp: return 10
    if "fifteen" in resp or "15" in resp: return 15
    if "thirty" in resp or "30" in resp: return 30
    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
    return None

def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
    try:
        _set_reminder_speaking(True)
        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
        title = ev.get('title', '(no title)')
        notify_time = dt.datetime.fromisoformat(notify_iso)
        # include metadata in spoken message if present
        meta_str = ""
        if ev.get("username") is not None:
            meta_str = f" : 'username':{ev.get('username')} : 'score':{ev.get('score')!s} : 'gender':{ev.get('gender')!s} : 'gender_conf':{ev.get('gender_conf')!s}"
        _speak(f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")

#################
        
                # GUI log if available
        query_msg = (
            f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}."
##            f"and I replied:\n\n{Alfred_Repeat_Previous_Response}\n\n"
        )

        model = "Alfred"
        query_resp = f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}."
        
        # Use the gui instance passed into main() to log; handle None or exceptions gracefully
        try:
            if gui is not None:
                try:
                    gui.log_message(query_msg)
                    gui.log_response(query_resp)
                except Exception as e:
                    print("Error logging to GUI instance:", e)
            else:
                print("GUI instance not available for logging message (gui is None).")
        except Exception as e:
            print("Error while attempting GUI logging:", e)
            
################

        _send_bluetooth(f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
        if not resp:
            return False
        low = _resp_to_text(resp).lower()
        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
            return False
        minutes = _parse_snooze_minutes(low)
        if minutes is None:
            if "snooze" in low:
                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
                if follow:
                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
        if minutes is None:
            _speak("Okay, not snoozing.")
            return False
        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
        _save_organizer_events()
        return True
    except Exception as e:
        print("_announce_and_handle_snooze error:", e)
        return False
    finally:
        _set_reminder_speaking(False)

# ---------- main notifier loop ----------
_NOTIFIER_THREAD = None
_NOTIFIER_THREAD_LOCK = threading.Lock()

def _notifier_loop(poll_seconds: int = 20):
    while True:
        try:
            now = dt.datetime.now()
            changed = False
            for ev in organizer_events:
                try:
                    nts = ev.get("notify_times", [])
                    for nt in nts:
                        try:
                            if nt.get("fired", False):
                                continue
                            notify_dt = dt.datetime.fromisoformat(nt['t'])
                            if now >= notify_dt:
                                nt['fired'] = True
                                # mark that the event has had at least one notify fired
                                ev["notified"] = True
                                changed = True
                                _announce_and_handle_snooze(ev, nt['t'])
                        except Exception:
                            continue
                except Exception:
                    continue
            if changed:
                _save_organizer_events()
                # cleanup fully fired events to keep the schedule file tidy
                try:
                    _cleanup_fired_events()
                except Exception as _e:
                    print("cleanup error after save:", _e)
        except Exception as e:
            print("Notifier loop error:", e)
        time.sleep(poll_seconds)

def start_reminder_notifier_thread(poll_seconds: int = 20):
    global _NOTIFIER_THREAD
    with _NOTIFIER_THREAD_LOCK:
        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
            return
        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
        _NOTIFIER_THREAD.start()

# ---------- load / migration on import ----------
_load_organizer_events()
_migrate_loaded_events()
# cleanup any already-fired events on load as well
_cleanup_fired_events()

# ---------- public handler (entrypoint used by main.py) ----------
def handle_voice_command(AlfredQueryOffline: str, gui=None):
    text_in = safe_str(AlfredQueryOffline)
    if not text_in:
        return
    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
    # remove trailing speaker tokens like " : Name Home"
    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
    lower = text_clean.lower()
    k = ""
    # triggers for create/set reminders
    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
        _speak("Okay  I will create a reminder.")
        try:
            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
        except Exception:
            msg_text = text_clean
            speaker = None; score = None; gender = None; gender_conf = None
        msg_text = safe_str(msg_text)

        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
        print(f"[DEBUG REMINDER] speaker : {speaker}")
        print(f"[DEBUG REMINDER] score : {score}")
        print(f"[DEBUG REMINDER] gender : {gender}")
        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")

        # Preserve original utterance for parsing, but derive a clean subject
        original_for_parsing = msg_text
        subject = clean_reminder_subject(original_for_parsing)

        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
        try:
            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
            for f in fillers:
                subject = re.sub(f, "", subject, flags=re.I)
            # remove extra whitespace & punctuation
            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
        except Exception as _e:
            print("subject filler clean error:", _e)
            subject = subject.strip()

        subject = subject.replace("ing","")
        
        # If subject empty, ask first what the reminder should be about
        if not subject:
            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
            if resp:
                try:
                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
                except Exception:
                    resp_text = resp
                subject = safe_str(resp_text)

        if not subject:
            # cannot determine subject -> save quick reminder
            # include metadata in the quick reminder line if present
            meta_str = ""
            if speaker is not None:
                meta_str = f" : 'username':{speaker} : 'score':{safe_str(score)!s} : 'gender':{safe_str(gender)!s} : 'gender_conf':{safe_str(gender_conf)!s}"
            _append_lines_to_file([original_for_parsing + meta_str])
            _speak("Saved quick reminder (no subject).")
            return

        # Now parse date/time from the original utterance (so time tokens are preserved)
        msg_text_for_parsing = original_for_parsing

        parsed_dt = None
        try:
            parsed_dt = None
            # relative expressions first
            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
            if m_rel:
                num_phrase = m_rel.group(2).strip()
                unit = m_rel.group(3)
                try:
                    num = int(num_phrase)
                except:
                    num = words_to_number(num_phrase)
                if num is not None:
                    now = dt.datetime.now()
                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
            # if not relative, try explicit date/time
            if parsed_dt is None:
                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
                    time_frag = _extract_time_fragment(msg_text_for_parsing)
                    hm = spoken_time_to_hm(time_frag)
                    if hm:
                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
                    else:
                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
                elif "today" in msg_text_for_parsing.lower():
                    base = dt.date.today()
                    time_frag = _extract_time_fragment(msg_text_for_parsing)
                    hm = spoken_time_to_hm(time_frag)
                    if hm:
                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
                    else:
                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
                else:
                    # weekdays anywhere in phrase
                    for wd, idx in _WEEKDAYS.items():
                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
                            days_ahead = (idx - dt.date.today().weekday()) % 7
                            if days_ahead == 0:
                                days_ahead = 7
                            target = dt.date.today() + dt.timedelta(days=days_ahead)
                            time_frag = _extract_time_fragment(msg_text_for_parsing)
                            hm = spoken_time_to_hm(time_frag)
                            if hm:
                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
                            else:
                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
                            break
            # explicit date + time
            if parsed_dt is None:
                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
                date_val = None
                if m_date_iso:
                    date_val = m_date_iso.group(1)
                elif m_date_slash:
                    try:
                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
                        date_val = d.isoformat()
                    except:
                        date_val = None
                time_frag = _extract_time_fragment(msg_text_for_parsing)
                hm = spoken_time_to_hm(time_frag)
                if date_val and hm:
                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
                elif hm:
                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
                    if cand < dt.datetime.now():
                        cand = cand + dt.timedelta(days=1)
                    parsed_dt = cand
            # fallback: try to extract time only and schedule next occurrence
            if parsed_dt is None:
                time_frag = _extract_time_fragment(msg_text_for_parsing)
                hm = spoken_time_to_hm(time_frag)
                if hm:
                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
                    if cand < dt.datetime.now():
                        cand += dt.timedelta(days=1)
                    parsed_dt = cand
        except Exception:
            parsed_dt = None

        date_value = None; time_value = None
        if parsed_dt:
            date_value = parsed_dt.date().isoformat()
            time_value = parsed_dt.time().strftime("%H:%M")
        else:
            # interactively ask if missing
            title_candidate = subject or extract_title_from_text(subject)
            if not date_value:
                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
                if resp:
                    rtxt = _resp_to_text(resp).lower()
                    if "tomorrow" in rtxt:
                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
                    elif "today" in rtxt:
                        date_value = dt.date.today().isoformat()
                    else:
                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
                        if m_iso:
                            date_value = m_iso.group(1)
                        elif m_slash:
                            try:
                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
                                date_value = d.isoformat()
                            except:
                                date_value = None
            if not time_value:
                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
                if resp:
                    rv = None
                    try:
                        rtxt = _resp_to_text(resp)
                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
                        if m_rel:
                            num_phrase = m_rel.group(2).strip()
                            unit = m_rel.group(3)
                            try: num = int(num_phrase)
                            except: num = words_to_number(num_phrase)
                            if num is not None:
                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
                        if rv:
                            parsed_dt = rv
                            date_value = parsed_dt.date().isoformat()
                            time_value = parsed_dt.time().strftime("%H:%M")
                        else:
                            time_frag = _extract_time_fragment(rtxt)
                            hm = spoken_time_to_hm(time_frag)
                            if hm:
                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
                    except Exception:
                        pass
            if not parsed_dt:
                if not date_value:
                    date_value = dt.date.today().isoformat()
                if not time_value:
                    time_value = "09:00"
            try:
                parsed_date = dt.date.fromisoformat(date_value)
            except Exception:
                parsed_date = dt.date.today()
            try:
                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
            except Exception:
                hm = spoken_time_to_hm(time_value)
                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
            final_dt = dt.datetime.combine(parsed_date, parsed_time)
            parsed_dt = final_dt

        # prepare recurrence parsing
        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
        # build list of event datetimes from recurrence spec
        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
        if not occurrences:
            occurrences = [parsed_dt] if parsed_dt else []

        # confirm creation. If multiple events, summarise count.
        if len(occurrences) == 1:
            final_dt = occurrences[0]
            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
            if not confirmed:
                _speak("Okay, I will not save that reminder.")
                return
            try:
                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'),
                                         duration_minutes=60, reminder_minutes=15, description="Created by Alfred",
                                         event_type="reminder",
                                         username=speaker, score=score, gender=gender, gender_conf=gender_conf)
                try:
                    _set_reminder_speaking(True)
                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
                finally:
                    _set_reminder_speaking(False)
                if gui is not None and hasattr(gui, "log_query"):
                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
            except Exception as e:
                print("Error adding event:", e)
                _speak("Failed to save reminder.")
            return
        else:
            # multiple occurrences -> ask for confirmation with brief summary
            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
            if not confirmed:
                _speak("Okay, I will not save those reminders.")
                return
            created = 0
            for d in occurrences:
                try:
                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"),
                                             duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)",
                                             event_type="reminder",
                                             username=speaker, score=score, gender=gender, gender_conf=gender_conf)
                    created += 1
                except Exception as e:
                    print("Error adding recurring event:", e)
            try:
                _set_reminder_speaking(True)
                _speak(f"Created {created} reminders for '{title_candidate}'.")
            finally:
                _set_reminder_speaking(False)
            if gui is not None and hasattr(gui, "log_query"):
                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
            return

    # READ schedule
    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
        _speak("Checking your reminders and schedule.")
        quick = _read_all_reminders()
        dated = []
        for ev in organizer_events:
            try:
                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
                # build metadata string in requested format
                meta_parts = []
                if ev.get("username") is not None:
                    meta_parts.append(f"'username':{ev.get('username')}")
                else:
                    # still include username key for consistent playback format
                    meta_parts.append(f"'username':None")
                meta_parts.append(f"'score':{ev.get('score')!s}")
                meta_parts.append(f"'gender':{ev.get('gender')!s}")
                meta_parts.append(f"'gender_conf':{ev.get('gender_conf')!s}")
                meta_str = " : ".join(meta_parts)
                dated.append(f"{ev.get('title','(no title)')} : {meta_str} at {dobj.strftime('%Y-%m-%d %H:%M')}")
            except Exception:
                # fallback without dt
                meta_parts = []
                if ev.get("username") is not None:
                    meta_parts.append(f"'username':{ev.get('username')}")
                else:
                    meta_parts.append(f"'username':None")
                meta_parts.append(f"'score':{ev.get('score')!s}")
                meta_parts.append(f"'gender':{ev.get('gender')!s}")
                meta_parts.append(f"'gender_conf':{ev.get('gender_conf')!s}")
                meta_str = " : ".join(meta_parts)
                dated.append(f"{ev.get('title','(no title)')} : {meta_str}")
        out_parts = []
        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
        if out_parts:
            out = " . ".join(out_parts)
            try:
                _set_reminder_speaking(True)
                _speak(out); _send_bluetooth(out)
            finally:
                _set_reminder_speaking(False)
        else:
            _speak("You have no reminders or scheduled events I can see right now.")
        return

# start notifier when module imported
start_reminder_notifier_thread()






















###     LAST WORKING BEST BAD DESCRIPTION 2026_01_27__00h50
###
### reminders_module.py (fixed)
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##import calendar
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
##    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
##    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp).lower()
##        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
##            return True
##        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
##            return False
##        # fallback: first token
##        tokens = re.findall(r"[a-z]+", resp_text)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    """
##    Returns: (message, speaker/username, score, gender, gender_conf)
##
##    Behavior:
##      - dict: uses keys text/query/message/q and username/speaker/user
##      - strings:
##        * will detect and extract triple-single-quote wrappers '''...''' (or ``` fences)
##        * will find trailing metadata like:
##            : 'username':ITF : 'score':None : 'gender':None : 'gender_conf':None
##        * returns safe_str(text), speaker (or None), score(float or None),
##          gender (or None), gender_conf(float or None)
##    """
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() in ("none", "null", ""):
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf/username) and split ---
##        meta_idx = None
##        m = re.search(r"\b(?:username|user|speaker|score|gender|gender_conf)\b\s*[:=]", s, flags=re.I)
##        if m:
##            meta_idx = m.start()
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # generic key:value regex for the keys we care about
##            kv_pattern = re.compile(
##                r"(?:'|\")?(?P<k>username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]\s*(?:'(?P<vq>[^']*)'|\"(?P<vqq>[^\"]*)\"|(?P<vn>[^:\n]+))",
##                flags=re.I
##            )
##            parsed_meta = {}
##            for mm in kv_pattern.finditer(meta_part):
##                k = mm.group('k').lower()
##                v = mm.group('vq') if mm.group('vq') is not None else (mm.group('vqq') if mm.group('vqq') is not None else mm.group('vn'))
##                if v is not None:
##                    parsed_meta[k] = v.strip()
##
##            # extract values if present
##            if 'score' in parsed_meta:
##                score_val = _to_float_or_none(parsed_meta.get('score'))
##            if 'gender' in parsed_meta:
##                gv = parsed_meta.get('gender')
##                gender_val = None if (gv is None or gv.strip().lower() in ('none','null','')) else safe_str(gv)
##            if 'gender_conf' in parsed_meta:
##                gender_conf_val = _to_float_or_none(parsed_meta.get('gender_conf'))
##            if 'username' in parsed_meta:
##                speaker_val = parsed_meta.get('username')
##            elif 'user' in parsed_meta:
##                speaker_val = parsed_meta.get('user')
##            elif 'speaker' in parsed_meta:
##                speaker_val = parsed_meta.get('speaker')
##
##            # fallback: leftover tokens in meta_part that aren't known keys -> speaker
##            try:
##                meta_clean = kv_pattern.sub('', meta_part)
##                leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##                if leftovers and not speaker_val:
##                    for token in reversed(leftovers):
##                        if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                            speaker_val = token
##                            break
##            except Exception:
##                pass
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
##                    or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker and not speaker_val:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm using the whole phrase and remove those tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' -> compute
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock'
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens e.g., 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token -> hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) digits cluster like 930
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### -------------------------
### NEW HELPER: extract small time fragment from full utterance
### -------------------------
### Reason: passing the entire utterance (which may include "for the next two weeks")
### into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
### This helper finds a concise time-like substring and returns it.
##def _extract_time_fragment(text: str) -> str:
##    if not text:
##        return ""
##    t = safe_str(text).lower()
##    patterns = [
##        r"\bhalf past [a-z0-9 ]{1,20}\b",
##        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
##        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
##        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
##        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
##        r"\b(?:noon|midnight)\b",
##        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
##    ]
##    for pat in patterns:
##        m = re.search(pat, t, flags=re.I)
##        if m:
##            return m.group(0)
##    # fallback: try to find a short "X Y" token near "at" or near start
##    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
##    if m_at:
##        frag = m_at.group(1).strip()
##        # keep only first few words
##        frag = " ".join(frag.split()[:4])
##        return frag
##    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
##    return t
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        # include metadata in DESCRIPTION so ICS contains it
##        metadata_desc = []
##        if ev.get("username") is not None:
##            metadata_desc.append(f"username:{ev.get('username')}")
##        metadata_desc.append(f"score:{ev.get('score')!s}")
##        metadata_desc.append(f"gender:{ev.get('gender')!s}")
##        metadata_desc.append(f"gender_conf:{ev.get('gender_conf')!s}")
##        description = ev.get('description','') + " | " + " ; ".join(metadata_desc)
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{description}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##    return _unique_sorted_times(candidates)
##
### ---------- add event ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder",
##                        username: Optional[str] = None, score: Optional[float] = None,
##                        gender: Optional[str] = None, gender_conf: Optional[float] = None) -> dict:
##    """
##    Create an event and store metadata fields username/score/gender/gender_conf inside the event dict.
##    """
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False,
##              # store the metadata requested
##              "username": (safe_str(username) if username is not None else None),
##              "score": (float(score) if score is not None else None),
##              "gender": (safe_str(gender) if gender is not None else None),
##              "gender_conf": (float(gender_conf) if gender_conf is not None else None),
##              }
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##            # ensure metadata keys exist (migration-friendly)
##            if "username" not in ev:
##                ev["username"] = ev.get("username", None)
##                changed = True
##            if "score" not in ev:
##                ev["score"] = ev.get("score", None)
##                changed = True
##            if "gender" not in ev:
##                ev["gender"] = ev.get("gender", None)
##                changed = True
##            if "gender_conf" not in ev:
##                ev["gender_conf"] = ev.get("gender_conf", None)
##                changed = True
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### -------------------------
### NEW: cleanup fired events
### -------------------------
##def _cleanup_fired_events():
##    """
##    Remove events that have already had all their notify_times fired.
##    Also delete associated ICS files when removing.
##    """
##    global organizer_events
##    try:
##        with _NOTIFIER_THREAD_LOCK:
##            now = dt.datetime.now()
##            kept = []
##            removed_any = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    # if there are notify times and all are fired -> remove
##                    if nts and all(bool(item.get("fired", False)) for item in nts):
##                        # delete ICS if present
##                        ics = ev.get("ics_path")
##                        try:
##                            if ics and os.path.exists(ics):
##                                os.remove(ics)
##                        except Exception:
##                            pass
##                        removed_any = True
##                        continue
##                    # fallback: if no notify_times but 'notified' True and dtstart in past -> remove
##                    if (not nts or len(nts) == 0) and ev.get("notified", False):
##                        try:
##                            dtstart = dt.datetime.fromisoformat(ev.get("dtstart"))
##                            if dtstart < now:
##                                ics = ev.get("ics_path")
##                                try:
##                                    if ics and os.path.exists(ics):
##                                        os.remove(ics)
##                                except Exception:
##                                    pass
##                                removed_any = True
##                                continue
##                        except Exception:
##                            pass
##                    # otherwise keep
##                    kept.append(ev)
##                except Exception:
##                    kept.append(ev)
##            if removed_any:
##                organizer_events = kept
##                _save_organizer_events()
##    except Exception as e:
##        print("_cleanup_fired_events error:", e)
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- recurrence parsing & expansion helpers ----------
##def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
##    """Add months safely to a datetime (preserves day where possible)."""
##    year = date_obj.year + (date_obj.month - 1 + months) // 12
##    month = (date_obj.month - 1 + months) % 12 + 1
##    # find last day of target month
##    last_day = calendar.monthrange(year, month)[1]
##    day = min(date_obj.day, last_day)
##    try:
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##    except Exception:
##        # fallback simple approximation
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##
##def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
##    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
##    s = safe_str(text).lower()
##    # explicit tomorrow
##    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
##        out["explicit_tomorrow"] = True
##    # everyday / daily
##    if re.search(r'\bevery (day|everyday)\b', s):
##        out["type"] = "daily"
##        out["interval"] = 1
##    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
##        out["type"] = "every_n_days"; out["interval"] = 2
##    # every N days like 'every 3 days'
##    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
##    if m3:
##        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
##        except: pass
##    # weekly / every X weeks
##    if re.search(r'\bevery (week|weekly)\b', s):
##        out["type"] = "weekly"; out["interval"] = 1
##    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
##    if m4:
##        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
##        except: pass
##    if re.search(r'\bevery second week\b') or re.search(r'\bevery 2 weeks\b'):
##        out["type"] = "every_n_weeks"; out["interval"]=2
##    # weekday like "every Monday"
##    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
##    if mwd:
##        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
##        out["interval"] = 1
##    # "for the month" or span days hints
##    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
##        out["span_days"] = 30
##    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
##    if m_next:
##        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)*7
##    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
##    if m_nextd:
##        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)
##    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
##        out["type"] = "monthly"
##        out["months"] = 12 if 'of the year' in s else 1
##    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
##        today = dt.date.today()
##        days_left = 7 - today.weekday()
##        out["span_days"] = days_left
##        out["type"] = "daily"
##    return out
##
##def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
##    out: List[dt.datetime] = []
##    if base_dt is None:
##        return out
##    span_days = rec_spec.get("span_days", 30)
##    end_date = base_dt + dt.timedelta(days=span_days)
##    typ = rec_spec.get("type", "none")
##    interval = int(rec_spec.get("interval", 1) or 1)
##
##    # always include base_dt as first occurrence
##    out.append(base_dt)
##
##    if rec_spec.get("explicit_tomorrow"):
##        tomorrow_dt = base_dt + dt.timedelta(days=1)
##        out.append(tomorrow_dt)
##
##    if typ in ("daily",) and typ != "none":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_days":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ in ("weekly","every_n_weeks"):
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "weekday" and rec_spec.get("weekday") is not None:
##        wd = int(rec_spec.get("weekday"))
##        candidate = base_dt
##        if candidate.weekday() != wd:
##            days_ahead = (wd - candidate.weekday()) % 7
##            candidate = candidate + dt.timedelta(days=days_ahead)
##        while candidate <= end_date:
##            if candidate >= base_dt:
##                out.append(candidate)
##            candidate = candidate + dt.timedelta(weeks=1)
##    elif typ == "monthly":
##        months_to_create = int(rec_spec.get("months", 1) or 1)
##        current = base_dt
##        for i in range(1, months_to_create):
##            current = add_months(current, 1)
##            if current <= end_date + dt.timedelta(days=1):
##                out.append(current)
##
##    # dedupe & sort
##    uniq = {}
##    for d in out:
##        try:
##            iso = d.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = d
##        except Exception:
##            continue
##    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return final
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # include metadata in spoken message if present
##        meta_str = ""
##        if ev.get("username") is not None:
##            meta_str = f" : 'username':{ev.get('username')} : 'score':{ev.get('score')!s} : 'gender':{ev.get('gender')!s} : 'gender_conf':{ev.get('gender_conf')!s}"
##        _speak(f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}{meta_str}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            if now >= notify_dt:
##                                nt['fired'] = True
##                                # mark that the event has had at least one notify fired
##                                ev["notified"] = True
##                                changed = True
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##                # cleanup fully fired events to keep the schedule file tidy
##                try:
##                    _cleanup_fired_events()
##                except Exception as _e:
##                    print("cleanup error after save:", _e)
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
### cleanup any already-fired events on load as well
##_cleanup_fired_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##    k = ""
##    # triggers for create/set reminders
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##            speaker = None; score = None; gender = None; gender_conf = None
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for parsing, but derive a clean subject
##        original_for_parsing = msg_text
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
##        try:
##            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
##            for f in fillers:
##                subject = re.sub(f, "", subject, flags=re.I)
##            # remove extra whitespace & punctuation
##            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
##        except Exception as _e:
##            print("subject filler clean error:", _e)
##            subject = subject.strip()
##
##        subject = subject.replace("ing","")
##        
##        # If subject empty, ask first what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        if not subject:
##            # cannot determine subject -> save quick reminder
##            # include metadata in the quick reminder line if present
##            meta_str = ""
##            if speaker is not None:
##                meta_str = f" : 'username':{speaker} : 'score':{safe_str(score)!s} : 'gender':{safe_str(gender)!s} : 'gender_conf':{safe_str(gender_conf)!s}"
##            _append_lines_to_file([original_for_parsing + meta_str])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now parse date/time from the original utterance (so time tokens are preserved)
##        msg_text_for_parsing = original_for_parsing
##
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # relative expressions first
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            # if not relative, try explicit date/time
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays anywhere in phrase
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0:
##                                days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            time_frag = _extract_time_fragment(msg_text_for_parsing)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            # explicit date + time
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            # fallback: try to extract time only and schedule next occurrence
##            if parsed_dt is None:
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # interactively ask if missing
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            time_frag = _extract_time_fragment(rtxt)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare recurrence parsing
##        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
##        # build list of event datetimes from recurrence spec
##        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
##        if not occurrences:
##            occurrences = [parsed_dt] if parsed_dt else []
##
##        # confirm creation. If multiple events, summarise count.
##        if len(occurrences) == 1:
##            final_dt = occurrences[0]
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save that reminder.")
##                return
##            try:
##                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'),
##                                         duration_minutes=60, reminder_minutes=15, description="Created by Alfred",
##                                         event_type="reminder",
##                                         username=speaker, score=score, gender=gender, gender_conf=gender_conf)
##                try:
##                    _set_reminder_speaking(True)
##                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##                finally:
##                    _set_reminder_speaking(False)
##                if gui is not None and hasattr(gui, "log_query"):
##                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##            except Exception as e:
##                print("Error adding event:", e)
##                _speak("Failed to save reminder.")
##            return
##        else:
##            # multiple occurrences -> ask for confirmation with brief summary
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
##            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
##            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save those reminders.")
##                return
##            created = 0
##            for d in occurrences:
##                try:
##                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"),
##                                             duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)",
##                                             event_type="reminder",
##                                             username=speaker, score=score, gender=gender, gender_conf=gender_conf)
##                    created += 1
##                except Exception as e:
##                    print("Error adding recurring event:", e)
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Created {created} reminders for '{title_candidate}'.")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
##            return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                # build metadata string in requested format
##                meta_parts = []
##                if ev.get("username") is not None:
##                    meta_parts.append(f"'username':{ev.get('username')}")
##                else:
##                    # still include username key for consistent playback format
##                    meta_parts.append(f"'username':None")
##                meta_parts.append(f"'score':{ev.get('score')!s}")
##                meta_parts.append(f"'gender':{ev.get('gender')!s}")
##                meta_parts.append(f"'gender_conf':{ev.get('gender_conf')!s}")
##                meta_str = " : ".join(meta_parts)
##                dated.append(f"{ev.get('title','(no title)')} : {meta_str} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                # fallback without dt
##                meta_parts = []
##                if ev.get("username") is not None:
##                    meta_parts.append(f"'username':{ev.get('username')}")
##                else:
##                    meta_parts.append(f"'username':None")
##                meta_parts.append(f"'score':{ev.get('score')!s}")
##                meta_parts.append(f"'gender':{ev.get('gender')!s}")
##                meta_parts.append(f"'gender_conf':{ev.get('gender_conf')!s}")
##                meta_str = " : ".join(meta_parts)
##                dated.append(f"{ev.get('title','(no title)')} : {meta_str}")
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##






















##
###     LAST WORKING BEST BAD DESCRIPTION 2026_02_06__22h50
###
### reminders_module.py (fixed)
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##import calendar
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
##    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
##    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp).lower()
##        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
##            return True
##        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
##            return False
##        # fallback: first token
##        tokens = re.findall(r"[a-z]+", resp_text)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##
##
##
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    """More robust extractor that handles dicts, stringified dicts, and trailing
##    colon-separated metadata like:
##      "... : 'username':ITF : 'score':None : 'gender':None : 'gender_conf':None"
##
##    Returns: (text, speaker, score, gender, gender_conf)
##    """
##    if query is None:
##        return "", None, None, None, None
##
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() in ("none", "null", ""):
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    # handle dict quickly (preserve behaviour)
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    # strings (robust)
##    if isinstance(query, str):
##        s_orig = query
##        s = s_orig.strip()
##
##        # try base64 decode if it *looks* like base64
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # strip common leading timestamp wrapper
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # find where metadata likely begins by searching for any known meta key
##        meta_start = None
##        m = re.search(r"\b(?:username|user|speaker|score|gender|gender_conf)\b\s*[:=]", s, flags=re.I)
##        if m:
##            meta_start = m.start()
##
##        body = s
##        meta_part = ""
##        if meta_start is not None:
##            body = s[:meta_start].rstrip(" :")
##            meta_part = s[meta_start:]
##
##        # parse key:value pairs from meta_part and also from body as fallback
##        kv_re = re.compile(r"(?:'|\")?(?P<k>username|user|speaker|score|gender|gender_conf)(?:'|\")?\s*[:=]\s*(?:'(?P<vq>[^']*)'|\"(?P<vqq>[^\"]*)\"|(?P<vn>[^:\n]+))", flags=re.I)
##        parsed = {}
##        try:
##            for m in kv_re.finditer(meta_part):
##                k = m.group('k').lower()
##                v = m.group('vq') if m.group('vq') is not None else (m.group('vqq') if m.group('vqq') is not None else m.group('vn'))
##                if v is not None:
##                    parsed[k] = v.strip()
##        except Exception:
##            parsed = {}
##
##        # also try to find in body if not found
##        if 'username' not in parsed and 'speaker' not in parsed and body:
##            try:
##                for m in kv_re.finditer(body):
##                    k = m.group('k').lower()
##                    v = m.group('vq') if m.group('vq') is not None else (m.group('vqq') if m.group('vqq') is not None else m.group('vn'))
##                    if v is not None:
##                        parsed[k] = v.strip()
##            except Exception:
##                pass
##
##        # extract values
##        speaker_val = None
##        if 'username' in parsed:
##            speaker_val = parsed.get('username')
##        elif 'user' in parsed:
##            speaker_val = parsed.get('user')
##        elif 'speaker' in parsed:
##            speaker_val = parsed.get('speaker')
##
##        score_val = _to_float_or_none(parsed.get('score')) if parsed.get('score') is not None else None
##        gender_val = parsed.get('gender')
##        if isinstance(gender_val, str) and gender_val.lower() in ('none', 'null', ''):
##            gender_val = None
##        gender_conf_val = _to_float_or_none(parsed.get('gender_conf')) if parsed.get('gender_conf') is not None else None
##
##        # if still no speaker found, attempt leftover token heuristics from meta_part
##        if not speaker_val and meta_part:
##            # strip all key:values and split remaining tokens
##            try:
##                tmp = kv_re.sub('', meta_part)
##                tokens = [t.strip() for t in re.split(r'[:\n]', tmp) if t.strip()]
##                for tok in reversed(tokens):
##                    if tok.lower() not in ('score','gender','gender_conf','none','null'):
##                        speaker_val = tok
##                        break
##            except Exception:
##                pass
##
##        # now parse message text inside body: look for explicit 'text' key, else use whole body
##        m_text = re.search(r"(?:'text'|\"text\"|\btext\b)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        if m_text:
##            text_val = safe_str(m_text.group('t'))
##        else:
##            text_val = body
##
##        # final speaker cleanup
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "):
##                speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == 'none':
##                speaker_val = None
##
##        return safe_str(text_val), (safe_str(speaker_val) if speaker_val else None), score_val, (safe_str(gender_val) if gender_val else None), gender_conf_val
##
##    # fallback
##    return safe_str(query), None, None, None, None
##
##
####def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
####    if query is None:
####        return "", None, None, None, None
####
####    # Helper to parse numeric-or-None strings
####    def _to_float_or_none(v):
####        if v is None:
####            return None
####        if isinstance(v, (float, int)):
####            return float(v)
####        s = str(v).strip()
####        if s.lower() == "none" or s == "":
####            return None
####        try:
####            return float(s)
####        except Exception:
####            return None
####
####    if isinstance(query, dict):
####        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
####        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
####        score_ = query.get("score")
####        gender_ = query.get("gender")
####        gender_conf_ = query.get("gender_conf")
####        if isinstance(speaker_, str):
####            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
####            if s.lower().startswith("none "): s = s[5:].strip()
####            speaker_ = None if s.lower() == "none" else s
####        try: score_f = float(score_) if score_ is not None else None
####        except: score_f = None
####        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
####        except: gconf_f = None
####        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
####
####    if isinstance(query, str):
####        original = query
####        s = query.strip()
####
####        # --- try base64 decode if it looks like base64 (unchanged) ---
####        try:
####            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
####                try:
####                    decoded = base64.b64decode(s).decode('utf-8')
####                    if decoded:
####                        s = decoded.strip()
####                except Exception:
####                    pass
####        except Exception:
####            pass
####
####        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
####        try:
####            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
####            if not dt_match:
####                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
####            if not dt_match:
####                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
####            if dt_match:
####                s = s[dt_match.end():].lstrip()
####        except Exception:
####            pass
####
####        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
####        meta_idx = None
####        for key in ("'score'", '"score"', "score"):
####            m = re.search(r'\s*:\s*' + re.escape(key), s)
####            if m:
####                meta_idx = m.start()
####                break
####        if meta_idx is None:
####            for key in ("'score'", '"score"', "score"):
####                m = re.search(re.escape(key) + r'\s*[:=]', s)
####                if m:
####                    meta_idx = m.start()
####                    break
####
####        meta_part = ""
####        body = s
####        if meta_idx is not None:
####            body = s[:meta_idx].rstrip(" :")
####            meta_part = s[meta_idx:].lstrip(" :")
####
####        # If meta_part present parse score/gender/gender_conf and final speaker token
####        score_val = None
####        gender_val = None
####        gender_conf_val = None
####        speaker_val = None
####
####        if meta_part:
####            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
####                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
####                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
####            if m_score:
####                score_val = _to_float_or_none(m_score.group("v"))
####            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
####                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
####                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
####            if m_gender:
####                gv = m_gender.group("v").strip()
####                gender_val = None if gv.lower() == "none" else safe_str(gv)
####            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
####                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
####                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
####            if m_gconf:
####                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
####
####            meta_clean = meta_part
####            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
####
####            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
####            if leftovers:
####                for token in reversed(leftovers):
####                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
####                        speaker_val = token
####                        break
####
####        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
####        if score_val is None:
####            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
####                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
####            if m_score2:
####                score_val = _to_float_or_none(m_score2.group("v"))
####                body = body[:m_score2.start()].rstrip(" :")
####
####        if gender_val is None:
####            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
####                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
####            if m_gender2:
####                gv = m_gender2.group("v").strip()
####                gender_val = None if gv.lower() == "none" else safe_str(gv)
####                body = body[:m_gender2.start()].rstrip(" :")
####
####        if gender_conf_val is None:
####            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
####                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
####            if m_gconf2:
####                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
####                body = body[:m_gconf2.start()].rstrip(" :")
####
####        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
####        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
####        if looks_like_dict:
####            try:
####                parsed = ast.literal_eval(body)
####                if isinstance(parsed, dict):
####                    return extract_text_from_query(parsed)
####            except Exception:
####                try:
####                    parsed = json.loads(body)
####                    if isinstance(parsed, dict):
####                        return extract_text_from_query(parsed)
####                except Exception:
####                    pass
####
####        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
####        text_val = safe_str(m_text.group("t")) if m_text else body
####
####        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
####        if m_speaker:
####            speaker_val = safe_str(m_speaker.group("s"))
####
####        # post-process speaker found earlier (trim device suffixes and "none")
####        if isinstance(speaker_val, str):
####            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
####            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
####            if speaker_val.lower() == "none": speaker_val = None
####
####        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
####
####    # final fallback
####    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm using the whole phrase and remove those tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' -> compute
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock'
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens e.g., 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token -> hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) digits cluster like 930
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### -------------------------
### NEW HELPER: extract small time fragment from full utterance
### -------------------------
### Reason: passing the entire utterance (which may include "for the next two weeks")
### into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
### This helper finds a concise time-like substring and returns it.
##def _extract_time_fragment(text: str) -> str:
##    if not text:
##        return ""
##    t = safe_str(text).lower()
##    patterns = [
##        r"\bhalf past [a-z0-9 ]{1,20}\b",
##        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
##        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
##        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
##        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
##        r"\b(?:noon|midnight)\b",
##        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
##    ]
##    for pat in patterns:
##        m = re.search(pat, t, flags=re.I)
##        if m:
##            return m.group(0)
##    # fallback: try to find a short "X Y" token near "at" or near start
##    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
##    if m_at:
##        frag = m_at.group(1).strip()
##        # keep only first few words
##        frag = " ".join(frag.split()[:4])
##        return frag
##    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
##    return t
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##    return _unique_sorted_times(candidates)
##
### ---------- add event ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### -------------------------
### NEW: cleanup fired events
### -------------------------
##def _cleanup_fired_events():
##    """
##    Remove events that have already had all their notify_times fired.
##    Also delete associated ICS files when removing.
##    """
##    global organizer_events
##    try:
##        with _NOTIFIER_THREAD_LOCK:
##            now = dt.datetime.now()
##            kept = []
##            removed_any = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    # if there are notify times and all are fired -> remove
##                    if nts and all(bool(item.get("fired", False)) for item in nts):
##                        # delete ICS if present
##                        ics = ev.get("ics_path")
##                        try:
##                            if ics and os.path.exists(ics):
##                                os.remove(ics)
##                        except Exception:
##                            pass
##                        removed_any = True
##                        continue
##                    # fallback: if no notify_times but 'notified' True and dtstart in past -> remove
##                    if (not nts or len(nts) == 0) and ev.get("notified", False):
##                        try:
##                            dtstart = dt.datetime.fromisoformat(ev.get("dtstart"))
##                            if dtstart < now:
##                                ics = ev.get("ics_path")
##                                try:
##                                    if ics and os.path.exists(ics):
##                                        os.remove(ics)
##                                except Exception:
##                                    pass
##                                removed_any = True
##                                continue
##                        except Exception:
##                            pass
##                    # otherwise keep
##                    kept.append(ev)
##                except Exception:
##                    kept.append(ev)
##            if removed_any:
##                organizer_events = kept
##                _save_organizer_events()
##    except Exception as e:
##        print("_cleanup_fired_events error:", e)
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- recurrence parsing & expansion helpers ----------
##def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
##    """Add months safely to a datetime (preserves day where possible)."""
##    year = date_obj.year + (date_obj.month - 1 + months) // 12
##    month = (date_obj.month - 1 + months) % 12 + 1
##    # find last day of target month
##    last_day = calendar.monthrange(year, month)[1]
##    day = min(date_obj.day, last_day)
##    try:
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##    except Exception:
##        # fallback simple approximation
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##
##def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
##    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
##    s = safe_str(text).lower()
##    # explicit tomorrow
##    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
##        out["explicit_tomorrow"] = True
##    # everyday / daily
##    if re.search(r'\bevery (day|everyday)\b', s):
##        out["type"] = "daily"
##        out["interval"] = 1
##    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
##        out["type"] = "every_n_days"; out["interval"] = 2
##    # every N days like 'every 3 days'
##    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
##    if m3:
##        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
##        except: pass
##    # weekly / every X weeks
##    if re.search(r'\bevery (week|weekly)\b', s):
##        out["type"] = "weekly"; out["interval"] = 1
##    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
##    if m4:
##        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
##        except: pass
##    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
##        out["type"] = "every_n_weeks"; out["interval"]=2
##    # weekday like "every Monday"
##    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
##    if mwd:
##        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
##        out["interval"] = 1
##    # "for the month" or span days hints
##    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
##        out["span_days"] = 30
##    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
##    if m_next:
##        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)*7
##    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
##    if m_nextd:
##        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)
##    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
##        out["type"] = "monthly"
##        out["months"] = 12 if 'of the year' in s else 1
##    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
##        today = dt.date.today()
##        days_left = 7 - today.weekday()
##        out["span_days"] = days_left
##        out["type"] = "daily"
##    return out
##
##def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
##    out: List[dt.datetime] = []
##    if base_dt is None:
##        return out
##    span_days = rec_spec.get("span_days", 30)
##    end_date = base_dt + dt.timedelta(days=span_days)
##    typ = rec_spec.get("type", "none")
##    interval = int(rec_spec.get("interval", 1) or 1)
##
##    # always include base_dt as first occurrence
##    out.append(base_dt)
##
##    if rec_spec.get("explicit_tomorrow"):
##        tomorrow_dt = base_dt + dt.timedelta(days=1)
##        out.append(tomorrow_dt)
##
##    if typ in ("daily",) and typ != "none":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_days":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ in ("weekly","every_n_weeks"):
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "weekday" and rec_spec.get("weekday") is not None:
##        wd = int(rec_spec.get("weekday"))
##        candidate = base_dt
##        if candidate.weekday() != wd:
##            days_ahead = (wd - candidate.weekday()) % 7
##            candidate = candidate + dt.timedelta(days=days_ahead)
##        while candidate <= end_date:
##            if candidate >= base_dt:
##                out.append(candidate)
##            candidate = candidate + dt.timedelta(weeks=1)
##    elif typ == "monthly":
##        months_to_create = int(rec_spec.get("months", 1) or 1)
##        current = base_dt
##        for i in range(1, months_to_create):
##            current = add_months(current, 1)
##            if current <= end_date + dt.timedelta(days=1):
##                out.append(current)
##
##    # dedupe & sort
##    uniq = {}
##    for d in out:
##        try:
##            iso = d.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = d
##        except Exception:
##            continue
##    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return final
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            if now >= notify_dt:
##                                nt['fired'] = True
##                                # mark that the event has had at least one notify fired
##                                ev["notified"] = True
##                                changed = True
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##                # cleanup fully fired events to keep the schedule file tidy
##                try:
##                    _cleanup_fired_events()
##                except Exception as _e:
##                    print("cleanup error after save:", _e)
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
### cleanup any already-fired events on load as well
##_cleanup_fired_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##    k = ""
##    # triggers for create/set reminders
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for parsing, but derive a clean subject
##        original_for_parsing = msg_text
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
##        try:
##            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
##            for f in fillers:
##                subject = re.sub(f, "", subject, flags=re.I)
##            # remove extra whitespace & punctuation
##            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
##        except Exception as _e:
##            print("subject filler clean error:", _e)
##            subject = subject.strip()
##
##        subject = subject.replace("ing","")
##        
##        # If subject empty, ask first what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        if not subject:
##            # cannot determine subject -> save quick reminder
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now parse date/time from the original utterance (so time tokens are preserved)
##        msg_text_for_parsing = original_for_parsing
##
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # relative expressions first
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            # if not relative, try explicit date/time
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays anywhere in phrase
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0:
##                                days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            time_frag = _extract_time_fragment(msg_text_for_parsing)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            # explicit date + time
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            # fallback: try to extract time only and schedule next occurrence
##            if parsed_dt is None:
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # interactively ask if missing
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            time_frag = _extract_time_fragment(rtxt)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare recurrence parsing
##        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
##        # build list of event datetimes from recurrence spec
##        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
##        if not occurrences:
##            occurrences = [parsed_dt] if parsed_dt else []
##
##        # confirm creation. If multiple events, summarise count.
##        if len(occurrences) == 1:
##            final_dt = occurrences[0]
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save that reminder.")
##                return
##            try:
##                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##                try:
##                    _set_reminder_speaking(True)
##                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##                finally:
##                    _set_reminder_speaking(False)
##                if gui is not None and hasattr(gui, "log_query"):
##                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##            except Exception as e:
##                print("Error adding event:", e)
##                _speak("Failed to save reminder.")
##            return
##        else:
##            # multiple occurrences -> ask for confirmation with brief summary
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
##            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
##            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save those reminders.")
##                return
##            created = 0
##            for d in occurrences:
##                try:
##                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)", event_type="reminder")
##                    created += 1
##                except Exception as e:
##                    print("Error adding recurring event:", e)
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Created {created} reminders for '{title_candidate}'.")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
##            return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##






























#####     LAST WORKING BEST BAD DESCRIPTION 2026_01_27__00h50
#####
##### reminders_module.py (fixed + pruning of completed events + save original query metadata)
####from __future__ import annotations
####import re
####import os
####import json
####import base64
####import ast
####import uuid
####import time
####import threading
####from typing import List, Optional, Tuple, Dict, Any
####import datetime as dt
####import calendar
####
##### try to reuse your project's speech/listen objects if available
####try:
####    from speech import speech
####except Exception:
####    speech = None
####try:
####    from listen import listen
####except Exception:
####    listen = None
####
##### ---------- small helpers ----------
####def safe_str(val) -> str:
####    if val is None:
####        return ""
####    if isinstance(val, str):
####        return val.strip()
####    try:
####        return str(val)
####    except Exception:
####        return ""
####
####def _speak(text: str):
####    try:
####        if speech is not None and hasattr(speech, "AlfredSpeak"):
####            speech.AlfredSpeak(str(text))
####            return
####    except Exception:
####        pass
####    print("[ALFRED SPEAK]", text)
####
####def _send_bluetooth(text: str):
####    try:
####        if listen is not None and hasattr(listen, "send_bluetooth"):
####            listen.send_bluetooth(str(text))
####    except Exception:
####        pass
####
##### ---------- reminder-speaking flag (thread-safe) ----------
####REMINDER_SPEAKING_DONT_LISTEN = False
####_REMINDER_SPEAKING_LOCK = threading.Lock()
####
####def _set_reminder_speaking(flag: bool):
####    global REMINDER_SPEAKING_DONT_LISTEN
####    try:
####        with _REMINDER_SPEAKING_LOCK:
####            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
####    except Exception:
####        # best-effort only; swallow errors
####        pass
####
####def get_reminder_speaking_flag() -> bool:
####    try:
####        with _REMINDER_SPEAKING_LOCK:
####            return bool(REMINDER_SPEAKING_DONT_LISTEN)
####    except Exception:
####        return False
####
##### ---------- listen helpers ----------
####import time as _time
####
####def _wait_for_tts_to_finish(max_wait: int = 6):
####    try:
####        if speech is not None:
####            is_speaking_fn = getattr(speech, "is_speaking", None)
####            if callable(is_speaking_fn):
####                start = _time.time()
####                while _time.time() - start < max_wait:
####                    try:
####                        if not bool(is_speaking_fn()):
####                            break
####                    except Exception:
####                        break
####                    _time.sleep(0.12)
####                return
####            if getattr(speech, "_currently_speaking", False):
####                start = _time.time()
####                while _time.time() - start < max_wait:
####                    if not getattr(speech, "_currently_speaking", False):
####                        break
####                    _time.sleep(0.12)
####    except Exception:
####        pass
####
####def _listen_once(timeout: int = 20) -> str:
####    _wait_for_tts_to_finish(max_wait=3)
####    end_time = _time.time() + max(1, int(timeout))
####    while _time.time() < end_time:
####        try:
####            if listen is not None and hasattr(listen, "listen"):
####                got = listen.listen()
####            else:
####                try:
####                    # debug fallback when running module directly
####                    got = input("(debug) type response (or empty): ")
####                except Exception:
####                    got = ""
####            if got:
####                print("[listen] Heard:", got)
####                return got
####        except Exception as e:
####            print("_listen_once listen() error:", e)
####        _time.sleep(0.18)
####    return ""
####
####def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
####    for attempt in range(attempts):
####        _speak(question)
####        _send_bluetooth(question)
####        _time.sleep(0.28)
####        resp = _listen_once(timeout=timeout_per_attempt)
####        if resp:
####            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
####            return resp
####        if attempt + 1 < attempts:
####            _speak("I didn't catch that. Please say it again.")
####            _send_bluetooth("I didn't catch that. Please say it again.")
####            _time.sleep(0.12)
####    print("_ask_question_and_get_response: no reply after attempts")
####    return ""
####
##### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
####def _resp_to_text(resp) -> str:
####    """
####    Normalize responses returned by listen() or other sources into a plain string.
####    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
####    """
####    try:
####        # If it's already a dict or looks like a dict/stringified dict, use extractor
####        if isinstance(resp, dict):
####            text, _, _, _, _ = extract_text_from_query(resp)
####            return safe_str(text)
####        if isinstance(resp, str):
####            # extract_text_from_query safely handles stringified dicts and plain strings
####            text, _, _, _, _ = extract_text_from_query(resp)
####            return safe_str(text)
####        return safe_str(resp)
####    except Exception:
####        try:
####            return safe_str(resp)
####        except Exception:
####            return ""
####
####def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
####    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
####    for i in range(attempts):
####        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
####        if not resp:
####            if i + 1 < attempts:
####                continue
####            return False
####        resp_text = _resp_to_text(resp).lower()
####        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
####            return True
####        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
####            return False
####        # fallback: first token
####        tokens = re.findall(r"[a-z]+", resp_text)
####        if tokens:
####            if tokens[0] in yes_words: return True
####            if tokens[0] in no_words: return False
####        if i + 1 < attempts:
####            _speak("I didn't understand. Please answer yes or no.")
####            _send_bluetooth("I didn't understand. Please answer yes or no.")
####            _time.sleep(0.12)
####    return False
####
##### ---------- words -> numbers ----------
####_UNITS = {
####    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
####    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
####    "seventeen":17,"eighteen":18,"nineteen":19
####}
####_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
####_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
####
####def words_to_number(phrase: str) -> Optional[int]:
####    if phrase is None: return None
####    if not isinstance(phrase, str): phrase = str(phrase)
####    words = re.findall(r"[a-z]+", phrase.lower())
####    if not words: return None
####    total = 0; current = 0; valid = False
####    for w in words:
####        if w in _UNITS:
####            current += _UNITS[w]; valid = True
####        elif w in _TENS:
####            current += _TENS[w]; valid = True
####        elif w in _SCALES:
####            scale = _SCALES[w]
####            if current == 0: current = 1
####            current *= scale
####            if scale >= 1000:
####                total += current; current = 0
####            valid = True
####        elif w == "and":
####            continue
####        else:
####            return None
####    return (total + current) if valid else None
####
####def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
####    i = 0; n = len(words); nums: List[int] = []
####    while i < n:
####        parsed = None; parsed_len = 0
####        for window in range(max_window, 0, -1):
####            if i + window > n: continue
####            phrase = " ".join(words[i:i+window])
####            val = words_to_number(phrase)
####            if val is not None:
####                parsed = val; parsed_len = window; break
####        if parsed is not None:
####            nums.append(parsed); i += parsed_len
####        else:
####            token = words[i]
####            if re.fullmatch(r"\d+", token):
####                nums.append(int(token)); i += 1
####            else:
####                i += 1
####    return nums
####
####### ---------- extractor that accepts dicts & stringified dicts ----------
####
####
####def safe_str(v) -> str:
####    if v is None:
####        return ""
####    return str(v)
####
####def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
####    if query is None:
####        return "", None, None, None, None
####
####    # Helper to parse numeric-or-None strings
####    def _to_float_or_none(v):
####        if v is None:
####            return None
####        if isinstance(v, (float, int)):
####            return float(v)
####        s = str(v).strip()
####        if s.lower() == "none" or s == "":
####            return None
####        try:
####            return float(s)
####        except Exception:
####            return None
####
####    if isinstance(query, dict):
####        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
####        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
####        score_ = query.get("score")
####        gender_ = query.get("gender")
####        gender_conf_ = query.get("gender_conf")
####        if isinstance(speaker_, str):
####            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
####            if s.lower().startswith("none "): s = s[5:].strip()
####            speaker_ = None if s.lower() == "none" else s
####        try: score_f = float(score_) if score_ is not None else None
####        except: score_f = None
####        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
####        except: gconf_f = None
####        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
####
####    if isinstance(query, str):
####        original = query
####        s = query.strip()
####
####        # --- try base64 decode if it looks like base64 (unchanged) ---
####        try:
####            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
####                try:
####                    decoded = base64.b64decode(s).decode('utf-8')
####                    if decoded:
####                        s = decoded.strip()
####                except Exception:
####                    pass
####        except Exception:
####            pass
####
####        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
####        try:
####            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
####            if not dt_match:
####                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
####            if not dt_match:
####                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
####            if dt_match:
####                s = s[dt_match.end():].lstrip()
####        except Exception:
####            pass
####
####        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
####        meta_idx = None
####        # more robust detection of where metadata starts: look for first occurrence of score key followed by : or =
####        m_meta = re.search(r"(?:(?:'score'|\"score\"|score)\s*[:=])", s, flags=re.I)
####        if m_meta:
####            meta_idx = m_meta.start()
####
####        meta_part = ""
####        body = s
####        if meta_idx is not None:
####            body = s[:meta_idx].rstrip(" :")
####            meta_part = s[meta_idx:].lstrip(" :")
####
####        # If meta_part present parse score/gender/gender_conf and final speaker token
####        score_val = None
####        gender_val = None
####        gender_conf_val = None
####        speaker_val = None
####
####        if meta_part:
####            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
####                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
####                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
####            if m_score:
####                score_val = _to_float_or_none(m_score.group("v"))
####            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
####                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
####                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
####            if m_gender:
####                gv = m_gender.group("v").strip()
####                gender_val = None if gv.lower() == "none" else safe_str(gv)
####            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
####                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
####                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
####            if m_gconf:
####                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
####
####            # remove known metadata tokens so the leftover text (like a speaker) can be found
####            meta_clean = meta_part
####            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
####            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
####
####            # split remaining text on colons/newlines and take the last non-metadata token as speaker
####            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
####            if leftovers:
####                for token in reversed(leftovers):
####                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
####                        speaker_val = token
####                        break
####
####        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
####        if score_val is None:
####            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
####                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
####            if m_score2:
####                score_val = _to_float_or_none(m_score2.group("v"))
####                body = body[:m_score2.start()].rstrip(" :")
####
####        if gender_val is None:
####            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
####                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
####            if m_gender2:
####                gv = m_gender2.group("v").strip()
####                gender_val = None if gv.lower() == "none" else safe_str(gv)
####                body = body[:m_gender2.start()].rstrip(" :")
####
####        if gender_conf_val is None:
####            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
####                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
####            if m_gconf2:
####                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
####                body = body[:m_gconf2.start()].rstrip(" :")
####
####        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
####        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
####        if looks_like_dict:
####            try:
####                parsed = ast.literal_eval(body)
####                if isinstance(parsed, dict):
####                    return extract_text_from_query(parsed)
####            except Exception:
####                try:
####                    parsed = json.loads(body)
####                    if isinstance(parsed, dict):
####                        return extract_text_from_query(parsed)
####                except Exception:
####                    pass
####
####        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
####        text_val = safe_str(m_text.group("t")) if m_text else body
####
####        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
####        if m_speaker:
####            speaker_val = safe_str(m_speaker.group("s"))
####
####        # post-process speaker found earlier (trim device suffixes and "none")
####        if isinstance(speaker_val, str):
####            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
####            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
####            if speaker_val.lower() == "none": speaker_val = None
####
####        return safe_str(text_val), (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
####
####    # final fallback
####    return safe_str(query), None, None, None, None
####
####
####
######def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
######    if query is None:
######        return "", None, None, None, None
######
######    # Helper to parse numeric-or-None strings
######    def _to_float_or_none(v):
######        if v is None:
######            return None
######        if isinstance(v, (float, int)):
######            return float(v)
######        s = str(v).strip()
######        if s.lower() == "none" or s == "":
######            return None
######        try:
######            return float(s)
######        except Exception:
######            return None
######
######    if isinstance(query, dict):
######        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
######        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
######        score_ = query.get("score")
######        gender_ = query.get("gender")
######        gender_conf_ = query.get("gender_conf")
######        if isinstance(speaker_, str):
######            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
######            if s.lower().startswith("none "): s = s[5:].strip()
######            speaker_ = None if s.lower() == "none" else s
######        try: score_f = float(score_) if score_ is not None else None
######        except: score_f = None
######        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
######        except: gconf_f = None
######        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
######
######    if isinstance(query, str):
######        original = query
######        s = query.strip()
######
######        # --- try base64 decode if it looks like base64 (unchanged) ---
######        try:
######            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
######                try:
######                    decoded = base64.b64decode(s).decode('utf-8')
######                    if decoded:
######                        s = decoded.strip()
######                except Exception:
######                    pass
######        except Exception:
######            pass
######
######        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
######        try:
######            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
######            if not dt_match:
######                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
######            if not dt_match:
######                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
######            if dt_match:
######                s = s[dt_match.end():].lstrip()
######        except Exception:
######            pass
######
######        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
######        meta_idx = None
######        for key in ("'score'", '"score"', "score"):
######            m = re.search(r'\s*:\s*' + re.escape(key), s)
######            if m:
######                meta_idx = m.start()
######                break
######        if meta_idx is None:
######            for key in ("'score'", '"score"', "score"):
######                m = re.search(re.escape(key) + r'\s*[:=]', s)
######                if m:
######                    meta_idx = m.start()
######                    break
######
######        meta_part = ""
######        body = s
######        if meta_idx is not None:
######            body = s[:meta_idx].rstrip(" :")
######            meta_part = s[meta_idx:].lstrip(" :")
######
######        # If meta_part present parse score/gender/gender_conf and final speaker token
######        score_val = None
######        gender_val = None
######        gender_conf_val = None
######        speaker_val = None
######
######        if meta_part:
######            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
######                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
######                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
######            if m_score:
######                score_val = _to_float_or_none(m_score.group("v"))
######            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
######                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
######                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
######            if m_gender:
######                gv = m_gender.group("v").strip()
######                gender_val = None if gv.lower() == "none" else safe_str(gv)
######            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
######                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
######                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
######            if m_gconf:
######                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
######
######            meta_clean = meta_part
######            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
######            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
######            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
######            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
######            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
######            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
######
######            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
######            if leftovers:
######                for token in reversed(leftovers):
######                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
######                        speaker_val = token
######                        break
######
######        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
######        if score_val is None:
######            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
######                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
######            if m_score2:
######                score_val = _to_float_or_none(m_score2.group("v"))
######                body = body[:m_score2.start()].rstrip(" :")
######
######        if gender_val is None:
######            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
######                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
######            if m_gender2:
######                gv = m_gender2.group("v").strip()
######                gender_val = None if gv.lower() == "none" else safe_str(gv)
######                body = body[:m_gender2.start()].rstrip(" :")
######
######        if gender_conf_val is None:
######            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
######                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
######            if m_gconf2:
######                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
######                body = body[:m_gconf2.start()].rstrip(" :")
######
######        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
######        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
######        if looks_like_dict:
######            try:
######                parsed = ast.literal_eval(body)
######                if isinstance(parsed, dict):
######                    return extract_text_from_query(parsed)
######            except Exception:
######                try:
######                    parsed = json.loads(body)
######                    if isinstance(parsed, dict):
######                        return extract_text_from_query(parsed)
######                except Exception:
######                    pass
######
######        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
######        text_val = safe_str(m_text.group("t")) if m_text else body
######
######        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
######        if m_speaker:
######            speaker_val = safe_str(m_speaker.group("s"))
######
######        # post-process speaker found earlier (trim device suffixes and "none")
######        if isinstance(speaker_val, str):
######            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
######            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
######            if speaker_val.lower() == "none": speaker_val = None
######
######        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
######
######    # final fallback
######    return safe_str(query), None, None, None, None
####
##### ---------- date/time parsing helpers ----------
####_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
####_WEEKDAYS = _WEEKDAY_MAP.copy()
####
####_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
####_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
####
####def _token_to_number(token: str) -> Optional[int]:
####    token = safe_str(token).lower()
####    if not token: return None
####    if re.fullmatch(r"\d+", token):
####        try: return int(token)
####        except: return None
####    if token in _UNITS: return _UNITS[token]
####    if token in _TENS: return _TENS[token]
####    if "-" in token:
####        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
####        if all(v is not None for v in vals): return sum(vals)
####    return words_to_number(token)
####
####def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
####    s0 = safe_str(s).lower()
####    ampm = None
####    for w in _AM_WORDS:
####        if re.search(r"\b" + re.escape(w) + r"\b", s0):
####            ampm = "am"
####            break
####    if ampm is None:
####        for w in _PM_WORDS:
####            if re.search(r"\b" + re.escape(w) + r"\b", s0):
####                ampm = "pm"
####                break
####    if re.search(r"\bnoon\b", s0): ampm = "pm"
####    if re.search(r"\bmidnight\b", s0): ampm = "am"
####    if ampm:
####        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
####        s0 = re.sub(pattern, " ", s0)
####        s0 = re.sub(r"\s+", " ", s0).strip()
####    return s0, ampm
####
####def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
####    """
####    Robust spoken time -> (hour, minute) parser.
####    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
####    """
####    if spoken is None: return None
####    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
####    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
####
####    s_orig = safe_str(spoken)
####    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
####    # quick special words
####    if re.search(r"\bnoon\b", s): return (12, 0)
####    if re.search(r"\bmidnight\b", s): return (0, 0)
####
####    # detect am/pm using the whole phrase and remove those tokens
####    s_no_ampm, ampm = _detect_ampm_and_remove(s)
####
####    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
####    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
####    if m_colon:
####        try:
####            hh = int(m_colon.group(1)) % 24
####            mm = int(m_colon.group(2)) % 60
####            hour = hh
####            minute = mm
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####        except Exception:
####            pass
####
####    # 2) 'half past X'
####    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
####    if m_half:
####        token = m_half.group(1).strip()
####        h = _token_to_number(token)
####        if h is not None:
####            hour = int(h) % 24
####            minute = 30
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####
####    # 3) 'quarter past/to X'
####    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
####    if m_quarter:
####        typ = m_quarter.group(1)
####        hour_token = m_quarter.group(2).strip()
####        h = _token_to_number(hour_token)
####        if h is not None:
####            hour = int(h) % 24
####            if typ == "past":
####                minute = 15
####            else:
####                minute = 45
####                hour = (hour - 1) % 24
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####
####    # 4) 'X minutes past Y'
####    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
####    if m_past:
####        try:
####            mins = int(m_past.group(1))
####            htoken = m_past.group(2)
####            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
####            if h is not None:
####                hour = int(h) % 24
####                minute = mins % 60
####                if ampm == "pm" and hour < 12: hour += 12
####                if ampm == "am" and hour == 12: hour = 0
####                return (hour, minute)
####        except Exception:
####            pass
####
####    # 5) 'X minutes to Y' -> compute
####    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
####    if m_to:
####        try:
####            mins = int(m_to.group(1))
####            htoken = m_to.group(2)
####            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
####            if h is not None:
####                hour = (int(h) - 1) % 24
####                minute = (60 - (mins % 60)) % 60
####                if ampm == "pm" and hour < 12: hour += 12
####                if ampm == "am" and hour == 12: hour = 0
####                return (hour, minute)
####        except Exception:
####            pass
####
####    # 6) 'X o'clock'
####    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
####    if m_oclock:
####        try:
####            hour = int(m_oclock.group(1)) % 24
####            minute = 0
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####        except Exception:
####            pass
####
####    # 7) two-number tokens e.g., 'ten thirty'
####    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
####    if len(tokens) >= 2:
####        h_candidate = _token_to_number(tokens[0])
####        m_candidate = _token_to_number(tokens[1])
####        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
####            hour = int(h_candidate) % 24
####            minute = int(m_candidate) % 60
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####
####    # 8) single number token -> hour
####    if len(tokens) == 1:
####        h = _token_to_number(tokens[0])
####        if h is not None:
####            hour = int(h) % 24
####            minute = 0
####            if ampm == "pm" and hour < 12: hour += 12
####            if ampm == "am" and hour == 12: hour = 0
####            return (hour, minute)
####
####    # 9) digits cluster like 930
####    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
####    if digits_cluster:
####        cluster = digits_cluster.group(1)
####        try:
####            if len(cluster) == 3:
####                h = int(cluster[0]); m = int(cluster[1:])
####            else:
####                h = int(cluster[:2]); m = int(cluster[2:])
####            if 0 <= h < 24 and 0 <= m < 60:
####                hour = h; minute = m
####                if ampm == "pm" and hour < 12: hour += 12
####                if ampm == "am" and hour == 12: hour = 0
####                return (hour, minute)
####        except Exception:
####            pass
####
####    return None
####
####def spoken_time_to_str(spoken) -> Optional[str]:
####    hm = spoken_time_to_hm(spoken)
####    if not hm: return None
####    return f"{hm[0]:02d}:{hm[1]:02d}"
####
##### -------------------------
##### NEW HELPER: extract small time fragment from full utterance
##### -------------------------
##### Reason: passing the entire utterance (which may include "for the next two weeks")
##### into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
##### This helper finds a concise time-like substring and returns it.
####def _extract_time_fragment(text: str) -> str:
####    if not text:
####        return ""
####    t = safe_str(text).lower()
####    patterns = [
####        r"\bhalf past [a-z0-9 ]{1,20}\b",
####        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
####        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
####        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
####        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
####        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
####        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
####        r"\b(?:noon|midnight)\b",
####        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
####    ]
####    for pat in patterns:
####        m = re.search(pat, t, flags=re.I)
####        if m:
####            return m.group(0)
####    # fallback: try to find a short "X Y" token near "at" or near start
####    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
####    if m_at:
####        frag = m_at.group(1).strip()
####        # keep only first few words
####        frag = " ".join(frag.split()[:4])
####        return frag
####    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
####    return t
####
##### ---------- simple persistence/organizer ----------
####ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
####os.makedirs(ORGANIZER_DIR, exist_ok=True)
####ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
####organizer_events: List[dict] = []
####
##### Lock to protect organizer_events during prune/save/load
####_ORGANIZER_LOCK = threading.Lock()
####
####def _load_organizer_events():
####    global organizer_events
####    try:
####        with _ORGANIZER_LOCK:
####            if os.path.exists(ORGANIZER_DB):
####                with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
####                    organizer_events = json.load(f)
####            else:
####                organizer_events = []
####    except Exception as e:
####        print("Organizer load failed:", e); organizer_events = []
####
####def _prune_completed_events(now: Optional[dt.datetime] = None):
####    """
####    Remove events that have already been fully fired (all notify_times fired)
####    or events whose dtstart is in the past and have no notify_times.
####    Also remove any associated ICS files for removed events.
####    This function mutates `organizer_events` in place (under lock).
####    """
####    global organizer_events
####    now = now or dt.datetime.now()
####    removed_any = False
####    new_list: List[dict] = []
####    for ev in organizer_events:
####        try:
####            dtstart_str = ev.get("dtstart")
####            dtstart = None
####            if dtstart_str:
####                try:
####                    dtstart = dt.datetime.fromisoformat(dtstart_str)
####                except Exception:
####                    dtstart = None
####
####            nts = ev.get("notify_times", [])
####            if isinstance(nts, list) and nts:
####                all_fired = all(bool(item.get("fired", False)) for item in nts)
####            else:
####                # no notify times -> treat as fired if dtstart in past
####                all_fired = False
####                if dtstart is not None and dtstart < now:
####                    all_fired = True
####
####            if all_fired:
####                # delete ICS if exists
####                ics_path = ev.get("ics_path")
####                if ics_path:
####                    try:
####                        if os.path.exists(ics_path):
####                            os.remove(ics_path)
####                    except Exception:
####                        pass
####                removed_any = True
####                # skip adding to new_list -> effectively removed
####            else:
####                new_list.append(ev)
####        except Exception:
####            # if anything goes wrong, keep the event to avoid data loss
####            new_list.append(ev)
####    if removed_any:
####        organizer_events = new_list
####
####def _save_organizer_events():
####    try:
####        with _ORGANIZER_LOCK:
####            # prune completed events before saving
####            try:
####                _prune_completed_events()
####            except Exception:
####                pass
####            with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
####                json.dump(organizer_events, f, indent=2, default=str)
####    except Exception as e:
####        print("Organizer save failed:", e)
####
####def _write_ics_file(ev: dict) -> Optional[str]:
####    try:
####        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
####        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
####        uid = ev['id']
####        ics_text = "\r\n".join([
####            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
####            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
####            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
####            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
####            "END:VEVENT","END:VCALENDAR",""
####        ])
####        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
####        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
####            f.write(ics_text)
####        return ics_path
####    except Exception as e:
####        print("Error writing ics:", e); return None
####
##### ---------- compute notify times ----------
####def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
####    uniq = {}
####    for t in times:
####        try:
####            iso = t.replace(second=0, microsecond=0).isoformat()
####            uniq[iso] = t
####        except Exception:
####            pass
####    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
####    return out
####
####def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
####    now = now or dt.datetime.now()
####    event_date = dtstart.date()
####    candidates: List[dt.datetime] = []
####    for hh in (7, 10, 12):
####        try:
####            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
####            if cand < dtstart and cand > now:
####                candidates.append(cand)
####        except Exception:
####            continue
####    for minutes_before in (60, 30, 15, 0):
####        try:
####            cand = dtstart - dt.timedelta(minutes=minutes_before)
####            if cand > now and cand <= dtstart:
####                candidates.append(cand)
####        except Exception:
####            continue
####    return _unique_sorted_times(candidates)
####
##### ---------- add event ----------
####def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
####                        duration_minutes: int = 60, reminder_minutes: int = 15,
####                        description: str = "", event_type: str = "reminder",
####                        metadata: Optional[Dict[str, Any]] = None) -> dict:
####    """
####    metadata: optional dict saved under 'orig_query' in the event, expected keys:
####      'text', 'speaker', 'score', 'gender', 'gender_conf' (but any keys are allowed)
####    """
####    try:
####        if isinstance(date_text, str):
####            ymd = dt.date.fromisoformat(date_text)
####        elif isinstance(date_text, dt.date):
####            ymd = date_text
####        else:
####            raise ValueError("Invalid date_text")
####        hh, mm = 9, 0
####        try:
####            if isinstance(time_text, str) and ":" in time_text:
####                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
####            elif isinstance(time_text, dt.time):
####                hh = time_text.hour; mm = time_text.minute
####        except Exception:
####            pass
####        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
####        ev_id = uuid.uuid4().hex
####        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
####              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
####              "description": description, "ics_path": None, "notified": False}
####        # store original metadata (for later use when the reminder fires)
####        ev["orig_query"] = metadata if metadata is not None else {}
####        notify_list = _compute_notify_times_for_event(dtstart)
####        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
####        ics = _write_ics_file(ev)
####        if ics: ev['ics_path'] = ics
####        with _ORGANIZER_LOCK:
####            organizer_events.append(ev)
####            _save_organizer_events()
####        return ev
####    except Exception as e:
####        print("add_organizer_event failed:", e)
####        raise
####
####def _migrate_loaded_events():
####    changed = False
####    now = dt.datetime.now()
####    for ev in organizer_events:
####        try:
####            ds = ev.get("dtstart")
####            if not ds:
####                continue
####            dtstart = dt.datetime.fromisoformat(ds)
####            if not ev.get("notify_times"):
####                nts = _compute_notify_times_for_event(dtstart, now=now)
####                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
####                changed = True
####            else:
####                new_nts = []
####                for item in ev.get("notify_times", []):
####                    if isinstance(item, dict) and item.get("t"):
####                        try:
####                            dt.datetime.fromisoformat(item["t"])
####                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
####                        except Exception:
####                            continue
####                if not new_nts:
####                    nts = _compute_notify_times_for_event(dtstart, now=now)
####                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
####                    changed = True
####                else:
####                    ev["notify_times"] = new_nts
####        except Exception:
####            continue
####    # prune completed events after migration
####    try:
####        _prune_completed_events()
####    except Exception:
####        pass
####    if changed:
####        _save_organizer_events()
####
##### ---------- quick reminders ----------
####_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
####def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
####    if not lines: return
####    try:
####        with open(path, "a", encoding="utf-8") as f:
####            for ln in lines:
####                f.write(safe_str(ln).rstrip() + "\n")
####    except Exception as e:
####        print("Failed to save quick reminders:", e)
####
####def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
####    try:
####        if not os.path.exists(path): return []
####        with open(path, "r", encoding="utf-8") as f:
####            return [ln.strip() for ln in f.readlines() if ln.strip()]
####    except Exception as e:
####        print("Failed to read reminders:", e); return []
####
##### ---------- title extraction ----------
####def extract_title_from_text(text: str) -> str:
####    s = safe_str(text)
####    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
####    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
####    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
####    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
####    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
####    s = s.strip(" ,.")
####    return s or "Reminder"
####
##### ---------- NEW: clean subject helper ----------
####_TRIGGER_LEADING_RE = re.compile(
####    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
####)
####
####_DATE_TIME_CUES = [
####    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
####    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
####    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
####    r'\bday after tomorrow\b',
####    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
####    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
####    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
####    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
####    r'\b\d{1,2}\s?(?:am|pm)\b'
####]
####_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
####
####def clean_reminder_subject(text: str) -> str:
####    """
####    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
####    and trim away trailing date/time phrases so the returned text is just the reminder subject.
####    """
####    if not text:
####        return ""
####    t = safe_str(text)
####    # remove leading trigger
####    t = _TRIGGER_LEADING_RE.sub("", t).strip()
####    if not t:
####        return ""
####    # find earliest date/time cue and cut there
####    earliest = None
####    for cre in _DATE_TIME_CUES_COMPILED:
####        m = cre.search(t)
####        if m:
####            idx = m.start()
####            if earliest is None or idx < earliest:
####                earliest = idx
####    if earliest is not None and earliest > 0:
####        t = t[:earliest].strip(" ,:-")
####    # final cleanup
####    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
####    return t
####
##### ---------- recurrence parsing & expansion helpers ----------
####def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
####    """Add months safely to a datetime (preserves day where possible)."""
####    year = date_obj.year + (date_obj.month - 1 + months) // 12
####    month = (date_obj.month - 1 + months) % 12 + 1
####    # find last day of target month
####    last_day = calendar.monthrange(year, month)[1]
####    day = min(date_obj.day, last_day)
####    try:
####        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
####    except Exception:
####        # fallback simple approximation
####        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
####
####def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
####    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
####    s = safe_str(text).lower()
####    # explicit tomorrow
####    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
####        out["explicit_tomorrow"] = True
####    # everyday / daily
####    if re.search(r'\bevery (day|everyday)\b', s):
####        out["type"] = "daily"
####        out["interval"] = 1
####    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
####        out["type"] = "every_n_days"; out["interval"] = 2
####    # every N days like 'every 3 days'
####    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
####    if m3:
####        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
####        except: pass
####    # weekly / every X weeks
####    if re.search(r'\bevery (week|weekly)\b', s):
####        out["type"] = "weekly"; out["interval"] = 1
####    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
####    if m4:
####        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
####        except: pass
####    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
####        out["type"] = "every_n_weeks"; out["interval"]=2
####    # weekday like "every Monday"
####    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
####    if mwd:
####        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
####        out["interval"] = 1
####    # "for the month" or span days hints
####    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
####        out["span_days"] = 30
####    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
####    if m_next:
####        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
####        if n:
####            out["span_days"] = int(n)*7
####    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
####    if m_nextd:
####        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
####        if n:
####            out["span_days"] = int(n)
####    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
####        out["type"] = "monthly"
####        out["months"] = 12 if 'of the year' in s else 1
####    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
####        today = dt.date.today()
####        days_left = 7 - today.weekday()
####        out["span_days"] = days_left
####        out["type"] = "daily"
####    return out
####
####def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
####    out: List[dt.datetime] = []
####    if base_dt is None:
####        return out
####    span_days = rec_spec.get("span_days", 30)
####    end_date = base_dt + dt.timedelta(days=span_days)
####    typ = rec_spec.get("type", "none")
####    interval = int(rec_spec.get("interval", 1) or 1)
####
####    # always include base_dt as first occurrence
####    out.append(base_dt)
####
####    if rec_spec.get("explicit_tomorrow"):
####        tomorrow_dt = base_dt + dt.timedelta(days=1)
####        out.append(tomorrow_dt)
####
####    if typ in ("daily",) and typ != "none":
####        day = base_dt
####        while True:
####            day = day + dt.timedelta(days=interval)
####            if day <= end_date:
####                out.append(day)
####            else:
####                break
####    elif typ == "every_n_days":
####        day = base_dt
####        while True:
####            day = day + dt.timedelta(days=interval)
####            if day <= end_date:
####                out.append(day)
####            else:
####                break
####    elif typ in ("weekly","every_n_weeks"):
####        day = base_dt
####        while True:
####            day = day + dt.timedelta(weeks=interval)
####            if day <= end_date:
####                out.append(day)
####            else:
####                break
####    elif typ == "weekday" and rec_spec.get("weekday") is not None:
####        wd = int(rec_spec.get("weekday"))
####        candidate = base_dt
####        if candidate.weekday() != wd:
####            days_ahead = (wd - candidate.weekday()) % 7
####            candidate = candidate + dt.timedelta(days=days_ahead)
####        while candidate <= end_date:
####            if candidate >= base_dt:
####                out.append(candidate)
####            candidate = candidate + dt.timedelta(weeks=1)
####    elif typ == "monthly":
####        months_to_create = int(rec_spec.get("months", 1) or 1)
####        current = base_dt
####        for i in range(1, months_to_create):
####            current = add_months(current, 1)
####            if current <= end_date + dt.timedelta(days=1):
####                out.append(current)
####
####    # dedupe & sort
####    uniq = {}
####    for d in out:
####        try:
####            iso = d.replace(second=0, microsecond=0).isoformat()
####            uniq[iso] = d
####        except Exception:
####            continue
####    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
####    return final
####
##### ---------- notification/snooze handling ----------
####def _parse_snooze_minutes(resp: str) -> Optional[int]:
####    if not resp: return None
####    resp = resp.lower()
####    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
####    if m:
####        n = int(m.group(1))
####        unit = m.group(2)
####        if "hour" in unit or unit == "h":
####            return n * 60
####        return n
####    n = words_to_number(resp)
####    if isinstance(n, int):
####        if "hour" in resp:
####            return n * 60
####        return n
####    if "five" in resp or "5" in resp: return 5
####    if "ten" in resp or "10" in resp: return 10
####    if "fifteen" in resp or "15" in resp: return 15
####    if "thirty" in resp or "30" in resp: return 30
####    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
####    return None
####
####def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
####    try:
####        _set_reminder_speaking(True)
####        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
####        title = ev.get('title', '(no title)')
####        notify_time = dt.datetime.fromisoformat(notify_iso)
####        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
####        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
####        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
####        if not resp:
####            return False
####        low = _resp_to_text(resp).lower()
####        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
####            return False
####        minutes = _parse_snooze_minutes(low)
####        if minutes is None:
####            if "snooze" in low:
####                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
####                if follow:
####                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
####        if minutes is None:
####            _speak("Okay, not snoozing.")
####            return False
####        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
####        with _ORGANIZER_LOCK:
####            ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
####            _save_organizer_events()
####        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
####        return True
####    except Exception as e:
####        print("_announce_and_handle_snooze error:", e)
####        return False
####    finally:
####        _set_reminder_speaking(False)
####
##### ---------- main notifier loop ----------
####_NOTIFIER_THREAD = None
####_NOTIFIER_THREAD_LOCK = threading.Lock()
####
####def _notifier_loop(poll_seconds: int = 20):
####    while True:
####        try:
####            now = dt.datetime.now()
####            changed = False
####            with _ORGANIZER_LOCK:
####                for ev in list(organizer_events):
####                    try:
####                        nts = ev.get("notify_times", [])
####                        for nt in nts:
####                            try:
####                                if nt.get("fired", False):
####                                    continue
####                                notify_dt = dt.datetime.fromisoformat(nt['t'])
####                                if now >= notify_dt:
####                                    nt['fired'] = True
####                                    changed = True
####                                    # announce outside lock to prevent blocking saves/other ops
####                                    # collect call to _announce_and_handle_snooze after releasing lock
####                            except Exception:
####                                continue
####                    except Exception(e):
####                        print(f"Error get notify_times : {e}")
####                        continue
####                            
####            if changed:
####                # save (which prunes) and then call announcer(s) for fired ones
####                _save_organizer_events()
####                # Now perform the announces/snooze handling for events that were just fired
####                # We do this by scanning for notify_times that are fired and not yet processed by announce.
####                # To avoid re-announcing already announced items, we'll mark them by adding a small flag like `_announced_by_process`
####                with _ORGANIZER_LOCK:
####                    to_announce = []
####                    for ev in organizer_events:
####                        try:
####                            for nt in ev.get("notify_times", []):
####                                if nt.get("fired", False) and not nt.get("_announced", False):
####                                    to_announce.append((ev, nt))
####                        except Exception:
####                            continue
####                # announce outside lock
####                for ev, nt in to_announce:
####                    try:
####                        _announce_and_handle_snooze(ev, nt['t'])
####                        # mark announced so we don't announce again
####                        with _ORGANIZER_LOCK:
####                            nt["_announced"] = True
####                            _save_organizer_events()
####                    except Exception:
####                        continue
####        except Exception as e:
####            print("Notifier loop error:", e)
####        time.sleep(poll_seconds)
####
####def start_reminder_notifier_thread(poll_seconds: int = 20):
####    global _NOTIFIER_THREAD
####    with _NOTIFIER_THREAD_LOCK:
####        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
####            return
####        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
####        _NOTIFIER_THREAD.start()
####
##### ---------- load / migration on import ----------
####_load_organizer_events()
####_migrate_loaded_events()
####
##### ---------- public handler (entrypoint used by main.py) ----------
####def handle_voice_command(AlfredQueryOffline: str, gui=None):
####    text_in = safe_str(AlfredQueryOffline)
####    if not text_in:
####        return
####    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
####    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
####    # remove trailing speaker tokens like " : Name Home"
####    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
####    lower = text_clean.lower()
####    k = ""
####    # triggers for create/set reminders
####    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
####        _speak("Okay  I will create a reminder.")
####        try:
####            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
####        except Exception:
####            msg_text = text_clean
####            speaker = None; score = None; gender = None; gender_conf = None
####        msg_text = safe_str(msg_text)
####
####        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
####        print(f"[DEBUG REMINDER] speaker : {speaker}")
####        print(f"[DEBUG REMINDER] score : {score}")
####        print(f"[DEBUG REMINDER] gender : {gender}")
####        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
####
####        # metadata to store with the reminder so main.py can reuse it later
####        metadata = {
####            "text": msg_text,
####            "speaker": speaker,
####            "score": score,
####            "gender": gender,
####            "gender_conf": gender_conf
####        }
####
####        # Preserve original utterance for parsing, but derive a clean subject
####        original_for_parsing = msg_text
####        subject = clean_reminder_subject(original_for_parsing)
####
####        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
####        try:
####            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
####            for f in fillers:
####                subject = re.sub(f, "", subject, flags=re.I)
####            # remove extra whitespace & punctuation
####            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
####        except Exception as _e:
####            print("subject filler clean error:", _e)
####            subject = subject.strip()
####
####        subject = subject.replace("ing","")
####        
####        # If subject empty, ask first what the reminder should be about
####        if not subject:
####            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
####            if resp:
####                try:
####                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
####                except Exception:
####                    resp_text = resp
####                subject = safe_str(resp_text)
####
####        if not subject:
####            # cannot determine subject -> save quick reminder
####            _append_lines_to_file([original_for_parsing])
####            _speak("Saved quick reminder (no subject).")
####            return
####
####        # Now parse date/time from the original utterance (so time tokens are preserved)
####        msg_text_for_parsing = original_for_parsing
####
####        parsed_dt = None
####        try:
####            parsed_dt = None
####            # relative expressions first
####            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
####            if m_rel:
####                num_phrase = m_rel.group(2).strip()
####                unit = m_rel.group(3)
####                try:
####                    num = int(num_phrase)
####                except:
####                    num = words_to_number(num_phrase)
####                if num is not None:
####                    now = dt.datetime.now()
####                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
####                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
####                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
####                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
####            # if not relative, try explicit date/time
####            if parsed_dt is None:
####                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
####                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
####                    time_frag = _extract_time_fragment(msg_text_for_parsing)
####                    hm = spoken_time_to_hm(time_frag)
####                    if hm:
####                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
####                    else:
####                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
####                elif "today" in msg_text_for_parsing.lower():
####                    base = dt.date.today()
####                    time_frag = _extract_time_fragment(msg_text_for_parsing)
####                    hm = spoken_time_to_hm(time_frag)
####                    if hm:
####                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
####                    else:
####                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
####                else:
####                    # weekdays anywhere in phrase
####                    for wd, idx in _WEEKDAYS.items():
####                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
####                            days_ahead = (idx - dt.date.today().weekday()) % 7
####                            if days_ahead == 0:
####                                days_ahead = 7
####                            target = dt.date.today() + dt.timedelta(days=days_ahead)
####                            time_frag = _extract_time_fragment(msg_text_for_parsing)
####                            hm = spoken_time_to_hm(time_frag)
####                            if hm:
####                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
####                            else:
####                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
####                            break
####            # explicit date + time
####            if parsed_dt is None:
####                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
####                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
####                date_val = None
####                if m_date_iso:
####                    date_val = m_date_iso.group(1)
####                elif m_date_slash:
####                    try:
####                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
####                        date_val = d.isoformat()
####                    except:
####                        date_val = None
####                time_frag = _extract_time_fragment(msg_text_for_parsing)
####                hm = spoken_time_to_hm(time_frag)
####                if date_val and hm:
####                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
####                elif hm:
####                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
####                    if cand < dt.datetime.now():
####                        cand = cand + dt.timedelta(days=1)
####                    parsed_dt = cand
####            # fallback: try to extract time only and schedule next occurrence
####            if parsed_dt is None:
####                time_frag = _extract_time_fragment(msg_text_for_parsing)
####                hm = spoken_time_to_hm(time_frag)
####                if hm:
####                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
####                    if cand < dt.datetime.now():
####                        cand += dt.timedelta(days=1)
####                    parsed_dt = cand
####        except Exception:
####            parsed_dt = None
####
####        date_value = None; time_value = None
####        if parsed_dt:
####            date_value = parsed_dt.date().isoformat()
####            time_value = parsed_dt.time().strftime("%H:%M")
####        else:
####            # interactively ask if missing
####            title_candidate = subject or extract_title_from_text(subject)
####            if not date_value:
####                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
####                if resp:
####                    rtxt = _resp_to_text(resp).lower()
####                    if "tomorrow" in rtxt:
####                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
####                    elif "today" in rtxt:
####                        date_value = dt.date.today().isoformat()
####                    else:
####                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
####                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
####                        if m_iso:
####                            date_value = m_iso.group(1)
####                        elif m_slash:
####                            try:
####                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
####                                date_value = d.isoformat()
####                            except:
####                                date_value = None
####            if not time_value:
####                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
####                if resp:
####                    rv = None
####                    try:
####                        rtxt = _resp_to_text(resp)
####                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
####                        if m_rel:
####                            num_phrase = m_rel.group(2).strip()
####                            unit = m_rel.group(3)
####                            try: num = int(num_phrase)
####                            except: num = words_to_number(num_phrase)
####                            if num is not None:
####                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
####                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
####                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
####                        if rv:
####                            parsed_dt = rv
####                            date_value = parsed_dt.date().isoformat()
####                            time_value = parsed_dt.time().strftime("%H:%M")
####                        else:
####                            time_frag = _extract_time_fragment(rtxt)
####                            hm = spoken_time_to_hm(time_frag)
####                            if hm:
####                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
####                    except Exception:
####                        pass
####            if not parsed_dt:
####                if not date_value:
####                    date_value = dt.date.today().isoformat()
####                if not time_value:
####                    time_value = "09:00"
####            try:
####                parsed_date = dt.date.fromisoformat(date_value)
####            except Exception:
####                parsed_date = dt.date.today()
####            try:
####                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
####            except Exception:
####                hm = spoken_time_to_hm(time_value)
####                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
####            final_dt = dt.datetime.combine(parsed_date, parsed_time)
####            parsed_dt = final_dt
####
####        # prepare recurrence parsing
####        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
####        # build list of event datetimes from recurrence spec
####        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
####        if not occurrences:
####            occurrences = [parsed_dt] if parsed_dt else []
####
####        # confirm creation. If multiple events, summarise count.
####        if len(occurrences) == 1:
####            final_dt = occurrences[0]
####            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
####            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
####            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
####            if not confirmed:
####                _speak("Okay, I will not save that reminder.")
####                return
####            try:
####                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'),
####                                         duration_minutes=60, reminder_minutes=15,
####                                         description="Created by Alfred", event_type="reminder",
####                                         metadata=metadata)
####                try:
####                    _set_reminder_speaking(True)
####                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
####                finally:
####                    _set_reminder_speaking(False)
####                if gui is not None and hasattr(gui, "log_query"):
####                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
####            except Exception as e:
####                print("Error adding event:", e)
####                _speak("Failed to save reminder.")
####            return
####        else:
####            # multiple occurrences -> ask for confirmation with brief summary
####            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
####            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
####            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
####            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
####            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
####            if not confirmed:
####                _speak("Okay, I will not save those reminders.")
####                return
####            created = 0
####            for d in occurrences:
####                try:
####                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"),
####                                             duration_minutes=60, reminder_minutes=15,
####                                             description="Created by Alfred (recurrence)", event_type="reminder",
####                                             metadata=metadata)
####                    created += 1
####                except Exception as e:
####                    print("Error adding recurring event:", e)
####            try:
####                _set_reminder_speaking(True)
####                _speak(f"Created {created} reminders for '{title_candidate}'.")
####            finally:
####                _set_reminder_speaking(False)
####            if gui is not None and hasattr(gui, "log_query"):
####                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
####            return
####
####    # READ schedule
####    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
####        _speak("Checking your reminders and schedule.")
####        quick = _read_all_reminders()
####        dated = []
####        for ev in organizer_events:
####            try:
####                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
####                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
####            except Exception:
####                dated.append(ev.get('title','(no title)'))
####        out_parts = []
####        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
####        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
####        if out_parts:
####            out = " . ".join(out_parts)
####            try:
####                _set_reminder_speaking(True)
####                _speak(out); _send_bluetooth(out)
####            finally:
####                _set_reminder_speaking(False)
####        else:
####            _speak("You have no reminders or scheduled events I can see right now.")
####        return
####
##### start notifier when module imported
####start_reminder_notifier_thread()
####
##
##
##
##
##
##
##
##
##
##
##
##
##
##
##
##
##
##
##
###     LAST WORKING BEST DESCRIPTION Clear Triggered Reminders 2026_02_06__17H50
###
### reminders_module.py (fixed + pruning of completed events)
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##import calendar
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
##    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
##    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp).lower()
##        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
##            return True
##        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
##            return False
##        # fallback: first token
##        tokens = re.findall(r"[a-z]+", resp_text)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm using the whole phrase and remove those tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' -> compute
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock'
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens e.g., 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token -> hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) digits cluster like 930
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### -------------------------
### NEW HELPER: extract small time fragment from full utterance
### -------------------------
### Reason: passing the entire utterance (which may include "for the next two weeks")
### into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
### This helper finds a concise time-like substring and returns it.
##def _extract_time_fragment(text: str) -> str:
##    if not text:
##        return ""
##    t = safe_str(text).lower()
##    patterns = [
##        r"\bhalf past [a-z0-9 ]{1,20}\b",
##        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
##        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
##        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
##        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
##        r"\b(?:noon|midnight)\b",
##        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
##    ]
##    for pat in patterns:
##        m = re.search(pat, t, flags=re.I)
##        if m:
##            return m.group(0)
##    # fallback: try to find a short "X Y" token near "at" or near start
##    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
##    if m_at:
##        frag = m_at.group(1).strip()
##        # keep only first few words
##        frag = " ".join(frag.split()[:4])
##        return frag
##    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
##    return t
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
### Lock to protect organizer_events during prune/save/load
##_ORGANIZER_LOCK = threading.Lock()
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        with _ORGANIZER_LOCK:
##            if os.path.exists(ORGANIZER_DB):
##                with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                    organizer_events = json.load(f)
##            else:
##                organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _prune_completed_events(now: Optional[dt.datetime] = None):
##    """
##    Remove events that have already been fully fired (all notify_times fired)
##    or events whose dtstart is in the past and have no notify_times.
##    Also remove any associated ICS files for removed events.
##    This function mutates `organizer_events` in place (under lock).
##    """
##    global organizer_events
##    now = now or dt.datetime.now()
##    removed_any = False
##    new_list: List[dict] = []
##    for ev in organizer_events:
##        try:
##            dtstart_str = ev.get("dtstart")
##            dtstart = None
##            if dtstart_str:
##                try:
##                    dtstart = dt.datetime.fromisoformat(dtstart_str)
##                except Exception:
##                    dtstart = None
##
##            nts = ev.get("notify_times", [])
##            if isinstance(nts, list) and nts:
##                all_fired = all(bool(item.get("fired", False)) for item in nts)
##            else:
##                # no notify times -> treat as fired if dtstart in past
##                all_fired = False
##                if dtstart is not None and dtstart < now:
##                    all_fired = True
##
##            if all_fired:
##                # delete ICS if exists
##                ics_path = ev.get("ics_path")
##                if ics_path:
##                    try:
##                        if os.path.exists(ics_path):
##                            os.remove(ics_path)
##                    except Exception:
##                        pass
##                removed_any = True
##                # skip adding to new_list -> effectively removed
##            else:
##                new_list.append(ev)
##        except Exception:
##            # if anything goes wrong, keep the event to avoid data loss
##            new_list.append(ev)
##    if removed_any:
##        organizer_events = new_list
##
##def _save_organizer_events():
##    try:
##        with _ORGANIZER_LOCK:
##            # prune completed events before saving
##            try:
##                _prune_completed_events()
##            except Exception:
##                pass
##            with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##                json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##    return _unique_sorted_times(candidates)
##
### ---------- add event ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        with _ORGANIZER_LOCK:
##            organizer_events.append(ev)
##            _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    # prune completed events after migration
##    try:
##        _prune_completed_events()
##    except Exception:
##        pass
##    if changed:
##        _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- recurrence parsing & expansion helpers ----------
##def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
##    """Add months safely to a datetime (preserves day where possible)."""
##    year = date_obj.year + (date_obj.month - 1 + months) // 12
##    month = (date_obj.month - 1 + months) % 12 + 1
##    # find last day of target month
##    last_day = calendar.monthrange(year, month)[1]
##    day = min(date_obj.day, last_day)
##    try:
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##    except Exception:
##        # fallback simple approximation
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##
##def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
##    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
##    s = safe_str(text).lower()
##    # explicit tomorrow
##    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
##        out["explicit_tomorrow"] = True
##    # everyday / daily
##    if re.search(r'\bevery (day|everyday)\b', s):
##        out["type"] = "daily"
##        out["interval"] = 1
##    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
##        out["type"] = "every_n_days"; out["interval"] = 2
##    # every N days like 'every 3 days'
##    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
##    if m3:
##        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
##        except: pass
##    # weekly / every X weeks
##    if re.search(r'\bevery (week|weekly)\b', s):
##        out["type"] = "weekly"; out["interval"] = 1
##    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
##    if m4:
##        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
##        except: pass
##    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
##        out["type"] = "every_n_weeks"; out["interval"]=2
##    # weekday like "every Monday"
##    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
##    if mwd:
##        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
##        out["interval"] = 1
##    # "for the month" or span days hints
##    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
##        out["span_days"] = 30
##    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
##    if m_next:
##        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)*7
##    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
##    if m_nextd:
##        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)
##    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
##        out["type"] = "monthly"
##        out["months"] = 12 if 'of the year' in s else 1
##    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
##        today = dt.date.today()
##        days_left = 7 - today.weekday()
##        out["span_days"] = days_left
##        out["type"] = "daily"
##    return out
##
##def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
##    out: List[dt.datetime] = []
##    if base_dt is None:
##        return out
##    span_days = rec_spec.get("span_days", 30)
##    end_date = base_dt + dt.timedelta(days=span_days)
##    typ = rec_spec.get("type", "none")
##    interval = int(rec_spec.get("interval", 1) or 1)
##
##    # always include base_dt as first occurrence
##    out.append(base_dt)
##
##    if rec_spec.get("explicit_tomorrow"):
##        tomorrow_dt = base_dt + dt.timedelta(days=1)
##        out.append(tomorrow_dt)
##
##    if typ in ("daily",) and typ != "none":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_days":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ in ("weekly","every_n_weeks"):
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "weekday" and rec_spec.get("weekday") is not None:
##        wd = int(rec_spec.get("weekday"))
##        candidate = base_dt
##        if candidate.weekday() != wd:
##            days_ahead = (wd - candidate.weekday()) % 7
##            candidate = candidate + dt.timedelta(days=days_ahead)
##        while candidate <= end_date:
##            if candidate >= base_dt:
##                out.append(candidate)
##            candidate = candidate + dt.timedelta(weeks=1)
##    elif typ == "monthly":
##        months_to_create = int(rec_spec.get("months", 1) or 1)
##        current = base_dt
##        for i in range(1, months_to_create):
##            current = add_months(current, 1)
##            if current <= end_date + dt.timedelta(days=1):
##                out.append(current)
##
##    # dedupe & sort
##    uniq = {}
##    for d in out:
##        try:
##            iso = d.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = d
##        except Exception:
##            continue
##    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return final
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        with _ORGANIZER_LOCK:
##            ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##            _save_organizer_events()
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            with _ORGANIZER_LOCK:
##                for ev in list(organizer_events):
##                    try:
##                        nts = ev.get("notify_times", [])
##                        for nt in nts:
##                            try:
##                                if nt.get("fired", False):
##                                    continue
##                                notify_dt = dt.datetime.fromisoformat(nt['t'])
##                                if now >= notify_dt:
##                                    nt['fired'] = True
##                                    changed = True
##                                    # announce outside lock to prevent blocking saves/other ops
##                                    # collect call to _announce_and_handle_snooze after releasing lock
##                            except Exception:
##                                continue
##                    except Exception(e):
##                        print(f"Error get notify_times : {e}")
##                        continue
##                
##            if changed:
##                # save (which prunes) and then call announcer(s) for fired ones
##                _save_organizer_events()
##                # Now perform the announces/snooze handling for events that were just fired
##                # We do this by scanning for notify_times that are fired and not yet processed by announce.
##                # To avoid re-announcing already announced items, we'll mark them by adding a small flag like `_announced_by_process`
##                with _ORGANIZER_LOCK:
##                    to_announce = []
##                    for ev in organizer_events:
##                        try:
##                            for nt in ev.get("notify_times", []):
##                                if nt.get("fired", False) and not nt.get("_announced", False):
##                                    to_announce.append((ev, nt))
##                        except Exception:
##                            continue
##                # announce outside lock
##                for ev, nt in to_announce:
##                    try:
##                        _announce_and_handle_snooze(ev, nt['t'])
##                        # mark announced so we don't announce again
##                        with _ORGANIZER_LOCK:
##                            nt["_announced"] = True
##                            _save_organizer_events()
##                    except Exception:
##                        continue
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##    k = ""
##    # triggers for create/set reminders
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for parsing, but derive a clean subject
##        original_for_parsing = msg_text
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
##        try:
##            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
##            for f in fillers:
##                subject = re.sub(f, "", subject, flags=re.I)
##            # remove extra whitespace & punctuation
##            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
##        except Exception as _e:
##            print("subject filler clean error:", _e)
##            subject = subject.strip()
##
##        subject = subject.replace("ing","")
##        
##        # If subject empty, ask first what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        if not subject:
##            # cannot determine subject -> save quick reminder
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now parse date/time from the original utterance (so time tokens are preserved)
##        msg_text_for_parsing = original_for_parsing
##
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # relative expressions first
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            # if not relative, try explicit date/time
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays anywhere in phrase
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0:
##                                days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            time_frag = _extract_time_fragment(msg_text_for_parsing)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            # explicit date + time
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            # fallback: try to extract time only and schedule next occurrence
##            if parsed_dt is None:
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # interactively ask if missing
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            time_frag = _extract_time_fragment(rtxt)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare recurrence parsing
##        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
##        # build list of event datetimes from recurrence spec
##        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
##        if not occurrences:
##            occurrences = [parsed_dt] if parsed_dt else []
##
##        # confirm creation. If multiple events, summarise count.
##        if len(occurrences) == 1:
##            final_dt = occurrences[0]
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save that reminder.")
##                return
##            try:
##                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##                try:
##                    _set_reminder_speaking(True)
##                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##                finally:
##                    _set_reminder_speaking(False)
##                if gui is not None and hasattr(gui, "log_query"):
##                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##            except Exception as e:
##                print("Error adding event:", e)
##                _speak("Failed to save reminder.")
##            return
##        else:
##            # multiple occurrences -> ask for confirmation with brief summary
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
##            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
##            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save those reminders.")
##                return
##            created = 0
##            for d in occurrences:
##                try:
##                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)", event_type="reminder")
##                    created += 1
##                except Exception as e:
##                    print("Error adding recurring event:", e)
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Created {created} reminders for '{title_candidate}'.")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
##            return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##
##























###     LAST WORKING BEST BAD DESCRIPTION 2026_02_06__00h50
###
### reminders_module.py (fixed)
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##import calendar
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
##    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
##    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp).lower()
##        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
##            return True
##        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
##            return False
##        # fallback: first token
##        tokens = re.findall(r"[a-z]+", resp_text)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm using the whole phrase and remove those tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' -> compute
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock'
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens e.g., 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token -> hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) digits cluster like 930
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### -------------------------
### NEW HELPER: extract small time fragment from full utterance
### -------------------------
### Reason: passing the entire utterance (which may include "for the next two weeks")
### into spoken_time_to_hm caused it to pick up unrelated numeric tokens.
### This helper finds a concise time-like substring and returns it.
##def _extract_time_fragment(text: str) -> str:
##    if not text:
##        return ""
##    t = safe_str(text).lower()
##    patterns = [
##        r"\bhalf past [a-z0-9 ]{1,20}\b",
##        r"\bquarter (?:past|to) [a-z0-9 ]{1,20}\b",
##        r"\bat\s+\d{1,2}\s*[:h]\s*\d{1,2}\b",
##        r"\b\d{1,2}\s*[:h]\s*\d{2}\b",
##        r"\bat\s+\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s*(?:o'clock|o clock|oclock)\b",
##        r"\b\d{1,2}\s?(?:am|pm|a\.m\.|p\.m\.)\b",
##        r"\b(?:noon|midnight)\b",
##        r"\b\d{1,2}\s+minutes?\s+(?:past|to)\s+[a-z0-9 ]{1,10}\b"
##    ]
##    for pat in patterns:
##        m = re.search(pat, t, flags=re.I)
##        if m:
##            return m.group(0)
##    # fallback: try to find a short "X Y" token near "at" or near start
##    m_at = re.search(r"\bat\b\s*([a-z0-9 :h']{1,20})", t, flags=re.I)
##    if m_at:
##        frag = m_at.group(1).strip()
##        # keep only first few words
##        frag = " ".join(frag.split()[:4])
##        return frag
##    # last fallback: return the original text (spoken_time_to_hm will try best-effort)
##    return t
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##    return _unique_sorted_times(candidates)
##
### ---------- add event ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- recurrence parsing & expansion helpers ----------
##def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
##    """Add months safely to a datetime (preserves day where possible)."""
##    year = date_obj.year + (date_obj.month - 1 + months) // 12
##    month = (date_obj.month - 1 + months) % 12 + 1
##    # find last day of target month
##    last_day = calendar.monthrange(year, month)[1]
##    day = min(date_obj.day, last_day)
##    try:
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##    except Exception:
##        # fallback simple approximation
##        return dt.datetime(year, month, day, date_obj.hour, date_obj.minute, date_obj.second)
##
##def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
##    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
##    s = safe_str(text).lower()
##    # explicit tomorrow
##    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
##        out["explicit_tomorrow"] = True
##    # everyday / daily
##    if re.search(r'\bevery (day|everyday)\b', s):
##        out["type"] = "daily"
##        out["interval"] = 1
##    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
##        out["type"] = "every_n_days"; out["interval"] = 2
##    # every N days like 'every 3 days'
##    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
##    if m3:
##        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
##        except: pass
##    # weekly / every X weeks
##    if re.search(r'\bevery (week|weekly)\b', s):
##        out["type"] = "weekly"; out["interval"] = 1
##    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
##    if m4:
##        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
##        except: pass
##    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
##        out["type"] = "every_n_weeks"; out["interval"]=2
##    # weekday like "every Monday"
##    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
##    if mwd:
##        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
##        out["interval"] = 1
##    # "for the month" or span days hints
##    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
##        out["span_days"] = 30
##    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
##    if m_next:
##        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)*7
##    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
##    if m_nextd:
##        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)
##    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
##        out["type"] = "monthly"
##        out["months"] = 12 if 'of the year' in s else 1
##    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
##        today = dt.date.today()
##        days_left = 7 - today.weekday()
##        out["span_days"] = days_left
##        out["type"] = "daily"
##    return out
##
##def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
##    out: List[dt.datetime] = []
##    if base_dt is None:
##        return out
##    span_days = rec_spec.get("span_days", 30)
##    end_date = base_dt + dt.timedelta(days=span_days)
##    typ = rec_spec.get("type", "none")
##    interval = int(rec_spec.get("interval", 1) or 1)
##
##    # always include base_dt as first occurrence
##    out.append(base_dt)
##
##    if rec_spec.get("explicit_tomorrow"):
##        tomorrow_dt = base_dt + dt.timedelta(days=1)
##        out.append(tomorrow_dt)
##
##    if typ in ("daily",) and typ != "none":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_days":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ in ("weekly","every_n_weeks"):
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "weekday" and rec_spec.get("weekday") is not None:
##        wd = int(rec_spec.get("weekday"))
##        candidate = base_dt
##        if candidate.weekday() != wd:
##            days_ahead = (wd - candidate.weekday()) % 7
##            candidate = candidate + dt.timedelta(days=days_ahead)
##        while candidate <= end_date:
##            if candidate >= base_dt:
##                out.append(candidate)
##            candidate = candidate + dt.timedelta(weeks=1)
##    elif typ == "monthly":
##        months_to_create = int(rec_spec.get("months", 1) or 1)
##        current = base_dt
##        for i in range(1, months_to_create):
##            current = add_months(current, 1)
##            if current <= end_date + dt.timedelta(days=1):
##                out.append(current)
##
##    # dedupe & sort
##    uniq = {}
##    for d in out:
##        try:
##            iso = d.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = d
##        except Exception:
##            continue
##    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return final
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            if now >= notify_dt:
##                                nt['fired'] = True
##                                changed = True
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##    k = ""
##    # triggers for create/set reminders
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about", "schedule a meeting", "create a meeting")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for parsing, but derive a clean subject
##        original_for_parsing = msg_text
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # Remove only polite filler phrases (safe & conservative)  do not remove 'for'/'to' blindly
##        try:
##            fillers = [r'\bplease\b', r'\bcould you\b', r'\bwould you\b', r'\bcan you\b',  r'\bschedule a meeting\b',  r'\bcreate a meeting\b', r'\bset a reminder\b', r'\bcreate me a reminder\b', r'\bcreate a reminder\b', r'\bfor\b', r'\bto\b']
##            for f in fillers:
##                subject = re.sub(f, "", subject, flags=re.I)
##            # remove extra whitespace & punctuation
##            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.")
##        except Exception as _e:
##            print("subject filler clean error:", _e)
##            subject = subject.strip()
##
##        subject = subject.replace("ing","")
##        
##        # If subject empty, ask first what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        if not subject:
##            # cannot determine subject -> save quick reminder
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now parse date/time from the original utterance (so time tokens are preserved)
##        msg_text_for_parsing = original_for_parsing
##
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # relative expressions first
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            # if not relative, try explicit date/time
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    time_frag = _extract_time_fragment(msg_text_for_parsing)
##                    hm = spoken_time_to_hm(time_frag)
##                    if hm:
##                        parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else:
##                        parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays anywhere in phrase
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0:
##                                days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            time_frag = _extract_time_fragment(msg_text_for_parsing)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            # explicit date + time
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            # fallback: try to extract time only and schedule next occurrence
##            if parsed_dt is None:
##                time_frag = _extract_time_fragment(msg_text_for_parsing)
##                hm = spoken_time_to_hm(time_frag)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # interactively ask if missing
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            time_frag = _extract_time_fragment(rtxt)
##                            hm = spoken_time_to_hm(time_frag)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare recurrence parsing
##        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
##        # build list of event datetimes from recurrence spec
##        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
##        if not occurrences:
##            occurrences = [parsed_dt] if parsed_dt else []
##
##        # confirm creation. If multiple events, summarise count.
##        if len(occurrences) == 1:
##            final_dt = occurrences[0]
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save that reminder.")
##                return
##            try:
##                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##                try:
##                    _set_reminder_speaking(True)
##                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##                finally:
##                    _set_reminder_speaking(False)
##                if gui is not None and hasattr(gui, "log_query"):
##                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##            except Exception as e:
##                print("Error adding event:", e)
##                _speak("Failed to save reminder.")
##            return
##        else:
##            # multiple occurrences -> ask for confirmation with brief summary
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
##            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
##            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save those reminders.")
##                return
##            created = 0
##            for d in occurrences:
##                try:
##                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)", event_type="reminder")
##                    created += 1
##                except Exception as e:
##                    print("Error adding recurring event:", e)
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Created {created} reminders for '{title_candidate}'.")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
##            return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##
##























###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            # some logs are "2026-01-25 : 15:05:53 : " (date : time : ), that regex above expects an extra colon - adjust to cover common pattern:
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                # alternate form: maybe "YYYY-MM-DD : HH:MM:SS :"
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                # cut everything up to the end of the matched timestamp block
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            # don't fail on weird timestamps  continue with original s
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        # if we didn't find ': score' pattern, also try finding " 'score':" without preceding colon-space
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # try to find score
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            # gender
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            # gender_conf
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            # attempt to pull final remaining token as speaker (e.g., "... : ITF" or "... : John")
##            # remove parsed kv pairs from meta_part to look for leftover tokens
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            # leftover tokens separated by ':' or whitespace
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                # choose the last leftover that looks like a name/speaker (alphabetic or mixed) and not a known label
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                # strip it out of body
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
### This removes leading triggers from the front and strips trailing date/time tokens
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember)\b[\s,:-]*'
##)
##
### Patterns that typically mark the start of time/date information (we cut at earliest occurrence)
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    # We set the global flag while speaking so other parts of the app won't start listening.
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for time/date parsing, but clean subject for reminder text
##        original_for_parsing = msg_text  # keep full user phrase (may contain date/time tokens)
##
##        # remove leading triggers and trailing date/time from subject
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # ---- NEW: additional cleaning to ensure trigger words and filler words are not saved in subject ----
##        # If the original utterance contained any of the trigger phrases, remove those trigger words
##        # and common polite/filler words from the subject so the saved reminder is "raw".
##        try:
##            TRIGGERS_EXTRA = (
##                "remind me","create a reminder","create me a reminder","set a reminder","set reminder",
##                "i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about",
##                "remind me to","remind me about","please","could you","would you","can you","create me a reminder"
##            )
##            # if any trigger occurred in the original lowercased utterance, strip trigger tokens out
##            if any(t in lower for t in TRIGGERS_EXTRA):
##                for t in TRIGGERS_EXTRA:
##                    # remove whole phrase occurrences (case-insensitive)
##                    subject = re.sub(re.escape(t), "", subject, flags=re.I)
##
##            # remove common filler words as standalone words (case-insensitive)
##            FILLERS = ("please", "could you", "would you", "can you", "for", "to", "my")
##            for w in FILLERS:
##                subject = re.sub(r'\b' + re.escape(w) + r'\b', "", subject, flags=re.I)
##
##            # remove 'ing' suffixes at word boundaries (so "feeding" -> "feed")
##            subject = re.sub(r'(\w+)ing\b', r'\1', subject, flags=re.I)
##
##            # final whitespace/punctuation cleanup
##            subject = re.sub(r'\s{2,}', ' ', subject).strip(" ,:.-")
##        except Exception as _e:
##            print("Subject cleaning error:", _e)
##            subject = subject.strip()
##
##        # If subject now empty, ask what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                # normalize response
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        # If still empty after asking -> treat as quick reminder text unknown -> save quick reminder or abort
##        if not subject:
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now proceed to parse date/time from the original utterance (so we don't lose time info)
##        msg_text_for_parsing = original_for_parsing
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text_for_parsing)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = subject or extract_title_from_text(subject)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()



























###     LAST WORKING BEST BAD DESCRIPTION 2026_01_27__00h50
###
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
##    yes_words = {"yes", "yep", "yeah", "confirm", "do it", "sure", "please", "ok", "okay", "yes that is correct", "yes, that is correct"}
##    no_words = {"no", "nah", "nope", "do not", "dont", "cancel", "stop", "not", "no that is not correct"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes' or 'no'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp).lower()
##        if any(w in resp_text for w in yes_words) and not any(w in resp_text for w in no_words):
##            return True
##        if any(w in resp_text for w in no_words) and not any(w in resp_text for w in yes_words):
##            return False
##        # fallback: first token
##        tokens = re.findall(r"[a-z]+", resp_text)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles many natural variants and uses AM/PM cues anywhere in the phrase.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm using the whole phrase and remove those tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' -> compute
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock'
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens e.g., 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token -> hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) digits cluster like 930
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##    return _unique_sorted_times(candidates)
##
### ---------- add event ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember|please remind me to)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- recurrence parsing & expansion helpers ----------
##def add_months(date_obj: dt.datetime, months: int) -> dt.datetime:
##    """Add months safely to a datetime (preserves day where possible)."""
##    year = date_obj.year + (date_obj.month - 1 + months) // 12
##    month = (date_obj.month - 1 + months) % 12 + 1
##    day = min(date_obj.day, (dt.date(year, month, 1).replace(day=28) + dt.timedelta(days=4)).day)
##    try:
##        return dt.datetime(year, month, date_obj.day, date_obj.hour, date_obj.minute, date_obj.second)
##    except Exception:
##        # fallback adjust day downwards
##        last_day = (dt.date(year, month, 1).replace(day=28) + dt.timedelta(days=4)).day
##        d = min(date_obj.day, last_day)
##        return dt.datetime(year, month, d, date_obj.hour, date_obj.minute, date_obj.second)
##
##def parse_recurrence_from_text(text: str) -> Dict[str, Any]:
##    """
##    Very lightweight recurrence extraction. Returns a dict with:
##      - type: 'none'|'daily'|'every_n_days'|'weekly'|'every_n_weeks'|'monthly'|'monthly_each'|'weekday'
##      - interval: int (e.g., 2 for every 2 days/weeks)
##      - weekday: 0-6 when relevant
##      - span_days: int max span in days (default 30 if unspecified)
##      - explicit_tomorrow: bool (if 'also for tomorrow')
##      - explicit_dates: list of dt.date for explicit mentions (not implemented extensively)
##    """
##    out = {"type":"none","interval":1,"weekday":None,"span_days":30,"explicit_tomorrow":False,"months":1,"count":None}
##    s = safe_str(text).lower()
##    # explicit tomorrow
##    if re.search(r'\b(and )?also (for )?tomorrow\b', s) or re.search(r'\band also tomorrow\b', s):
##        out["explicit_tomorrow"] = True
##    # every X day(s)
##    m = re.search(r'\bevery(?:\s+(\w+))?\s+(second|2nd|2|third|3rd|3|first|1st|1)?\s*(day|days)\b', s)
##    if re.search(r'\bevery (day|everyday)\b', s):
##        out["type"] = "daily"
##        out["interval"] = 1
##    if re.search(r'\bevery (second|2nd|2) day\b', s) or re.search(r'\bevery 2 (days|day)\b', s) or re.search(r'\bevery second day\b', s):
##        out["type"] = "every_n_days"; out["interval"] = 2
##    # every N days like 'every 3 days'
##    m3 = re.search(r'\bevery\s+(\d+)\s+days?\b', s)
##    if m3:
##        try: out["type"]="every_n_days"; out["interval"]=int(m3.group(1))
##        except: pass
##    # weekly / every X weeks
##    if re.search(r'\bevery (week|weekly)\b', s):
##        out["type"] = "weekly"; out["interval"] = 1
##    m4 = re.search(r'\bevery\s+(\d+)\s+weeks?\b', s)
##    if m4:
##        try: out["type"]="every_n_weeks"; out["interval"]=int(m4.group(1))
##        except: pass
##    if re.search(r'\bevery second week\b', s) or re.search(r'\bevery 2 weeks\b', s):
##        out["type"] = "every_n_weeks"; out["interval"]=2
##    # weekday like "every Monday"
##    mwd = re.search(r'\bevery\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b', s)
##    if mwd:
##        out["type"] = "weekday"; out["weekday"] = _WEEKDAYS[mwd.group(1)]
##        out["interval"] = 1
##    # month spans
##    if re.search(r'\bfor the month\b', s) or re.search(r'\bfor this month\b', s):
##        out["span_days"] = 30
##    # "for the next N weeks"
##    m_next = re.search(r'for (?:the )?next\s+(\w+)\s+weeks?', s)
##    if m_next:
##        n = words_to_number(m_next.group(1)) or (int(m_next.group(1)) if m_next.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)*7
##    # "for the next N days"
##    m_nextd = re.search(r'for (?:the )?next\s+(\w+)\s+days?', s)
##    if m_nextd:
##        n = words_to_number(m_nextd.group(1)) or (int(m_nextd.group(1)) if m_nextd.group(1).isdigit() else None)
##        if n:
##            out["span_days"] = int(n)
##    # every month or "every month of the year"
##    if re.search(r'\bevery month of the year\b', s) or re.search(r'\bevery month\b', s):
##        out["type"] = "monthly"
##        out["months"] = 12 if 'of the year' in s else 1
##    # "for every day this week"
##    if re.search(r'\bthis week\b', s) and re.search(r'\bevery\b', s):
##        # span until end of week
##        today = dt.date.today()
##        days_left = 7 - today.weekday()
##        out["span_days"] = days_left
##        out["type"] = "daily"
##    return out
##
##def expand_recurrences(base_dt: dt.datetime, subject: str, rec_spec: Dict[str, Any]) -> List[dt.datetime]:
##    """
##    Given a base datetime and a recurrence spec (parse_recurrence_from_text output),
##    expand to a list of datetimes (including base_dt) within the span defined.
##    """
##    out: List[dt.datetime] = []
##    if base_dt is None:
##        return out
##    span_days = rec_spec.get("span_days", 30)
##    end_date = base_dt + dt.timedelta(days=span_days)
##    typ = rec_spec.get("type", "none")
##    interval = int(rec_spec.get("interval", 1) or 1)
##
##    # always include base_dt as first occurrence
##    out.append(base_dt)
##
##    if rec_spec.get("explicit_tomorrow"):
##        tomorrow_dt = base_dt + dt.timedelta(days=1)
##        out.append(tomorrow_dt)
##
##    if typ in ("none", "daily") and typ != "none":
##        # daily expansion
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_days":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(days=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ in ("weekly","every_n_weeks"):
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "every_n_weeks":
##        day = base_dt
##        while True:
##            day = day + dt.timedelta(weeks=interval)
##            if day <= end_date:
##                out.append(day)
##            else:
##                break
##    elif typ == "weekday" and rec_spec.get("weekday") is not None:
##        wd = int(rec_spec.get("weekday"))
##        # generate for each week until end_date
##        candidate = base_dt
##        # find next date with that weekday at same time (including today if matches)
##        if candidate.weekday() != wd:
##            days_ahead = (wd - candidate.weekday()) % 7
##            candidate = candidate + dt.timedelta(days=days_ahead)
##        while candidate <= end_date:
##            if candidate >= base_dt:
##                out.append(candidate)
##            candidate = candidate + dt.timedelta(weeks=1)
##    elif typ == "monthly":
##        months_to_create = int(rec_spec.get("months", 1) or 1)
##        current = base_dt
##        for i in range(1, months_to_create):
##            current = add_months(current, 1)
##            if current <= end_date + dt.timedelta(days=1):
##                out.append(current)
##
##    # dedupe & sort
##    uniq = {}
##    for d in out:
##        try:
##            iso = d.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = d
##        except Exception:
##            continue
##    final = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return final
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            if now >= notify_dt:
##                                nt['fired'] = True
##                                changed = True
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##    k = ""
##    # triggers for create/set reminders
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember","set me a reminder","set me a reminder for","set me a reminder about")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for parsing, but derive a clean subject
##        original_for_parsing = msg_text
##        subject = clean_reminder_subject(original_for_parsing)
##
####        subject = subject.replace(k,"")
##        subject = subject.replace("can you","")
##        subject = subject.replace("please","")
##        subject = subject.replace("for","")
##        subject = subject.replace("to","")
##        subject = subject.replace("ing","")
##        subject = subject.replace("my","your")
##
##
##        # If subject empty, ask first what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        if not subject:
##            # cannot determine subject -> save quick reminder
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now parse date/time from the original utterance (so time tokens are preserved)
##        msg_text_for_parsing = original_for_parsing
##
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower() or "day after tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1 if "tomorrow" in msg_text_for_parsing.lower() else 2)
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays anywhere in phrase
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0:
##                                days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text_for_parsing)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # interactively ask if missing
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare recurrence parsing
##        rec_spec = parse_recurrence_from_text(msg_text_for_parsing)
##        # build list of event datetimes from recurrence spec
##        occurrences = expand_recurrences(parsed_dt, subject, rec_spec) if parsed_dt else []
##        if not occurrences:
##            occurrences = [parsed_dt] if parsed_dt else []
##
##        # confirm creation. If multiple events, summarise count.
##        if len(occurrences) == 1:
##            final_dt = occurrences[0]
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save that reminder.")
##                return
##            try:
##                ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##                try:
##                    _set_reminder_speaking(True)
##                    _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##                finally:
##                    _set_reminder_speaking(False)
##                if gui is not None and hasattr(gui, "log_query"):
##                    gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##            except Exception as e:
##                print("Error adding event:", e)
##                _speak("Failed to save reminder.")
##            return
##        else:
##            # multiple occurrences -> ask for confirmation with brief summary
##            title_candidate = subject or extract_title_from_text(subject) or "Reminder"
##            summary = ", ".join([d.strftime("%Y-%m-%d %H:%M") for d in occurrences[:5]])
##            more = "" if len(occurrences) <= 5 else f" and {len(occurrences)-5} more"
##            confirm_text = f"I will create {len(occurrences)} reminders for '{title_candidate}', starting {occurrences[0].strftime('%Y-%m-%d %H:%M')}. Example: {summary}{more}. Confirm?"
##            confirmed = _ask_confirm_and_listen(confirm_text, timeout=18, attempts=2)
##            if not confirmed:
##                _speak("Okay, I will not save those reminders.")
##                return
##            created = 0
##            for d in occurrences:
##                try:
##                    ev = add_organizer_event(title_candidate, d.date().isoformat(), d.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred (recurrence)", event_type="reminder")
##                    created += 1
##                except Exception as e:
##                    print("Error adding recurring event:", e)
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Created {created} reminders for '{title_candidate}'.")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {created} events")
##            return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you","what do you remember")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##



















##  # BESTEST SO FAR 2026_01_25__19h00
##
### reminders_module.py
###   SNOOZE IS BLOCKING
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    """
##    Detects if the string contains AM/PM/period words and returns (cleaned_string_without_period_words, ampm)
##    where ampm is 'am'/'pm'/None. It searches the whole input, so phrases like 'in the evening' anywhere will be detected.
##    """
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles:
##      - 'half past 1 in the morning'
##      - 'quarter past 5 in the evening'
##      - 'quarter to 4 in the afternoon'
##      - '5 o clock'
##      - '10 past 10 in the evening'
##      - '20 minutes past 6 in the morning'
##      - 'midnight', 'noon'
##      - '15h30', '09h45'
##      - '16:10', '00:00'
##    Returns None if it cannot parse.
##    """
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm and get cleaned string without am/pm tokens (looking across whole phrase)
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30 or 15h 30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y' or 'X past Y'
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y'
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) simple 'N past H' handled above, also '(\d+) past (\d+)'
##    m_simple_past = re.search(r"\b(\d{1,2})\s+past\s+(\d{1,2})\b", s_no_ampm)
##    if m_simple_past:
##        try:
##            mins = int(m_simple_past.group(1))
##            hour = int(m_simple_past.group(2)) % 24
##            minute = mins % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) "X o'clock"
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 8) two-number tokens 'ten thirty'
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) single number token interpret as hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 10) digits cluster like 930 or 1530
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h
##                minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember)\b[\s,:-]*'
##)
##
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        if "hour" in resp:
##            return n * 60
##        return n
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            _speak("Okay, not snoozing.")
##            return False
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            if now >= notify_dt:
##                                nt['fired'] = True
##                                changed = True
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- Robust date/time parser used by handler ----------
##def parse_date_time_from_text(text: str) -> Optional[dt.datetime]:
##    """
##    Try many heuristics to extract a datetime from arbitrary user text.
##    Returns a naive local datetime or None when parsing fails.
##    """
##    if not text:
##        return None
##    s = safe_str(text)
##    s_low = s.lower()
##
##    # 1) relative "in X minutes/hours/days"
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|mins?|hours?|days?|weeks?)\b", s_low)
##    if m_rel:
##        num_phrase = m_rel.group(2).strip()
##        unit = m_rel.group(3)
##        try:
##            num = int(num_phrase)
##        except:
##            num = words_to_number(num_phrase)
##        if num is not None:
##            now = dt.datetime.now()
##            if unit.startswith("hour"): return now + dt.timedelta(hours=num)
##            if unit.startswith("minute"): return now + dt.timedelta(minutes=num)
##            if unit.startswith("day"): return now + dt.timedelta(days=num)
##            if unit.startswith("week"): return now + dt.timedelta(weeks=num)
##
##    # 2) explicit date formats
##    date_val = None
##    m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m_date_iso:
##        date_val = m_date_iso.group(1)
##    elif m_date_slash:
##        try:
##            d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##            date_val = d.isoformat()
##        except Exception:
##            date_val = None
##
##    # 3) try spoken_time_to_hm on full text (this also reads period words anywhere)
##    hm = spoken_time_to_hm(s)
##    if hm:
##        # decide date: explicit date, 'today', 'tomorrow', weekdays, or assume today/next day
##        if date_val:
##            try:
##                parsed_date = dt.date.fromisoformat(date_val)
##            except Exception:
##                parsed_date = dt.date.today()
##        else:
##            if re.search(r"\btomorrow\b", s_low):
##                parsed_date = dt.date.today() + dt.timedelta(days=1)
##            elif re.search(r"\btoday\b", s_low):
##                parsed_date = dt.date.today()
##            else:
##                # weekdays
##                picked = None
##                for wd, idx in _WEEKDAYS.items():
##                    if re.search(rf"\b{wd}\b", s_low):
##                        days_ahead = (idx - dt.date.today().weekday()) % 7
##                        if days_ahead == 0: days_ahead = 7
##                        picked = dt.date.today() + dt.timedelta(days=days_ahead)
##                        break
##                if picked:
##                    parsed_date = picked
##                else:
##                    # default: today's date, but if time already passed assume next day
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    return cand
##        return dt.datetime.combine(parsed_date, dt.time(hm[0], hm[1]))
##
##    # 4) If no specific time found but period words exist (morning/afternoon/evening/tonight),
##    # choose a reasonable default time for the period.
##    period_map = {
##        "morning": (9, 0),
##        "this morning": (9, 0),
##        "afternoon": (15, 0),
##        "evening": (18, 0),
##        "this evening": (18, 0),
##        "tonight": (20, 0),
##        "night": (21, 0),
##        "noon": (12, 0),
##        "midnight": (0, 0)
##    }
##    for key, hm_def in period_map.items():
##        if re.search(rf"\b{re.escape(key)}\b", s_low):
##            # decide date as above
##            if date_val:
##                try:
##                    parsed_date = dt.date.fromisoformat(date_val)
##                except Exception:
##                    parsed_date = dt.date.today()
##            else:
##                if re.search(r"\btomorrow\b", s_low):
##                    parsed_date = dt.date.today() + dt.timedelta(days=1)
##                elif re.search(r"\btoday\b", s_low):
##                    parsed_date = dt.date.today()
##                else:
##                    # check weekday reference
##                    picked = None
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", s_low):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            picked = dt.date.today() + dt.timedelta(days=days_ahead)
##                            break
##                    parsed_date = picked if picked else dt.date.today()
##            return dt.datetime.combine(parsed_date, dt.time(hm_def[0], hm_def[1]))
##
##    # 5) final attempt: if explicit date available but no time, default to 09:00
##    if date_val:
##        try:
##            parsed_date = dt.date.fromisoformat(date_val)
##            return dt.datetime.combine(parsed_date, dt.time(9, 0))
##        except Exception:
##            pass
##
##    return None
##
### ---------- public handler (entrypoint used by main.py) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for time/date parsing, but clean subject for reminder text
##        original_for_parsing = msg_text  # keep full user phrase (may contain date/time tokens)
##        # remove leading triggers and trailing date/time from subject
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # If subject now empty, ask what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        # If still empty after asking -> treat as quick reminder text unknown -> save quick reminder or abort
##        if not subject:
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now proceed to parse date/time from the original utterance (so we don't lose time info)
##        msg_text_for_parsing = original_for_parsing
##
##        # Use the robust parser
##        parsed_dt = None
##        try:
##            parsed_dt = parse_date_time_from_text(msg_text_for_parsing)
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        # try using parser
##                        rv = parse_date_time_from_text(rtxt)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = subject or extract_title_from_text(subject)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()




























###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            # some logs are "2026-01-25 : 15:05:53 : " (date : time : ), that regex above expects an extra colon - adjust to cover common pattern:
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                # alternate form: maybe "YYYY-MM-DD : HH:MM:SS :"
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                # cut everything up to the end of the matched timestamp block
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            # don't fail on weird timestamps  continue with original s
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        # if we didn't find ': score' pattern, also try finding " 'score':" without preceding colon-space
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # try to find score
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            # gender
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            # gender_conf
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            # attempt to pull final remaining token as speaker (e.g., "... : ITF" or "... : John")
##            # remove parsed kv pairs from meta_part to look for leftover tokens
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            # leftover tokens separated by ':' or whitespace
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                # choose the last leftover that looks like a name/speaker (alphabetic or mixed) and not a known label
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                # strip it out of body
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles:
##      - 'half past 1 in the morning'
##      - 'quarter past 5 in the evening'
##      - 'quarter to 4 in the afternoon'
##      - '5 o clock'
##      - '10 past 10'
##      - 'midnight', 'noon'
##      - '15h30', '09h45'
##      - '16:10', '00:00'
##    Returns None if it cannot parse.
##    """
##    if spoken is None: return None
##    # direct datetime/time objects:
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm and get cleaned string without am/pm tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30 or 15h 30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            # apply am/pm if present (rare with colon but honor if user said 'pm')
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y' or 'X past Y' (e.g. '20 minutes past 6', '10 past 10')
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' (e.g. '20 minutes to 6' -> 5:40)
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) 'X o'clock' or "X o clock"
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) two-number tokens (e.g. 'ten thirty' or '5 30')
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    if len(tokens) >= 2:
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 8) single number token interpret as hour
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) fallback check cluster digits like 930 or 1530
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h; minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
### This removes leading triggers from the front and strips trailing date/time tokens
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember)\b[\s,:-]*'
##)
##
### Patterns that typically mark the start of time/date information (we cut at earliest occurrence)
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- NEW: robust datetime finder ----------
##def _detect_period_only(text: str) -> Optional[str]:
##    """Return 'morning'/'afternoon'/'evening'/'night'/'noon'/'midnight' or None."""
##    if not text:
##        return None
##    s = text.lower()
##    if re.search(r"\b(morning|this morning|in the morning)\b", s): return "morning"
##    if re.search(r"\b(afternoon|this afternoon)\b", s): return "afternoon"
##    if re.search(r"\b(evening|this evening|in the evening|tonight)\b", s): return "evening"
##    if re.search(r"\b(night)\b", s): return "night"
##    if re.search(r"\bnoon\b", s): return "noon"
##    if re.search(r"\bmidnight\b", s): return "midnight"
##    return None
##
##def _period_default_hour(period: str) -> Tuple[int,int]:
##    """Give a sensible default hour/minute for named periods."""
##    if not period:
##        return (9, 0)
##    per = period.lower()
##    if per in ("morning",): return (9, 0)
##    if per in ("afternoon",): return (15, 0)
##    if per in ("evening", "tonight"): return (18, 30)
##    if per in ("night",): return (20, 0)
##    if per == "noon": return (12, 0)
##    if per == "midnight": return (0, 0)
##    return (9, 0)
##
##def find_datetime_in_text(text: str) -> Optional[dt.datetime]:
##    """
##    Try many strategies to extract a datetime from `text`.
##    Returns a naive local datetime or None if nothing reliable found.
##    """
##    if not text:
##        return None
##    s = safe_str(text)
##    now = dt.datetime.now()
##
##    # 1) relative "in/after X units" with number words supported
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s.lower())
##    if m_rel:
##        num_phrase = m_rel.group(2).strip()
##        unit = m_rel.group(3)
##        try:
##            num = int(num_phrase)
##        except Exception:
##            num = words_to_number(num_phrase)
##        if num is not None:
##            if unit.startswith("hour"):
##                return now + dt.timedelta(hours=num)
##            if unit.startswith("minute") or unit.startswith("min"):
##                return now + dt.timedelta(minutes=num)
##            if unit.startswith("day"):
##                return now + dt.timedelta(days=num)
##            if unit.startswith("week"):
##                return now + dt.timedelta(weeks=num)
##
##    # 2) explicit ISO or slash date present
##    m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    date_val = None
##    if m_date_iso:
##        date_val = m_date_iso.group(1)
##    elif m_date_slash:
##        try:
##            d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##            date_val = d.isoformat()
##        except Exception:
##            date_val = None
##
##    # 3) detect spoken time anywhere
##    hm = spoken_time_to_hm(s)  # will honor 'in the evening' etc
##    period = _detect_period_only(s)
##
##    # 4) detect day words (today/tomorrow/day after tomorrow/weekday/next ...)
##    date_obj = None
##    sl = s.lower()
##    if re.search(r"\bday after tomorrow\b", sl):
##        date_obj = dt.date.today() + dt.timedelta(days=2)
##    elif re.search(r"\btomorrow\b", sl):
##        date_obj = dt.date.today() + dt.timedelta(days=1)
##    elif re.search(r"\btoday\b", sl):
##        date_obj = dt.date.today()
##    else:
##        # weekdays
##        for wd, idx in _WEEKDAYS.items():
##            if re.search(rf"\b(next\s+)?{wd}\b", sl):
##                # if "next X" push one extra week
##                next_week = bool(re.search(rf"\bnext\s+{wd}\b", sl))
##                today_idx = dt.date.today().weekday()
##                days_ahead = (idx - today_idx) % 7
##                if days_ahead == 0:
##                    days_ahead = 7
##                if next_week:
##                    days_ahead += 7
##                date_obj = dt.date.today() + dt.timedelta(days=days_ahead)
##                break
##
##    # 5) Combine detections
##    # If explicit date_str found -> combine with time if available
##    if date_val:
##        try:
##            base_date = dt.date.fromisoformat(date_val)
##        except Exception:
##            base_date = None
##        if base_date:
##            if hm:
##                return dt.datetime.combine(base_date, dt.time(hm[0], hm[1]))
##            if period:
##                hh, mm = _period_default_hour(period)
##                return dt.datetime.combine(base_date, dt.time(hh, mm))
##            # no time -> default 09:00
##            return dt.datetime.combine(base_date, dt.time(9, 0))
##
##    # If date_obj (today/tomorrow/weekday) found:
##    if date_obj:
##        if hm:
##            return dt.datetime.combine(date_obj, dt.time(hm[0], hm[1]))
##        if period:
##            hh, mm = _period_default_hour(period)
##            return dt.datetime.combine(date_obj, dt.time(hh, mm))
##        # if only "today" and no time, default to 09:00
##        return dt.datetime.combine(date_obj, dt.time(9, 0))
##
##    # If we found a spoken time but no explicit date -> choose next occurence (today unless passed)
##    if hm:
##        cand = now.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        if cand < now:
##            cand = cand + dt.timedelta(days=1)
##        return cand
##
##    # If only a period word (e.g., "in the evening") and e.g., "today" present in text
##    if period:
##        # if text mentions tomorrow/day-after-tomorrow pick that; otherwise default today or tomorrow depending on "today"/"tomorrow" presence handled earlier
##        if "tomorrow" in sl:
##            base = dt.date.today() + dt.timedelta(days=1)
##        elif "day after tomorrow" in sl:
##            base = dt.date.today() + dt.timedelta(days=2)
##        elif "today" in sl:
##            base = dt.date.today()
##        else:
##            # no explicit date -> choose today unless time-of-day already passed, then choose tomorrow
##            hh, mm = _period_default_hour(period)
##            cand = now.replace(hour=hh, minute=mm, second=0, microsecond=0)
##            if cand < now:
##                cand = cand + dt.timedelta(days=1)
##            return cand
##        hh, mm = _period_default_hour(period)
##        return dt.datetime.combine(base, dt.time(hh, mm))
##
##    # Nothing found
##    return None
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    # We set the global flag while speaking so other parts of the app won't start listening.
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for time/date parsing, but clean subject for reminder text
##        original_for_parsing = msg_text  # keep full user phrase (may contain date/time tokens)
##        # remove leading triggers and trailing date/time from subject
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # If subject now empty, ask what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                # normalize response
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        # If still empty after asking -> treat as quick reminder text unknown -> save quick reminder or abort
##        if not subject:
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now proceed to parse date/time from the original utterance (so we don't lose time info)
##        msg_text_for_parsing = original_for_parsing
##
##        # NEW: use helper that searches anywhere in the sentence
##        parsed_dt = None
##        try:
##            parsed_dt = find_datetime_in_text(msg_text_for_parsing)
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                            else:
##                                # maybe user only said "this evening" etc.
##                                period = _detect_period_only(rtxt)
##                                if period:
##                                    hh, mm = _period_default_hour(period)
##                                    time_value = f"{hh:02d}:{mm:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = subject or extract_title_from_text(subject)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()


















##      # BESTEST SO FAR 2026_01_25__17H30
##
###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            # some logs are "2026-01-25 : 15:05:53 : " (date : time : ), that regex above expects an extra colon - adjust to cover common pattern:
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                # alternate form: maybe "YYYY-MM-DD : HH:MM:SS :"
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                # cut everything up to the end of the matched timestamp block
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            # don't fail on weird timestamps  continue with original s
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        # if we didn't find ': score' pattern, also try finding " 'score':" without preceding colon-space
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # try to find score
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            # gender
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            # gender_conf
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            # attempt to pull final remaining token as speaker (e.g., "... : ITF" or "... : John")
##            # remove parsed kv pairs from meta_part to look for leftover tokens
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            # leftover tokens separated by ':' or whitespace
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                # choose the last leftover that looks like a name/speaker (alphabetic or mixed) and not a known label
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                # strip it out of body
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Robust spoken time -> (hour, minute) parser.
##    Handles:
##      - 'half past 1 in the morning'
##      - 'quarter past 5 in the evening'
##      - 'quarter to 4 in the afternoon'
##      - '5 o clock'
##      - '10 past 10 in the evening'
##      - '20 minutes past 6 in the morning'
##      - 'midnight', 'noon'
##      - '15h30', '09h45'
##      - '16:10', '00:00'
##    Returns None if it cannot parse.
##    """
##    if spoken is None: return None
##    # direct datetime/time objects:
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##
##    s_orig = safe_str(spoken)
##    s = s_orig.lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # quick special words
##    if re.search(r"\bnoon\b", s): return (12, 0)
##    if re.search(r"\bmidnight\b", s): return (0, 0)
##
##    # detect am/pm and get cleaned string without am/pm tokens
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # 1) explicit 24h with colon or 'h' like 15:30 or 15h30 or 15h 30
##    m_colon = re.search(r"\b(\d{1,2})\s*[:h]\s*(\d{2})\b", s_no_ampm, flags=re.I)
##    if m_colon:
##        try:
##            hh = int(m_colon.group(1)) % 24
##            mm = int(m_colon.group(2)) % 60
##            hour = hh
##            minute = mm
##            # apply am/pm if present (rare with colon but honor if user said 'pm')
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 2) 'half past X'
##    m_half = re.search(r"\bhalf past ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_half:
##        token = m_half.group(1).strip()
##        h = _token_to_number(token)
##        if h is not None:
##            hour = int(h) % 24
##            minute = 30
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 3) 'quarter past/to X'
##    m_quarter = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)\b", s_no_ampm)
##    if m_quarter:
##        typ = m_quarter.group(1)
##        hour_token = m_quarter.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is not None:
##            hour = int(h) % 24
##            if typ == "past":
##                minute = 15
##            else:
##                minute = 45
##                hour = (hour - 1) % 24
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 4) 'X minutes past Y' or 'X past Y' (e.g. '20 minutes past 6', '10 past 10')
##    m_past = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*past\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_past:
##        try:
##            mins = int(m_past.group(1))
##            htoken = m_past.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = int(h) % 24
##                minute = mins % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 5) 'X minutes to Y' (e.g. '20 minutes to 6' -> 5:40)
##    m_to = re.search(r"\b(\d{1,2})\s*(?:minutes?|mins?)?\s*to\s+(\d{1,2}|[a-z]+)\b", s_no_ampm)
##    if m_to:
##        try:
##            mins = int(m_to.group(1))
##            htoken = m_to.group(2)
##            h = _token_to_number(htoken) if not re.fullmatch(r"\d+", htoken) else int(htoken)
##            if h is not None:
##                hour = (int(h) - 1) % 24
##                minute = (60 - (mins % 60)) % 60
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    # 6) simple 'N past H' like '10 past 10' is covered by m_past, but also try '(\d+) past (\d+)'
##    m_simple_past = re.search(r"\b(\d{1,2})\s+past\s+(\d{1,2})\b", s_no_ampm)
##    if m_simple_past:
##        try:
##            mins = int(m_simple_past.group(1))
##            hour = int(m_simple_past.group(2)) % 24
##            minute = mins % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 7) "X o'clock" or "X o clock" or "X oclock"
##    m_oclock = re.search(r"\b(\d{1,2})\s*(?:o['\s]?clock|oclock|o clock)\b", s_no_ampm)
##    if m_oclock:
##        try:
##            hour = int(m_oclock.group(1)) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##        except Exception:
##            pass
##
##    # 8) two-number tokens (e.g. 'ten thirty' or '5 30' or '10 past 10' fallback)
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    # try to find explicit number pairs like 'ten thirty' or 'five thirty'
##    if len(tokens) >= 2:
##        # try greedy parse of first two tokens as hour and minute
##        h_candidate = _token_to_number(tokens[0])
##        m_candidate = _token_to_number(tokens[1])
##        if h_candidate is not None and m_candidate is not None and 0 <= m_candidate < 60:
##            hour = int(h_candidate) % 24
##            minute = int(m_candidate) % 60
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 9) single number token interpret as hour (e.g., "five" -> 05:00)
##    if len(tokens) == 1:
##        h = _token_to_number(tokens[0])
##        if h is not None:
##            hour = int(h) % 24
##            minute = 0
##            if ampm == "pm" and hour < 12: hour += 12
##            if ampm == "am" and hour == 12: hour = 0
##            return (hour, minute)
##
##    # 10) fallback: look for 3-4 digit cluster like 930 or 1530 (handled if present)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                hour = h
##                minute = m
##                if ampm == "pm" and hour < 12: hour += 12
##                if ampm == "am" and hour == 12: hour = 0
##                return (hour, minute)
##        except Exception:
##            pass
##
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
### This removes leading triggers from the front and strips trailing date/time tokens
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember)\b[\s,:-]*'
##)
##
### Patterns that typically mark the start of time/date information (we cut at earliest occurrence)
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    # We set the global flag while speaking so other parts of the app won't start listening.
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for time/date parsing, but clean subject for reminder text
##        original_for_parsing = msg_text  # keep full user phrase (may contain date/time tokens)
##        # remove leading triggers and trailing date/time from subject
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # If subject now empty, ask what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                # normalize response
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        # If still empty after asking -> treat as quick reminder text unknown -> save quick reminder or abort
##        if not subject:
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now proceed to parse date/time from the original utterance (so we don't lose time info)
##        msg_text_for_parsing = original_for_parsing
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text_for_parsing)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = subject or extract_title_from_text(subject)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##



















##  # BEST SO FAR
###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            # some logs are "2026-01-25 : 15:05:53 : " (date : time : ), that regex above expects an extra colon - adjust to cover common pattern:
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                # alternate form: maybe "YYYY-MM-DD : HH:MM:SS :"
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                # cut everything up to the end of the matched timestamp block
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            # don't fail on weird timestamps  continue with original s
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        # if we didn't find ': score' pattern, also try finding " 'score':" without preceding colon-space
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # try to find score
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            # gender
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            # gender_conf
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            # attempt to pull final remaining token as speaker (e.g., "... : ITF" or "... : John")
##            # remove parsed kv pairs from meta_part to look for leftover tokens
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            # leftover tokens separated by ':' or whitespace
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                # choose the last leftover that looks like a name/speaker (alphabetic or mixed) and not a known label
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                # strip it out of body
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- NEW: clean subject helper ----------
### This removes leading triggers from the front and strips trailing date/time tokens
##_TRIGGER_LEADING_RE = re.compile(
##    r'(?i)^(?:schedule me a meeting with|create me a meeting|setup a meeting|create me a reminder|set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder for|set a reminder about|set a reminder|set reminder|remind me to|remind me about|remind me|create me a reminder|create a reminder|i want to remember|can you remember)\b[\s,:-]*'
##)
##
### Patterns that typically mark the start of time/date information (we cut at earliest occurrence)
##_DATE_TIME_CUES = [
##    r'\bin\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\bafter\s+\d+\s+(?:seconds?|minutes?|mins?|hours?|days?|weeks?)\b',
##    r'\btomorrow\b', r'\btoday\b', r'\btonight\b', r'\bthis morning\b', r'\bthis evening\b',
##    r'\bday after tomorrow\b',
##    r'\bon\b', r'\bat\b', r'\bby\b', r'\bnext\b',
##    r'\b(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b',
##    r'\b\d{4}-\d{2}-\d{2}\b', r'\b\d{1,2}/\d{1,2}/\d{4}\b',
##    r'\b\d{1,2}:\d{2}\b', r'\bhalf past\b', r'\bquarter (?:past|to)\b',
##    r'\b\d{1,2}\s?(?:am|pm)\b'
##]
##_DATE_TIME_CUES_COMPILED = [re.compile(pat, flags=re.I) for pat in _DATE_TIME_CUES]
##
##def clean_reminder_subject(text: str) -> str:
##    """
##    Remove leading trigger phrase (like 'remind me to', 'set me a reminder for') from front
##    and trim away trailing date/time phrases so the returned text is just the reminder subject.
##    """
##    if not text:
##        return ""
##    t = safe_str(text)
##    # remove leading trigger
##    t = _TRIGGER_LEADING_RE.sub("", t).strip()
##    if not t:
##        return ""
##    # find earliest date/time cue and cut there
##    earliest = None
##    for cre in _DATE_TIME_CUES_COMPILED:
##        m = cre.search(t)
##        if m:
##            idx = m.start()
##            if earliest is None or idx < earliest:
##                earliest = idx
##    if earliest is not None and earliest > 0:
##        t = t[:earliest].strip(" ,:-")
##    # final cleanup
##    t = re.sub(r'\s{2,}', ' ', t).strip(" ,:.")
##    return t
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    # We set the global flag while speaking so other parts of the app won't start listening.
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##        # Preserve original utterance for time/date parsing, but clean subject for reminder text
##        original_for_parsing = msg_text  # keep full user phrase (may contain date/time tokens)
##        # remove leading triggers and trailing date/time from subject
##        subject = clean_reminder_subject(original_for_parsing)
##
##        # If subject now empty, ask what the reminder should be about
##        if not subject:
##            resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##            if resp:
##                # normalize response
##                try:
##                    resp_text, spk, sc, g, gc = extract_text_from_query(resp)
##                except Exception:
##                    resp_text = resp
##                subject = safe_str(resp_text)
##
##        # If still empty after asking -> treat as quick reminder text unknown -> save quick reminder or abort
##        if not subject:
##            _append_lines_to_file([original_for_parsing])
##            _speak("Saved quick reminder (no subject).")
##            return
##
##        # Now proceed to parse date/time from the original utterance (so we don't lose time info)
##        msg_text_for_parsing = original_for_parsing
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text_for_parsing.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text_for_parsing.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text_for_parsing.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text_for_parsing)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text_for_parsing.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text_for_parsing)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text_for_parsing)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text_for_parsing)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text_for_parsing)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = subject or extract_title_from_text(subject)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = subject or extract_title_from_text(subject)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##













###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- reminder-speaking flag (thread-safe) ----------
##REMINDER_SPEAKING_DONT_LISTEN = False
##_REMINDER_SPEAKING_LOCK = threading.Lock()
##
##def _set_reminder_speaking(flag: bool):
##    global REMINDER_SPEAKING_DONT_LISTEN
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            REMINDER_SPEAKING_DONT_LISTEN = bool(flag)
##    except Exception:
##        # best-effort only; swallow errors
##        pass
##
##def get_reminder_speaking_flag() -> bool:
##    try:
##        with _REMINDER_SPEAKING_LOCK:
##            return bool(REMINDER_SPEAKING_DONT_LISTEN)
##    except Exception:
##        return False
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##
##
##
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##
##    # Helper to parse numeric-or-None strings
##    def _to_float_or_none(v):
##        if v is None:
##            return None
##        if isinstance(v, (float, int)):
##            return float(v)
##        s = str(v).strip()
##        if s.lower() == "none" or s == "":
##            return None
##        try:
##            return float(s)
##        except Exception:
##            return None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        original = query
##        s = query.strip()
##
##        # --- try base64 decode if it looks like base64 (unchanged) ---
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded:
##                        s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        # --- strip leading timestamp like "YYYY-MM-DD : HH:MM:SS : " if present ---
##        try:
##            dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*\d{2}\s*:\s*', s)
##            # some logs are "2026-01-25 : 15:05:53 : " (date : time : ), that regex above expects an extra colon - adjust to cover common pattern:
##            if not dt_match:
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*', s)
##            if not dt_match:
##                # alternate form: maybe "YYYY-MM-DD : HH:MM:SS :"
##                dt_match = re.search(r'\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:', s)
##            if dt_match:
##                # cut everything up to the end of the matched timestamp block
##                s = s[dt_match.end():].lstrip()
##        except Exception:
##            # don't fail on weird timestamps  continue with original s
##            pass
##
##        # --- detect trailing metadata start (score/gender/gender_conf) and split ---
##        meta_idx = None
##        for key in ("'score'", '"score"', "score"):
##            m = re.search(r'\s*:\s*' + re.escape(key), s)
##            if m:
##                meta_idx = m.start()
##                break
##        # if we didn't find ': score' pattern, also try finding " 'score':" without preceding colon-space
##        if meta_idx is None:
##            for key in ("'score'", '"score"', "score"):
##                m = re.search(re.escape(key) + r'\s*[:=]', s)
##                if m:
##                    meta_idx = m.start()
##                    break
##
##        meta_part = ""
##        body = s
##        if meta_idx is not None:
##            body = s[:meta_idx].rstrip(" :")
##            meta_part = s[meta_idx:].lstrip(" :")
##
##        # If meta_part present parse score/gender/gender_conf and final speaker token
##        score_val = None
##        gender_val = None
##        gender_conf_val = None
##        speaker_val = None
##
##        if meta_part:
##            # try to find score
##            m_score = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                      or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                      or re.search(r'\bscore\b\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_score:
##                score_val = _to_float_or_none(m_score.group("v"))
##            # gender
##            m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\",:}]+)['\"]?", meta_part, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"\n,}]+)["]?', meta_part, flags=re.I) \
##                    or re.search(r'\bgender\b\s*[:=]\s*["\']?(?P<v>[^"\',:}]+)["\']?', meta_part, flags=re.I)
##            if m_gender:
##                gv = m_gender.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##            # gender_conf
##            m_gconf = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", meta_part, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I) \
##                     or re.search(r'\bgender_conf\b\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', meta_part, flags=re.I)
##            if m_gconf:
##                gender_conf_val = _to_float_or_none(m_gconf.group("v"))
##
##            # attempt to pull final remaining token as speaker (e.g., "... : ITF" or "... : John")
##            # remove parsed kv pairs from meta_part to look for leftover tokens
##            meta_clean = meta_part
##            meta_clean = re.sub(r"'score'\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"score"\s*[:=]\s*(?:None|[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender'\s*[:=]\s*['\"]?[^'\"\n,}]+['\"]?", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender"\s*[:=]\s*["]?[^\n,}"]+["]?', "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r"'gender_conf'\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)", "", meta_clean, flags=re.I)
##            meta_clean = re.sub(r'"gender_conf"\s*[:=]\s*(?:[0-9]+(?:\.[0-9]+)?)', "", meta_clean, flags=re.I)
##
##            # leftover tokens separated by ':' or whitespace
##            leftovers = [t.strip() for t in re.split(r'[:\n]', meta_clean) if t.strip()]
##            if leftovers:
##                # choose the last leftover that looks like a name/speaker (alphabetic or mixed) and not a known label
##                for token in reversed(leftovers):
##                    if token.lower() not in ("score", "gender", "gender_conf", "none", "null"):
##                        speaker_val = token
##                        break
##
##        # --- fallback: if no metadata parsed, attempt earlier regexes for score/gender/gender_conf present inside body ---
##        if score_val is None:
##            m_score2 = re.search(r"'score'\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                    or re.search(r'"score"\s*[:=]\s*(?P<v>None|[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_score2:
##                score_val = _to_float_or_none(m_score2.group("v"))
##                # strip it out of body
##                body = body[:m_score2.start()].rstrip(" :")
##
##        if gender_val is None:
##            m_gender2 = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<v>[^'\"\n,}]+)['\"]?", body, flags=re.I) \
##                    or re.search(r'"gender"\s*[:=]\s*["]?(?P<v>[^"]+)["]?', body, flags=re.I)
##            if m_gender2:
##                gv = m_gender2.group("v").strip()
##                gender_val = None if gv.lower() == "none" else safe_str(gv)
##                body = body[:m_gender2.start()].rstrip(" :")
##
##        if gender_conf_val is None:
##            m_gconf2 = re.search(r"'gender_conf'\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)", body, flags=re.I) \
##                     or re.search(r'"gender_conf"\s*[:=]\s*(?P<v>[0-9]+(?:\.[0-9]+)?)', body, flags=re.I)
##            if m_gconf2:
##                gender_conf_val = _to_float_or_none(m_gconf2.group("v"))
##                body = body[:m_gconf2.start()].rstrip(" :")
##
##        # --- now try to find 'text' or 'speaker' keys inside body (unchanged behaviour) ---
##        looks_like_dict = body.startswith("{") and ("'text'" in body or '"text"' in body or "'speaker'" in body or '"speaker"' in body)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(body)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(body)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", body)
##        text_val = safe_str(m_text.group("t")) if m_text else body
##
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", body)
##        if m_speaker:
##            speaker_val = safe_str(m_speaker.group("s"))
##
##        # post-process speaker found earlier (trim device suffixes and "none")
##        if isinstance(speaker_val, str):
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val.strip(), flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # final fallback
##    return safe_str(query), None, None, None, None
##
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    # We set the global flag while speaking so other parts of the app won't start listening.
##    try:
##        _set_reminder_speaking(True)
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##    finally:
##        _set_reminder_speaking(False)
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##
##
##        # NEW: If the user included the reminder subject in the same phrase,
##        # strip leading trigger up to the subject and use remainder as the reminder text.
##        # Patterns to strip (case-insensitive): "set me a reminder for", "set me a reminder about",
##        # "set a reminder for", "set a reminder about", "remind me to", "remind me about", "remind me".
##        try:
##            m = re.search(r"(?i)(?:set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder about|remind me to|remind me about|remind me)(?:\s+)(?P<sub>.+)", msg_text)
##            if m:
##                # Use the text after the trigger as the reminder subject
##                subject = m.group("sub").strip()
##                if subject:
##                    msg_text = subject
##            else:
##                # If no subject included, ask first what the reminder should be about
##                # (this is the behavior you requested)
##                # But only ask if the msg_text is short or basically equal to the trigger
##                stripped = re.sub(r"(?i)^(?:remind me|set a reminder|set a reminder for me|set me a reminder|create a reminder)(\W*)$", "", msg_text).strip()
##                if not stripped:
##                    resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##
##
##                    try:
##                        msg_text, speaker, score, gender, gender_conf = extract_text_from_query(resp)
##                    except Exception:
##                        msg_text = text_clean
##                    msg_text = safe_str(msg_text)
##
##                    print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##                    print(f"[DEBUG REMINDER] speaker : {speaker}")
##                    print(f"[DEBUG REMINDER] score : {score}")
##                    print(f"[DEBUG REMINDER] gender : {gender}")
##                    print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##                    resp = msg_text
##
##                    if resp:
##                        msg_text = resp.strip()
##                        
##        except Exception as _e:
##            # on any error leave msg_text as-is
##            print("Reminder subject extraction error:", _e)
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = extract_title_from_text(msg_text)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = extract_title_from_text(msg_text)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            # set the flag while we speak the confirmation
##            try:
##                _set_reminder_speaking(True)
##                _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            finally:
##                _set_reminder_speaking(False)
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            try:
##                _set_reminder_speaking(True)
##                _speak(out); _send_bluetooth(out)
##            finally:
##                _set_reminder_speaking(False)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##
##
##























###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
### --- Normalizer helper: convert listen() outputs (dict or str) to simple text ---
##def _resp_to_text(resp) -> str:
##    """
##    Normalize responses returned by listen() or other sources into a plain string.
##    Uses extract_text_from_query to handle dicts and stringified dicts consistently.
##    """
##    try:
##        # If it's already a dict or looks like a dict/stringified dict, use extractor
##        if isinstance(resp, dict):
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        if isinstance(resp, str):
##            # extract_text_from_query safely handles stringified dicts and plain strings
##            text, _, _, _, _ = extract_text_from_query(resp)
##            return safe_str(text)
##        return safe_str(resp)
##    except Exception:
##        try:
##            return safe_str(resp)
##        except Exception:
##            return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        resp_text = _resp_to_text(resp)
##        low = resp_text.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = _resp_to_text(resp).lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(_resp_to_text(follow))
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##
##
##        # NEW: If the user included the reminder subject in the same phrase,
##        # strip leading trigger up to the subject and use remainder as the reminder text.
##        # Patterns to strip (case-insensitive): "set me a reminder for", "set me a reminder about",
##        # "set a reminder for", "set a reminder about", "remind me to", "remind me about", "remind me".
##        try:
##            m = re.search(r"(?i)(?:set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder about|remind me to|remind me about|remind me)(?:\s+)(?P<sub>.+)", msg_text)
##            if m:
##                # Use the text after the trigger as the reminder subject
##                subject = m.group("sub").strip()
##                if subject:
##                    msg_text = subject
##            else:
##                # If no subject included, ask first what the reminder should be about
##                # (this is the behavior you requested)
##                # But only ask if the msg_text is short or basically equal to the trigger
##                stripped = re.sub(r"(?i)^(?:remind me|set a reminder|set a reminder for me|set me a reminder|create a reminder)(\W*)$", "", msg_text).strip()
##                if not stripped:
##                    resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##
##
##                    try:
##                        msg_text, speaker, score, gender, gender_conf = extract_text_from_query(resp)
##                    except Exception:
##                        msg_text = text_clean
##                    msg_text = safe_str(msg_text)
##
##                    print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##                    print(f"[DEBUG REMINDER] speaker : {speaker}")
##                    print(f"[DEBUG REMINDER] score : {score}")
##                    print(f"[DEBUG REMINDER] gender : {gender}")
##                    print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##                    resp = msg_text
##
##                    if resp:
##                        msg_text = resp.strip()
##                        
##        except Exception as _e:
##            # on any error leave msg_text as-is
##            print("Reminder subject extraction error:", _e)
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = extract_title_from_text(msg_text)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rtxt = _resp_to_text(resp).lower()
##                    if "tomorrow" in rtxt:
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in rtxt:
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", rtxt)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", rtxt)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        rtxt = _resp_to_text(resp)
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", rtxt.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(rtxt)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = extract_title_from_text(msg_text)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()














###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = listen.listen()
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = input("(debug) type response (or empty): ")
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes, that is correct", "yes, thank you", "yes, you are correct", "yes, thank you", "yes, that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no, that is not correct", "no, that is incorrect", "no, that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        low = resp.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes, that is correct' or 'no, that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder to|for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = resp.lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(follow)
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##        print(f"[DEBUG REMINDER] speaker : {speaker}")
##        print(f"[DEBUG REMINDER] score : {score}")
##        print(f"[DEBUG REMINDER] gender : {gender}")
##        print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##
##
##        # NEW: If the user included the reminder subject in the same phrase,
##        # strip leading trigger up to the subject and use remainder as the reminder text.
##        # Patterns to strip (case-insensitive): "set me a reminder for", "set me a reminder about",
##        # "set a reminder for", "set a reminder about", "remind me to", "remind me about", "remind me".
##        try:
##            m = re.search(r"(?i)(?:set me a reminder for|set me a reminder about|set a reminder for me about|set a reminder for the|set a reminder about|remind me to|remind me about|remind me)(?:\s+)(?P<sub>.+)", msg_text)
##            if m:
##                # Use the text after the trigger as the reminder subject
##                subject = m.group("sub").strip()
##                if subject:
##                    msg_text = subject
##            else:
##                # If no subject included, ask first what the reminder should be about
##                # (this is the behavior you requested)
##                # But only ask if the msg_text is short or basically equal to the trigger
##                stripped = re.sub(r"(?i)^(?:remind me|set a reminder|set a reminder for me|set me a reminder|create a reminder)(\W*)$", "", msg_text).strip()
##                if not stripped:
##                    resp = _ask_question_and_get_response("What should I remind you about?", attempts=3, timeout_per_attempt=15)
##
##
##                    try:
##                        msg_text, speaker, score, gender, gender_conf = extract_text_from_query(resp)
##                    except Exception:
##                        msg_text = text_clean
##                    msg_text = safe_str(msg_text)
##
##                    print(f"[DEBUG REMINDER] msg_text : {msg_text}")
##                    print(f"[DEBUG REMINDER] speaker : {speaker}")
##                    print(f"[DEBUG REMINDER] score : {score}")
##                    print(f"[DEBUG REMINDER] gender : {gender}")
##                    print(f"[DEBUG REMINDER] gender_conf : {gender_conf}")
##
##                    resp = msg_text
##
##                    if resp:
##                        msg_text = resp.strip()
##                        
##        except Exception as _e:
##            # on any error leave msg_text as-is
##            print("Reminder subject extraction error:", _e)
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            if parsed_dt is None:
##                if "tomorrow" in msg_text.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            if parsed_dt is None:
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                hm = spoken_time_to_hm(msg_text)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            title_candidate = extract_title_from_text(msg_text)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    if "tomorrow" in resp.lower():
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in resp.lower():
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", resp)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", resp)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", resp.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(resp)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = extract_title_from_text(msg_text)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime('%H:%M'), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##






















###     MOST AWESOME SO FAR 2026_01_16__00h00
##
##
###   SNOOZE IS BLOCKING
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple, Dict, Any
##import datetime as dt
##
### try to reuse your project's speech/listen objects if available
##try:
##    from speech import speech
##except Exception:
##    speech = None
##try:
##    from listen import listen
##except Exception:
##    listen = None
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
##def _speak(text: str):
##    try:
##        if speech is not None and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if listen is not None and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if speech is not None:
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 20) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if listen is not None and hasattr(listen, "listen"):
##                got = safe_str(listen.listen())
##            else:
##                try:
##                    # debug fallback when running module directly
##                    got = safe_str(input("(debug) type response (or empty): "))
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 3) -> bool:
####    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y", "yes thank you", "affirmative","correct","okay","ok", "yes you are correct", "yes that is correct", "yes thank you", "yes that is great"}
##    yes_words = {"yes that is correct", "yes thank you", "yes you are correct", "yes thank you", "yes that is great"}
####    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n", "no that is not correct", "no that is incorrect"}
##    no_words = {"no that is not correct", "no that is incorrect", "no that is wrong"}
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is not correct'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        low = resp.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: use first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            if tokens[0] in yes_words: return True
##            if tokens[0] in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand.  Please say 'yes that is correct' or 'no that is not correct.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing helpers (reuse your previous robust functions) ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
### We'll use a concise but solid time parser based on words_to_number and token parsing.
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning","this morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening","this evening","tonight","tonite"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##    if re.search(r"\bnoon\b", s0): ampm = "pm"
##    if re.search(r"\bmidnight\b", s0): ampm = "am"
##    if ampm:
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    if re.search(r"\bnoon\b", s): return (12,0)
##    if re.search(r"\bmidnight\b", s): return (0,0)
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute = 30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##        else:
##            organizer_events = []
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
### ---------- compute notify times ----------
##def _unique_sorted_times(times: List[dt.datetime]) -> List[dt.datetime]:
##    # unique and sort
##    uniq = {}
##    for t in times:
##        try:
##            iso = t.replace(second=0, microsecond=0).isoformat()
##            uniq[iso] = t
##        except Exception:
##            pass
##    out = sorted([dt.datetime.fromisoformat(k) for k in uniq.keys()])
##    return out
##
##def _compute_notify_times_for_event(dtstart: dt.datetime, now: Optional[dt.datetime] = None) -> List[dt.datetime]:
##    """
##    Build the list of datetime notifications for an event datetime (naive local).
##    Strategy:
##      - fixed times on event day: 07:00, 10:00, 12:00 (only if between now and event)
##      - relative: 60, 30, 15 minutes before event, and at event time
##    """
##    now = now or dt.datetime.now()
##    event_date = dtstart.date()
##    candidates: List[dt.datetime] = []
##
##    # day-fixed times (only on the event date)
##    for hh in (7, 10, 12):
##        try:
##            cand = dt.datetime.combine(event_date, dt.time(hh, 0))
##            # only include if before event and after now
##            if cand < dtstart and cand > now:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # relative offsets (minutes before)
##    for minutes_before in (60, 30, 15, 0):
##        try:
##            cand = dtstart - dt.timedelta(minutes=minutes_before)
##            if cand > now and cand <= dtstart:
##                candidates.append(cand)
##        except Exception:
##            continue
##
##    # return unique sorted times
##    return _unique_sorted_times(candidates)
##
### ---------- add event (persist, compute notify times) ----------
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # support date_text as ISO date string or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev_id = uuid.uuid4().hex
##        ev = {"id": ev_id, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        # compute notify_times list of dicts: {t: iso, fired: False}
##        notify_list = _compute_notify_times_for_event(dtstart)
##        ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in notify_list]
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
### ---------- load-time migration: ensure notify_times exists ----------
##def _migrate_loaded_events():
##    changed = False
##    now = dt.datetime.now()
##    for ev in organizer_events:
##        try:
##            # Ensure dtstart is isostring
##            ds = ev.get("dtstart")
##            if not ds:
##                continue
##            dtstart = dt.datetime.fromisoformat(ds)
##            # if notify_times missing or empty compute them
##            if not ev.get("notify_times"):
##                nts = _compute_notify_times_for_event(dtstart, now=now)
##                ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                changed = True
##            else:
##                # ensure structure and clean invalid entries
##                new_nts = []
##                for item in ev.get("notify_times", []):
##                    if isinstance(item, dict) and item.get("t"):
##                        try:
##                            dt.datetime.fromisoformat(item["t"])
##                            new_nts.append({"t": item["t"], "fired": bool(item.get("fired", False))})
##                        except Exception:
##                            continue
##                # if empty, compute
##                if not new_nts:
##                    nts = _compute_notify_times_for_event(dtstart, now=now)
##                    ev["notify_times"] = [{"t": t.isoformat(), "fired": False} for t in nts]
##                    changed = True
##                else:
##                    ev["notify_times"] = new_nts
##        except Exception:
##            continue
##    if changed: _save_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- notification/snooze handling ----------
##def _parse_snooze_minutes(resp: str) -> Optional[int]:
##    if not resp: return None
##    resp = resp.lower()
##    # try digits first
##    m = re.search(r"(\d+)\s*(minutes|minute|min|mins|hours|hour|h)\b", resp)
##    if m:
##        n = int(m.group(1))
##        unit = m.group(2)
##        if "hour" in unit or unit == "h":
##            return n * 60
##        return n
##    # try words
##    n = words_to_number(resp)
##    if isinstance(n, int):
##        # default interpret as minutes unless phrase contains 'hour'
##        if "hour" in resp:
##            return n * 60
##        return n
##    # common short forms
##    if "five" in resp or "5" in resp: return 5
##    if "ten" in resp or "10" in resp: return 10
##    if "fifteen" in resp or "15" in resp: return 15
##    if "thirty" in resp or "30" in resp: return 30
##    if "one hour" in resp or "60" in resp or "1 hour" in resp: return 60
##    return None
##
##def _announce_and_handle_snooze(ev: Dict[str, Any], notify_iso: str):
##    """
##    Called when a notify_time becomes due. Announces and optionally handles snooze.
##    """
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        title = ev.get('title', '(no title)')
##        notify_time = dt.datetime.fromisoformat(notify_iso)
##        # announce
##        _speak(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. This alert was scheduled for {notify_time.strftime('%H:%M')}.")
##        _send_bluetooth(f"Reminder: {title}. Scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}.")
##        # Ask if user wants to snooze
##        resp = _ask_question_and_get_response("Would you like to snooze this reminder? Say 'no' or say e.g. 'snooze 10 minutes'.", attempts=2, timeout_per_attempt=10)
##        if not resp:
##            # No response considered 'no'
##            return False
##        low = resp.lower()
##        if any(w in low for w in ("no","nah","nope","don't","do not","dont","cancel","stop","skip")):
##            return False
##        # detect snooze
##        minutes = _parse_snooze_minutes(low)
##        if minutes is None:
##            # try simple pattern "snooze" + next answer
##            if "snooze" in low:
##                follow = _ask_question_and_get_response("How many minutes would you like to snooze for? Try 5, 10, 15, 30 or 60.", attempts=2, timeout_per_attempt=10)
##                if follow:
##                    minutes = _parse_snooze_minutes(follow)
##        if minutes is None:
##            # can't parse => treat as no
##            _speak("Okay, not snoozing.")
##            return False
##        # schedule a new notify time `minutes` from now
##        new_t = dt.datetime.now() + dt.timedelta(minutes=minutes)
##        # append and mark fired False so notifier will handle it later
##        ev.setdefault("notify_times", []).append({"t": new_t.isoformat(), "fired": False})
##        _speak(f"Snoozed for {minutes} minutes. I will remind you again at {new_t.strftime('%H:%M')}.")
##        _save_organizer_events()
##        return True
##    except Exception as e:
##        print("_announce_and_handle_snooze error:", e)
##        return False
##
### ---------- main notifier loop ----------
##_NOTIFIER_THREAD = None
##_NOTIFIER_THREAD_LOCK = threading.Lock()
##
##def _notifier_loop(poll_seconds: int = 20):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            # iterate over events (copy so we can modify underlying list)
##            for ev in organizer_events:
##                try:
##                    nts = ev.get("notify_times", [])
##                    for nt in nts:
##                        try:
##                            if nt.get("fired", False):
##                                continue
##                            notify_dt = dt.datetime.fromisoformat(nt['t'])
##                            # If it's time or past time, announce
##                            if now >= notify_dt:
##                                # mark fired immediately to avoid duplicate announcements
##                                nt['fired'] = True
##                                changed = True
##                                # announce and handle snooze; if snoozed, event state already updated by function
##                                _announce_and_handle_snooze(ev, nt['t'])
##                        except Exception:
##                            continue
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread(poll_seconds: int = 20):
##    global _NOTIFIER_THREAD
##    with _NOTIFIER_THREAD_LOCK:
##        if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##            return
##        _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds": poll_seconds}, daemon=True)
##        _NOTIFIER_THREAD.start()
##
### ---------- load / migration on import ----------
##_load_organizer_events()
##_migrate_loaded_events()
##
### ---------- public handler (entrypoint used by main.py) ----------
### This function is compatible with the main.py delegation earlier.
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Name Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    # triggers
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","set reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        # Try relative or natural parsing first
##        parsed_dt = None
##        parsed_dt = None
##        try:
##            parsed_dt = None
##            # parse time/date combos
##            # try parse_natural_time (simple approach) then fallbacks
##            # here we re-use spoken_time_to_hm + parse_natural_date style heuristics
##            # first try to parse expressions like "in 3 hours" or "in two days at 6 pm"
##            # reuse functions inline from above: parse relative patterns
##            # quick relative
##            m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", msg_text.lower())
##            if m_rel:
##                num_phrase = m_rel.group(2).strip()
##                unit = m_rel.group(3)
##                try:
##                    num = int(num_phrase)
##                except:
##                    num = words_to_number(num_phrase)
##                if num is not None:
##                    now = dt.datetime.now()
##                    if unit.startswith("hour"): parsed_dt = now + dt.timedelta(hours=num)
##                    elif unit.startswith("minute"): parsed_dt = now + dt.timedelta(minutes=num)
##                    elif unit.startswith("day"): parsed_dt = now + dt.timedelta(days=num)
##                    elif unit.startswith("week"): parsed_dt = now + dt.timedelta(weeks=num)
##            # next try "tomorrow", "today", weekdays etc
##            if parsed_dt is None:
##                # if contains explicit "tomorrow" or "today" or weekday tokens
##                if "tomorrow" in msg_text.lower():
##                    base = dt.date.today() + dt.timedelta(days=1)
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                elif "today" in msg_text.lower():
##                    base = dt.date.today()
##                    hm = spoken_time_to_hm(msg_text)
##                    if hm: parsed_dt = dt.datetime.combine(base, dt.time(hm[0], hm[1]))
##                    else: parsed_dt = dt.datetime.combine(base, dt.time(9,0))
##                else:
##                    # weekdays
##                    for wd, idx in _WEEKDAYS.items():
##                        if re.search(rf"\b{wd}\b", msg_text.lower()):
##                            days_ahead = (idx - dt.date.today().weekday()) % 7
##                            if days_ahead == 0: days_ahead = 7
##                            target = dt.date.today() + dt.timedelta(days=days_ahead)
##                            hm = spoken_time_to_hm(msg_text)
##                            if hm:
##                                parsed_dt = dt.datetime.combine(target, dt.time(hm[0], hm[1]))
##                            else:
##                                parsed_dt = dt.datetime.combine(target, dt.time(9,0))
##                            break
##            # if still none, try to extract explicit date and time tokens
##            if parsed_dt is None:
##                # extract ISO-like date  YYYY-MM-DD or dd/mm/YYYY
##                m_date_iso = re.search(r"(\d{4}-\d{2}-\d{2})", msg_text)
##                m_date_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", msg_text)
##                date_val = None
##                if m_date_iso:
##                    date_val = m_date_iso.group(1)
##                elif m_date_slash:
##                    try:
##                        d = dt.datetime.strptime(m_date_slash.group(1), "%d/%m/%Y").date()
##                        date_val = d.isoformat()
##                    except:
##                        date_val = None
##                # time
##                hm = spoken_time_to_hm(msg_text)
##                if date_val and hm:
##                    parsed_dt = dt.datetime.combine(dt.date.fromisoformat(date_val), dt.time(hm[0], hm[1]))
##                elif hm:
##                    # no explicit date; pick next matching day (tomorrow if passed)
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand = cand + dt.timedelta(days=1)
##                    parsed_dt = cand
##            # final fallback: spoken_time_to_hm alone
##            if parsed_dt is None:
##                hm = spoken_time_to_hm(msg_text)
##                if hm:
##                    cand = dt.datetime.now().replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##                    if cand < dt.datetime.now():
##                        cand += dt.timedelta(days=1)
##                    parsed_dt = cand
##        except Exception:
##            parsed_dt = None
##
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # attempt to ask the user interactively for missing pieces
##            # title candidate
##            title_candidate = extract_title_from_text(msg_text)
##            if not date_value:
##                resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date like 2026-12-24.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    # try parse date
##                    if "tomorrow" in resp.lower():
##                        date_value = (dt.date.today() + dt.timedelta(days=1)).isoformat()
##                    elif "today" in resp.lower():
##                        date_value = dt.date.today().isoformat()
##                    else:
##                        # try ISO or dd/mm/yyyy
##                        m_iso = re.search(r"(\d{4}-\d{2}-\d{2})", resp)
##                        m_slash = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", resp)
##                        if m_iso:
##                            date_value = m_iso.group(1)
##                        elif m_slash:
##                            try:
##                                d = dt.datetime.strptime(m_slash.group(1), "%d/%m/%Y").date()
##                                date_value = d.isoformat()
##                            except:
##                                date_value = None
##            if not time_value:
##                resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##                if resp:
##                    rv = None
##                    try:
##                        # try relative
##                        m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+)\s+(seconds?|minutes?|hours?|days?)\b", resp.lower())
##                        if m_rel:
##                            num_phrase = m_rel.group(2).strip()
##                            unit = m_rel.group(3)
##                            try: num = int(num_phrase)
##                            except: num = words_to_number(num_phrase)
##                            if num is not None:
##                                if unit.startswith("hour"): rv = dt.datetime.now() + dt.timedelta(hours=num)
##                                elif unit.startswith("minute"): rv = dt.datetime.now() + dt.timedelta(minutes=num)
##                                elif unit.startswith("day"): rv = dt.datetime.now() + dt.timedelta(days=num)
##                        if rv:
##                            parsed_dt = rv
##                            date_value = parsed_dt.date().isoformat()
##                            time_value = parsed_dt.time().strftime("%H:%M")
##                        else:
##                            hm = spoken_time_to_hm(resp)
##                            if hm:
##                                time_value = f"{hm[0]:02d}:{hm[1]:02d}"
##                    except Exception:
##                        pass
##            if not parsed_dt:
##                # use defaults or partial
##                if not date_value:
##                    date_value = dt.date.today().isoformat()
##                if not time_value:
##                    time_value = "09:00"
##            # build final_dt
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                parsed_date = dt.date.today()
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9,0)
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##            parsed_dt = final_dt
##
##        # prepare title and confirm
##        title_candidate = extract_title_from_text(msg_text)
##        if not title_candidate:
##            title_candidate = "Reminder"
##        final_dt = parsed_dt
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Add event (this computes notify_times)
##        try:
##            ev = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {ev.get('ics_path','(no ics)')}")
##        except Exception as e:
##            print("Error adding event:", e)
##            _speak("Failed to save reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### start notifier when module imported
##start_reminder_notifier_thread()
##
##
##











##
###   WORKING AWESOME NO SNOOZE
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple
##import datetime as dt
##
##from speech import speech
##from listen import listen
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
### ---------- speak / bluetooth wrappers ----------
##def _speak(text: str):
##    try:
##        if 'speech' in globals() and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if 'listen' in globals() and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    try:
##        if 'speech' in globals():
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 12) -> str:
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    while _time.time() < end_time:
##        try:
##            if 'listen' in globals() and hasattr(listen, "listen"):
##                got = safe_str(listen.listen())
##            else:
##                try:
##                    got = safe_str(input("(debug) type response (or empty): "))
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return ""
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 2) -> bool:
##    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y","affirmative","correct","okay","ok", "yes that is correct", "yes you are correct"}
##    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n"}
##
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say 'yes that is correct' or 'no that is wrong'.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        low = resp.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            t0 = tokens[0]
##            if t0 in yes_words: return True
##            if t0 in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extract text from query ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date/time helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##def spoken_date_to_ymd(spoken) -> Optional[Tuple[int, Optional[int], Optional[int]]]:
##    if spoken is None: return None
##    if isinstance(spoken, (dt.datetime, dt.date)):
##        d = spoken.date() if isinstance(spoken, dt.datetime) else spoken
##        return (d.year, d.month, d.day)
##    s = safe_str(spoken).lower().replace("-", " ").replace("/", " ").replace(",", " ")
##    s = re.sub(r"\b(st|nd|rd|th)\b", "", s)
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    if not tokens: return None
##    whole = words_to_number(" ".join(tokens))
##    if whole is not None and whole >= 1000:
##        return (whole, None, None)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=3)
##    if not nums: return None
##    if len(nums) >= 3 and nums[0] >= 1000:
##        return (nums[0], nums[1], nums[2])
##    if len(nums) >= 3 and nums[0] < 100 and 1 <= nums[1] <= 12 and 1 <= nums[2] <= 31:
##        year = 2000 + (nums[0] % 100)
##        return (year, nums[1], nums[2])
##    if len(nums) == 1 and 0 <= nums[0] < 100:
##        return (2000 + nums[0], None, None)
##    return None
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening", "this evening", "tonight", "tonite", "night", "this night", "in the night"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    """
##    Detect an am/pm-like word in s and remove it, returning (cleaned_string, 'am'|'pm'|None).
##    This now handles 'tonight', 'this evening', 'this morning', 'noon', and 'midnight'.
##    """
##    s0 = safe_str(s).lower()
##    ampm = None
##
##    # direct textual matches that indicate AM
##    for w in _AM_WORDS:
##        if re.search(r"\b" + re.escape(w) + r"\b", s0):
##            ampm = "am"
##            break
##    # direct textual matches that indicate PM
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b" + re.escape(w) + r"\b", s0):
##                ampm = "pm"
##                break
##
##    # also interpret explicit 'noon' / 'midnight'
##    if re.search(r"\bnoon\b", s0):
##        ampm = "pm"
##    if re.search(r"\bmidnight\b", s0):
##        ampm = "am"
##
##    if ampm:
##        # remove common am/pm words and phrases (expanded list)
##        pattern = r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening|this morning|this evening|tonight|tonite|noon|midnight|this night)\b"
##        s0 = re.sub(pattern, " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    """
##    Parse spoken time into (hour, minute). Handles:
##      - "half past six", "quarter to nine", "quarter past nine"
##      - "six thirty", "eighteen thirty", "six thirty pm"
##      - "0630", "1830"
##      - "six pm", "six"
##      - "ten o'clock tonight" -> 22:00  (fixed)
##      - "noon" -> 12:00, "midnight" -> 00:00
##    """
##    if spoken is None:
##        return None
##    # handle direct datetime/time objects
##    if isinstance(spoken, dt.datetime):
##        return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time):
##        return (spoken.hour, spoken.minute)
##
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ").strip()
##    # handle 'noon' / 'midnight' quickly
##    if re.search(r"\bnoon\b", s):
##        return (12, 0)
##    if re.search(r"\bmidnight\b", s):
##        return (0, 0)
##
##    s = re.sub(r"\b(o'clock)\b", "", s)
##    s = re.sub(r"\s+", " ", s).strip()
##
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##
##    # "half past six"
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip()
##        h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24
##        minute = 30
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##
##    # "quarter past/to"
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip()
##        h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24
##        if typ == "past":
##            minute = 15
##        else:  # "to"
##            minute = 45
##            hour = (hour - 1) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##
##    # explicit HHMM cluster like 1830 or 0630
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                if ampm == "pm" and h < 12: h += 12
##                if ampm == "am" and h == 12: h = 0
##                return (h, m)
##        except Exception:
##            pass
##
##    # tokenized numeric words e.g. "six thirty", "eighteen thirty", "ten o clock"
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None:
##            num_list.append(v)
##
##    if len(num_list) >= 2:
##        hour = int(num_list[0]) % 24
##        minute = int(num_list[1]) % 60
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour = int(num_list[0]) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, 0)
##
##    # nothing matched
##    return None
##
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
##def parse_natural_time(text: str, now: Optional[dt.datetime] = None) -> Optional[dt.datetime]:
##    if text is None: return None
##    if isinstance(text, dt.datetime): return text
##    if isinstance(text, dt.date): return dt.datetime.combine(text, dt.time(9,0))
##    now = now or dt.datetime.now()
##    s = safe_str(text).lower().strip()
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s)
##    if m_rel:
##        num_phrase = m_rel.group(2).strip(); unit = m_rel.group(3)
##        num = None
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        unit = unit.rstrip("s")
##        if unit == "second": return now + dt.timedelta(seconds=num)
##        if unit == "minute": return now + dt.timedelta(minutes=num)
##        if unit == "hour": return now + dt.timedelta(hours=num)
##        if unit == "day": return now + dt.timedelta(days=num)
##        if unit == "week": return now + dt.timedelta(weeks=num)
##    m_rel2 = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(days?)\b\s*(?:at\s+(.+))?", s)
##    if m_rel2:
##        num_phrase = m_rel2.group(2).strip()
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        base = now + dt.timedelta(days=int(num))
##        at = m_rel2.group(4)
##        if at:
##            hm = spoken_time_to_hm(at)
##            if hm: return dt.datetime.combine(base.date(), dt.time(hm[0], hm[1]))
##        return base
##    if "tomorrow" in s:
##        base = now + dt.timedelta(days=1)
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base.replace(hour=9, minute=0, second=0, microsecond=0)
##    if "today" in s:
##        base = now
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base
##    for wd, idx in _WEEKDAYS.items():
##        if re.search(rf"\b{wd}\b", s):
##            days_ahead = (idx - now.weekday()) % 7
##            if days_ahead == 0: days_ahead = 7
##            target = now + dt.timedelta(days=days_ahead)
##            hm = spoken_time_to_hm(s)
##            if hm: return target.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##            return target.replace(hour=9, minute=0, second=0, microsecond=0)
##    hm = spoken_time_to_hm(s)
##    if hm:
##        candidate = now.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        if candidate < now: candidate += dt.timedelta(days=1)
##        return candidate
##    return None
##
##def parse_natural_date(text: str) -> Optional[str]:
##    if text is None: return None
##    if isinstance(text, (dt.datetime, dt.date)):
##        d = text.date() if isinstance(text, dt.datetime) else text
##        return d.isoformat()
##    s = safe_str(text).lower()
##    m = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    if m: return m.group(1)
##    m = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m:
##        try: d = dt.datetime.strptime(m.group(1), "%d/%m/%Y").date(); return d.isoformat()
##        except: pass
##    today = dt.date.today()
##    if re.search(r"\btoday\b", s): return today.isoformat()
##    if re.search(r"\btomorrow\b", s): return (today + dt.timedelta(days=1)).isoformat()
##    if re.search(r"\b(day after tomorrow|in two days)\b", s): return (today + dt.timedelta(days=2)).isoformat()
##    for wd, idx in _WEEKDAY_MAP.items():
##        if re.search(rf"\bthis\s+{wd}\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\bnext\s+{wd}\b", s) or re.search(rf"\b{wd}\s+next\s+week\b", s):
##            td = today.weekday(); days_ahead = ((idx-td)%7)+7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\b{wd}\b", s) and not re.search(r"\bthis\b", s) and not re.search(r"\bnext\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7
##            if days_ahead == 0: days_ahead = 7
##            return (today + dt.timedelta(days=days_ahead)).isoformat()
##    try:
##        ymd = spoken_date_to_ymd(text)
##        if ymd:
##            y,m,d = ymd
##            if y and m and d: return f"{y:04d}-{m:02d}-{d:02d}"
##            if y: return f"{y:04d}-01-01"
##    except: pass
##    return None
##
### ---------- organizer persistence ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR", "PRODID:-//AlfredOrganizer//EN", "VERSION:2.0", "CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT", f"UID:{uid}", f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}", f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}", f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT", "END:VCALENDAR", ""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev = {"id": uuid.uuid4().hex, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##_load_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    # defensive: remove leading timestamp wrappers if present
##    s = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", s)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    # strip trailing " : Name Home" if present
##    s = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- handler ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    # Defensive cleaning: remove common timestamp wrapper inserted by main.py
##    text_clean = re.sub(r"^\s*\d{4}-\d{2}-\d{2}\s*:\s*\d{2}:\d{2}:\d{2}\s*:\s*", "", text_in)
##    # remove trailing speaker tokens like " : Tjaart Home"
##    text_clean = re.sub(r"\s*:\s*[A-Za-z0-9\-' ]{1,40}\s*(Home|Office|Work|Phone)?\s*$", "", text_clean, flags=re.I)
##    lower = text_clean.lower()
##
##    if any(k in lower for k in ("remind me", "create a reminder", "create me a reminder", "set a reminder", "set reminder", "i want to remember", "can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_clean)
##        except Exception:
##            msg_text = text_clean
##        msg_text = safe_str(msg_text)
##
##        parsed_dt = parse_natural_time(msg_text)
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            date_value = parse_natural_date(msg_text)
##            dt_candidate = parse_natural_time(msg_text)
##            if isinstance(dt_candidate, dt.datetime):
##                parsed_dt = dt_candidate
##                date_value = parsed_dt.date().isoformat()
##                time_value = parsed_dt.time().strftime("%H:%M")
##            elif isinstance(dt_candidate, dt.time):
##                time_value = dt_candidate.strftime("%H:%M")
##            elif dt_candidate:
##                # dt_candidate might be datetime-like
##                date_value = dt_candidate.date().isoformat()
##                time_value = dt_candidate.time().strftime("%H:%M")
##            if time_value is None:
##                tstr = spoken_time_to_str(msg_text)
##                if tstr: time_value = tstr
##
##        title_candidate = extract_title_from_text(msg_text)
##
##        if not date_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                dv = parse_natural_date(resp)
##                if dv:
##                    date_value = dv
##                else:
##                    ymd = spoken_date_to_ymd(resp)
##                    if ymd and ymd[0] and ymd[1] and ymd[2]:
##                        date_value = f"{ymd[0]:04d}-{ymd[1]:02d}-{ymd[2]:02d}"
##
##        if not time_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                rv = parse_natural_time(resp)
##                if rv:
##                    parsed_dt = rv; date_value = parsed_dt.date().isoformat(); time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    tv = parse_natural_time(resp)
##                    if tv:
##                        if isinstance(tv, dt.datetime):
##                            date_value = tv.date().isoformat()
##                            time_value = tv.time().strftime("%H:%M")
##                        else:
##                            time_value = tv.strftime("%H:%M")
##                    else:
##                        tstr = spoken_time_to_str(resp)
##                        if tstr: time_value = tstr
##
##        if not date_value and parsed_dt is None and not time_value:
##            _append_lines_to_file([title_candidate])
##            _speak(f"Saved quick reminder: {title_candidate}")
##            return
##
##        if parsed_dt:
##            final_dt = parsed_dt
##        else:
##            if not date_value: date_value = dt.date.today().isoformat()
##            if not time_value: time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                try: parsed_date = dt.datetime.strptime(date_value, "%Y-%m-%d").date()
##                except Exception: parsed_date = None
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0],hm[1]) if hm else dt.time(9,0)
##            if parsed_date is None:
##                _append_lines_to_file([f"{title_candidate} (date unknown: {msg_text})"])
##                _speak("I saved the reminder text but could not determine the date. Ask me again with a clearer date and I will schedule it.")
##                return
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        try:
##            event = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {event.get('ics_path','(no ics)')}")
##        except Exception:
##            try:
##                ev = {"id": uuid.uuid4().hex, "title": title_candidate, "dtstart": final_dt.isoformat(), "duration_minutes": 60, "reminder_minutes": 15, "description": "Created by Alfred", "ics_path": None, "notified": False}
##                ics = _write_ics_file(ev)
##                if ics: ev['ics_path'] = ics
##                organizer_events.append(ev); _save_organizer_events()
##                _speak(f"Created calendar file for {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}.")
##            except Exception:
##                _speak("Failed to create calendar reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule", "what do i have", "what are my reminders", "what are my meetings", "what do i have scheduled", "what can you remember", "what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### ---------- notifier ----------
##_NOTIFIER_THREAD = None
##def _notifier_loop(poll_seconds: int = 30):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    if ev.get("notified", False):
##                        continue
##                    dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##                    remind_before = int(ev.get("reminder_minutes", 15))
##                    notify_time = dtstart - dt.timedelta(minutes=remind_before)
##                    if now >= notify_time:
##                        _speak(f"Hallo There. Sir. Please take note!!! . You have a Reminder: {ev.get('title','an event')} scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}. So please do not forget !!!")
##                        ev['notified'] = True
##                        changed = True
##                except Exception:
##                    continue
##            if changed: _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread():
##    global _NOTIFIER_THREAD
##    if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##        return
##    _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds":30}, daemon=True)
##    _NOTIFIER_THREAD.start()
##
### demo
##if __name__ == "__main__":
##    print("Reminder module demo. Type a test phrase or 'quit'.")
##    start_reminder_notifier_thread()
##    while True:
##        q = input("You: ").strip()
##        if not q or q.lower() in ("quit","exit"): break
##        handle_voice_command(q)
##























####    BEST WORKING NOT CORRECT TIMES
### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple
##import datetime as dt
##
### ---------- small helpers ----------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
### ---------- speech / bluetooth / listen wrappers (best-effort) ----------
##def _speak(text: str):
##    try:
##        if 'speech' in globals() and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if 'listen' in globals() and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---------- robust listen helpers ----------
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    """Wait (best-effort) until TTS finishes speaking before opening mic."""
##    try:
##        if 'speech' in globals():
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            if getattr(speech, "_currently_speaking", False):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 12) -> str:
##    """
##    Try to listen for `timeout` seconds. Uses `listen.listen()` if available;
##    otherwise falls back to `input()` for debugging.
##    """
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    last_nonempty = ""
##    while _time.time() < end_time:
##        try:
##            if 'listen' in globals() and hasattr(listen, "listen"):
##                got = safe_str(listen.listen())
##            else:
##                # debug fallback
##                try:
##                    got = safe_str(input("(debug) type response (or empty): "))
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                return got
##        except Exception as e:
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.18)
##    return last_nonempty
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    """Ask a spoken question then try multiple times to capture an answer."""
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 2) -> bool:
##    """Ask yes/no with retries. Returns True on confirmation."""
##    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y","affirmative","correct","okay","ok"}
##    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n"}
##
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say yes or no.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        low = resp.lower()
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        # fallback: check first token
##        tokens = re.findall(r"[a-z]+", low)
##        if tokens:
##            t0 = tokens[0]
##            if t0 in yes_words: return True
##            if t0 in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    """Convert 'two thousand and twenty six' -> 2026 etc. Returns None if not parseable."""
##    if phrase is None: return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extract text (handles dict inputs) ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date/time parsing ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##def spoken_date_to_ymd(spoken) -> Optional[Tuple[int, Optional[int], Optional[int]]]:
##    if spoken is None: return None
##    if isinstance(spoken, (dt.datetime, dt.date)):
##        d = spoken.date() if isinstance(spoken, dt.datetime) else spoken
##        return (d.year, d.month, d.day)
##    s = safe_str(spoken).lower().replace("-", " ").replace("/", " ").replace(",", " ")
##    s = re.sub(r"\b(st|nd|rd|th)\b", "", s)
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    if not tokens: return None
##    whole = words_to_number(" ".join(tokens))
##    if whole is not None and whole >= 1000:
##        return (whole, None, None)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=3)
##    if not nums: return None
##    if len(nums) >= 3 and nums[0] >= 1000:
##        return (nums[0], nums[1], nums[2])
##    if len(nums) >= 3 and nums[0] < 100 and 1 <= nums[1] <= 12 and 1 <= nums[2] <= 31:
##        year = 2000 + (nums[0] % 100)
##        return (year, nums[1], nums[2])
##    if len(nums) == 1 and 0 <= nums[0] < 100:
##        return (2000 + nums[0], None, None)
##    return None
##
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="am"; break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="pm"; break
##    if ampm:
##        s0 = re.sub(r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening)\b", " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    s = re.sub(r"\b(o'clock)\b", "", s); s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24; minute = 30
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24
##        if typ == "past": minute = 15
##        else: minute = 45; hour = (hour - 1) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3: h = int(cluster[0]); m = int(cluster[1:])
##            else: h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                if ampm == "pm" and h < 12: h += 12
##                if ampm == "am" and h == 12: h = 0
##                return (h, m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0]) % 24; minute = int(num_list[1]) % 60
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour = int(num_list[0]) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
##def parse_natural_time(text: str, now: Optional[dt.datetime] = None) -> Optional[dt.datetime]:
##    if text is None: return None
##    if isinstance(text, dt.datetime): return text
##    if isinstance(text, dt.date): return dt.datetime.combine(text, dt.time(9,0))
##    now = now or dt.datetime.now()
##    s = safe_str(text).lower().strip()
##    # relative: "in 3 hours" / "in two days at 6 pm"
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s)
##    if m_rel:
##        num_phrase = m_rel.group(2).strip(); unit = m_rel.group(3)
##        num = None
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        unit = unit.rstrip("s")
##        if unit == "second": return now + dt.timedelta(seconds=num)
##        if unit == "minute": return now + dt.timedelta(minutes=num)
##        if unit == "hour": return now + dt.timedelta(hours=num)
##        if unit == "day": return now + dt.timedelta(days=num)
##        if unit == "week": return now + dt.timedelta(weeks=num)
##    m_rel2 = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(days?)\b\s*(?:at\s+(.+))?", s)
##    if m_rel2:
##        num_phrase = m_rel2.group(2).strip()
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        base = now + dt.timedelta(days=int(num))
##        at = m_rel2.group(4)
##        if at:
##            hm = spoken_time_to_hm(at)
##            if hm: return dt.datetime.combine(base.date(), dt.time(hm[0], hm[1]))
##        return base
##    if "tomorrow" in s:
##        base = now + dt.timedelta(days=1)
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base.replace(hour=9, minute=0, second=0, microsecond=0)
##    if "today" in s:
##        base = now
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base
##    for wd, idx in _WEEKDAYS.items():
##        if re.search(rf"\b{wd}\b", s):
##            days_ahead = (idx - now.weekday()) % 7
##            if days_ahead == 0: days_ahead = 7
##            target = now + dt.timedelta(days=days_ahead)
##            hm = spoken_time_to_hm(s)
##            if hm: return target.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##            return target.replace(hour=9, minute=0, second=0, microsecond=0)
##    hm = spoken_time_to_hm(s)
##    if hm:
##        candidate = now.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        if candidate < now: candidate += dt.timedelta(days=1)
##        return candidate
##    return None
##
##def parse_natural_date(text: str) -> Optional[str]:
##    if text is None: return None
##    if isinstance(text, (dt.datetime, dt.date)):
##        d = text.date() if isinstance(text, dt.datetime) else text
##        return d.isoformat()
##    s = safe_str(text).lower()
##    m = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    if m: return m.group(1)
##    m = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m:
##        try: d = dt.datetime.strptime(m.group(1), "%d/%m/%Y").date(); return d.isoformat()
##        except: pass
##    today = dt.date.today()
##    if re.search(r"\btoday\b", s): return today.isoformat()
##    if re.search(r"\btomorrow\b", s): return (today + dt.timedelta(days=1)).isoformat()
##    if re.search(r"\b(day after tomorrow|in two days)\b", s): return (today + dt.timedelta(days=2)).isoformat()
##    for wd, idx in _WEEKDAY_MAP.items():
##        if re.search(rf"\bthis\s+{wd}\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\bnext\s+{wd}\b", s) or re.search(rf"\b{wd}\s+next\s+week\b", s):
##            td = today.weekday(); days_ahead = ((idx-td)%7)+7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\b{wd}\b", s) and not re.search(r"\bthis\b", s) and not re.search(r"\bnext\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7
##            if days_ahead == 0: days_ahead = 7
##            return (today + dt.timedelta(days=days_ahead)).isoformat()
##    try:
##        ymd = spoken_date_to_ymd(text)
##        if ymd:
##            y,m,d = ymd
##            if y and m and d: return f"{y:04d}-{m:02d}-{d:02d}"
##            if y: return f"{y:04d}-01-01"
##    except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=2)
##    if nums:
##        padded = []
##        for v in nums:
##            if 0 <= v < 100: padded.append(f"{v:02d}")
##            else: padded.append(str(v))
##        for i in range(0, max(0, len(padded) - 3)):
##            chunk = "".join(padded[i:i+4])
##            if len(chunk) == 8:
##                try:
##                    y = int(chunk[:4]); mo = int(chunk[4:6]); da = int(chunk[6:8])
##                    if 1900 <= y <= 3000 and 1 <= mo <= 12 and 1 <= da <= 31:
##                        return f"{y:04d}-{mo:02d}-{da:02d}"
##                except: pass
##    return None
##
##def parse_relative_datetime(text) -> Optional[dt.datetime]:
##    if text is None: return None
##    return parse_natural_time(text)
##
### ---------- organizer persistence ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR", "PRODID:-//AlfredOrganizer//EN", "VERSION:2.0", "CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT", f"UID:{uid}", f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}", f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}", f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT", "END:VCALENDAR", ""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev = {"id": uuid.uuid4().hex, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##_load_organizer_events()
##
### ---------- quick reminders file ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- voice command handler ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    lower = text_in.lower()
##
##    # If user asks to create or view reminders
##    if any(k in lower for k in ("remind me", "create a reminder", "create me a reminder", "set a reminder", "set reminder", "i want to remember", "can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_in)
##        except Exception:
##            msg_text = text_in
##        msg_text = safe_str(msg_text)
##
##        # Try relative/explicit parsing
##        parsed_dt = parse_relative_datetime(msg_text)
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            date_value = parse_natural_date(msg_text)
##            dt_candidate = parse_natural_time(msg_text)
##            if dt_candidate:
##                if isinstance(dt_candidate, dt.datetime):
##                    parsed_dt = dt_candidate
##                    date_value = parsed_dt.date().isoformat()
##                    time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    time_value = dt_candidate.strftime("%H:%M")
##            if time_value is None:
##                tstr = spoken_time_to_str(msg_text)
##                if tstr: time_value = tstr
##
##        title_candidate = extract_title_from_text(msg_text)
##
##        # Ask date if missing
##        if not date_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                dv = parse_natural_date(resp)
##                if dv:
##                    date_value = dv
##                else:
##                    ymd = spoken_date_to_ymd(resp)
##                    if ymd and ymd[0] and ymd[1] and ymd[2]:
##                        date_value = f"{ymd[0]:04d}-{ymd[1]:02d}-{ymd[2]:02d}"
##
##        # Ask time if missing
##        if not time_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                rv = parse_relative_datetime(resp)
##                if rv:
##                    parsed_dt = rv; date_value = parsed_dt.date().isoformat(); time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    tv = parse_natural_time(resp)
##                    if tv:
##                        if isinstance(tv, dt.datetime):
##                            date_value = tv.date().isoformat()
##                            time_value = tv.time().strftime("%H:%M")
##                        else:
##                            time_value = tv.strftime("%H:%M")
##                    else:
##                        tstr = spoken_time_to_str(resp)
##                        if tstr: time_value = tstr
##
##        # If neither date nor time resolved, save as quick reminder
##        if not date_value and parsed_dt is None and not time_value:
##            _append_lines_to_file([title_candidate])
##            _speak(f"Saved quick reminder: {title_candidate}")
##            return
##
##        # Build final datetime
##        if parsed_dt:
##            final_dt = parsed_dt
##        else:
##            if not date_value: date_value = dt.date.today().isoformat()
##            if not time_value: time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                try: parsed_date = dt.datetime.strptime(date_value, "%Y-%m-%d").date()
##                except Exception: parsed_date = None
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0],hm[1]) if hm else dt.time(9,0)
##            if parsed_date is None:
##                _append_lines_to_file([f"{title_candidate} (date unknown: {msg_text})"])
##                _speak("I saved the reminder text but could not determine the date. Ask me again with a clearer date and I will schedule it.")
##                return
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##
##        # Confirm
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Create event
##        try:
##            event = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {event.get('ics_path','(no ics)')}")
##        except Exception:
##            try:
##                ev = {"id": uuid.uuid4().hex, "title": title_candidate, "dtstart": final_dt.isoformat(), "duration_minutes": 60, "reminder_minutes": 15, "description": "Created by Alfred", "ics_path": None, "notified": False}
##                ics = _write_ics_file(ev)
##                if ics: ev['ics_path'] = ics
##                organizer_events.append(ev); _save_organizer_events()
##                _speak(f"Created calendar file for {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}.")
##            except Exception:
##                _speak("Failed to create calendar reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule", "what do i have", "what are my reminders", "what are my meetings", "what do i have scheduled", "what can you remember", "what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### ---------- notifier ----------
##_NOTIFIER_THREAD = None
##def _notifier_loop(poll_seconds: int = 30):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    if ev.get("notified", False):
##                        continue
##                    dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##                    remind_before = int(ev.get("reminder_minutes", 15))
##                    notify_time = dtstart - dt.timedelta(minutes=remind_before)
##                    if now >= notify_time:
##                        _speak(f"Reminder: {ev.get('title','an event')} scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}")
##                        ev['notified'] = True
##                        changed = True
##                except Exception:
##                    continue
##            if changed: _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread():
##    global _NOTIFIER_THREAD
##    if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##        return
##    _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds":30}, daemon=True)
##    _NOTIFIER_THREAD.start()
##
### demo only if run directly
##if __name__ == "__main__":
##    print("Reminder module demo. Type a test phrase or 'quit'.")
##    start_reminder_notifier_thread()
##    while True:
##        q = input("You: ").strip()
##        if not q or q.lower() in ("quit","exit"): break
##        handle_voice_command(q)














### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple
##import datetime as dt
##
### ----------------- small utilities -----------------
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
### ---------- speech/listen wrappers (use your app's objects if available) ----------
##def _speak(text: str):
##    try:
##        if 'speech' in globals() and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if 'listen' in globals() and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
### ---- improved listen + interactive question helpers ----
##import time as _time
##
##def _wait_for_tts_to_finish(max_wait: int = 6):
##    """
##    Wait until TTS finishes speaking (best-effort) to avoid microphone starting early.
##    """
##    try:
##        if 'speech' in globals():
##            # prefer public is_speaking
##            is_speaking_fn = getattr(speech, "is_speaking", None)
##            if callable(is_speaking_fn):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    try:
##                        if not bool(is_speaking_fn()):
##                            break
##                    except Exception:
##                        break
##                    _time.sleep(0.12)
##                return
##            # fallback to internal flag
##            if getattr(speech, "_currently_speaking", None):
##                start = _time.time()
##                while _time.time() - start < max_wait:
##                    if not getattr(speech, "_currently_speaking", False):
##                        break
##                    _time.sleep(0.12)
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 12) -> str:
##    """
##    Robust single-response listener:
##      - waits for TTS to finish
##      - tries listen.listen() repeatedly until timeout
##      - fallback to input() for debugging if listen not available
##    """
##    _wait_for_tts_to_finish(max_wait=3)
##    end_time = _time.time() + max(1, int(timeout))
##    last_nonempty = ""
##    while _time.time() < end_time:
##        try:
##            if 'listen' in globals() and hasattr(listen, "listen"):
##                got = safe_str(listen.listen())
##            else:
##                # debug fallback: type response
##                try:
##                    got = safe_str(input("(debug) type response (or empty): "))
##                except Exception:
##                    got = ""
##            if got:
##                print("[listen] Heard:", got)
##                last_nonempty = got
##                return got
##        except Exception as e:
##            # non-fatal, continue until timeout
##            print("_listen_once listen() error:", e)
##        _time.sleep(0.20)
##    return last_nonempty
##
##def _ask_question_and_get_response(question: str, attempts: int = 3, timeout_per_attempt: int = 12) -> str:
##    """
##    Speak question and try up to `attempts` times to collect a non-empty reply.
##    """
##    for attempt in range(attempts):
##        _speak(question)
##        _send_bluetooth(question)
##        _time.sleep(0.28)
##        resp = _listen_once(timeout=timeout_per_attempt)
##        if resp:
##            print(f"_ask_question_and_get_response: got on attempt {attempt+1}: {resp}")
##            return resp
##        if attempt + 1 < attempts:
##            _speak("I didn't catch that. Please say it again.")
##            _send_bluetooth("I didn't catch that. Please say it again.")
##            _time.sleep(0.12)
##    print("_ask_question_and_get_response: no reply after attempts")
##    return ""
##
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12, attempts: int = 2) -> bool:
##    """
##    Ask a yes/no confirmation, retrying a couple times. Returns True for confirm.
##    """
##    yes_words = {"yes","yep","yeah","confirm","do it","sure","please","y","affirmative","correct","okay","ok"}
##    no_words = {"no","nah","nope","don't","do not","dont","cancel","stop","not","nay","negative","n"}
##
##    for i in range(attempts):
##        resp = _ask_question_and_get_response(confirm_text + " Please say yes or no.", attempts=1, timeout_per_attempt=timeout)
##        if not resp:
##            if i + 1 < attempts:
##                continue
##            return False
##        low = resp.lower()
##        tokens = re.findall(r"[a-z]+", low)
##        if any(w in low for w in yes_words) and not any(w in low for w in no_words):
##            return True
##        if any(w in low for w in no_words) and not any(w in low for w in yes_words):
##            return False
##        if tokens:
##            t0 = tokens[0]
##            if t0 in yes_words: return True
##            if t0 in no_words: return False
##        if i + 1 < attempts:
##            _speak("I didn't understand. Please answer yes or no.")
##            _send_bluetooth("I didn't understand. Please answer yes or no.")
##            _time.sleep(0.12)
##    return False
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if phrase is None: return None
##    if isinstance(phrase, (dt.date, dt.datetime)): return None
##    if not isinstance(phrase, str): phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words: return None
##    total = 0; current = 0; valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0: current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current; current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    return safe_str(query), None, None, None, None
##
### ---------- date helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##_WEEKDAYS = _WEEKDAY_MAP.copy()
##
##def spoken_date_to_ymd(spoken) -> Optional[Tuple[int, Optional[int], Optional[int]]]:
##    if spoken is None: return None
##    if isinstance(spoken, (dt.datetime, dt.date)):
##        d = spoken.date() if isinstance(spoken, dt.datetime) else spoken
##        return (d.year, d.month, d.day)
##    s = safe_str(spoken).lower().replace("-", " ").replace("/", " ").replace(",", " ")
##    s = re.sub(r"\b(st|nd|rd|th)\b", "", s)
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    if not tokens: return None
##    whole = words_to_number(" ".join(tokens))
##    if whole is not None and whole >= 1000: return (whole, None, None)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=3)
##    if not nums: return None
##    if len(nums) >= 3:
##        if nums[0] >= 1000:
##            year = nums[0]; month = nums[1] if len(nums) > 1 else None; day = nums[2] if len(nums) > 2 else None
##            return (year, month, day)
##        padded = []
##        for v in nums:
##            if 0 <= v < 100:
##                padded.append(f"{v:02d}")
##            else:
##                padded.append(str(v))
##        for i in range(0, max(0, len(padded) - 3)):
##            chunk = "".join(padded[i:i+4])
##            if len(chunk) == 8:
##                try:
##                    y = int(chunk[:4]); mo = int(chunk[4:6]); da = int(chunk[6:8])
##                    if 1900 <= y <= 3000 and 1 <= mo <= 12 and 1 <= da <= 31:
##                        return (y, mo, da)
##                except Exception:
##                    pass
##    if len(nums) >= 2 and nums[0] < 100 and nums[1] <= 12:
##        year = 2000 + (nums[0] % 100); month = nums[1]; day = nums[2] if len(nums) > 2 else None
##        return (year, month, day)
##    if len(nums) == 1 and 0 <= nums[0] < 100:
##        return (2000 + nums[0], None, None)
##    return None
##
### ---------- time parsing ----------
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="am"; break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="pm"; break
##    if ampm:
##        s0 = re.sub(r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening)\b", " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None: return None
##    if isinstance(spoken, dt.datetime): return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time): return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    s = re.sub(r"\b(o'clock)\b", "", s); s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24; minute = 30
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24
##        if typ == "past": minute = 15
##        else: minute = 45; hour = (hour - 1) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3: h = int(cluster[0]); m = int(cluster[1:])
##            else: h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                if ampm == "pm" and h < 12: h += 12
##                if ampm == "am" and h == 12: h = 0
##                return (h, m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0]) % 24; minute = int(num_list[1]) % 60
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour = int(num_list[0]) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- natural parsers ----------
##def parse_natural_time(text: str, now: Optional[dt.datetime] = None) -> Optional[dt.datetime]:
##    if text is None: return None
##    if isinstance(text, dt.datetime): return text
##    if isinstance(text, dt.date): return dt.datetime.combine(text, dt.time(9,0))
##    now = now or dt.datetime.now()
##    s = safe_str(text).lower().strip()
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s)
##    if m_rel:
##        num_phrase = m_rel.group(2).strip(); unit = m_rel.group(3)
##        num = None
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        unit = unit.rstrip("s")
##        if unit == "second": return now + dt.timedelta(seconds=num)
##        if unit == "minute": return now + dt.timedelta(minutes=num)
##        if unit == "hour": return now + dt.timedelta(hours=num)
##        if unit == "day": return now + dt.timedelta(days=num)
##        if unit == "week": return now + dt.timedelta(weeks=num)
##    m_rel2 = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(days?)\b\s*(?:at\s+(.+))?", s)
##    if m_rel2:
##        num_phrase = m_rel2.group(2).strip()
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        base = now + dt.timedelta(days=int(num))
##        at = m_rel2.group(4)
##        if at:
##            hm = spoken_time_to_hm(at)
##            if hm: return dt.datetime.combine(base.date(), dt.time(hm[0], hm[1]))
##        return base
##    if "tomorrow" in s:
##        base = now + dt.timedelta(days=1)
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base.replace(hour=9, minute=0, second=0, microsecond=0)
##    if "today" in s:
##        base = now
##        hm = spoken_time_to_hm(s)
##        if hm: return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base
##    for wd, idx in _WEEKDAYS.items():
##        if re.search(rf"\b{wd}\b", s):
##            days_ahead = (idx - now.weekday()) % 7
##            if days_ahead == 0: days_ahead = 7
##            target = now + dt.timedelta(days=days_ahead)
##            hm = spoken_time_to_hm(s)
##            if hm: return target.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##            return target.replace(hour=9, minute=0, second=0, microsecond=0)
##    hm = spoken_time_to_hm(s)
##    if hm:
##        candidate = now.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        if candidate < now: candidate += dt.timedelta(days=1)
##        return candidate
##    return None
##
##def parse_natural_date(text: str) -> Optional[str]:
##    if text is None: return None
##    if isinstance(text, (dt.datetime, dt.date)):
##        d = text.date() if isinstance(text, dt.datetime) else text
##        return d.isoformat()
##    s = safe_str(text).lower()
##    m = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    if m: return m.group(1)
##    m = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m:
##        try: d = dt.datetime.strptime(m.group(1), "%d/%m/%Y").date(); return d.isoformat()
##        except: pass
##    today = dt.date.today()
##    if re.search(r"\btoday\b", s): return today.isoformat()
##    if re.search(r"\btomorrow\b", s): return (today + dt.timedelta(days=1)).isoformat()
##    if re.search(r"\b(day after tomorrow|in two days)\b", s): return (today + dt.timedelta(days=2)).isoformat()
##    for wd, idx in _WEEKDAY_MAP.items():
##        if re.search(rf"\bthis\s+{wd}\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\bnext\s+{wd}\b", s) or re.search(rf"\b{wd}\s+next\s+week\b", s):
##            td = today.weekday(); days_ahead = ((idx-td)%7)+7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\b{wd}\b", s) and not re.search(r"\bthis\b", s) and not re.search(r"\bnext\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7
##            if days_ahead == 0: days_ahead = 7
##            return (today + dt.timedelta(days=days_ahead)).isoformat()
##    try:
##        ymd = spoken_date_to_ymd(text)
##        if ymd:
##            y,m,d = ymd
##            if y and m and d: return f"{y:04d}-{m:02d}-{d:02d}"
##            if y: return f"{y:04d}-01-01"
##    except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=2)
##    if nums:
##        padded = []
##        for v in nums:
##            if 0 <= v < 100: padded.append(f"{v:02d}")
##            else: padded.append(str(v))
##        for i in range(0, max(0, len(padded) - 3)):
##            chunk = "".join(padded[i:i+4])
##            if len(chunk) == 8:
##                try:
##                    y = int(chunk[:4]); mo = int(chunk[4:6]); da = int(chunk[6:8])
##                    if 1900 <= y <= 3000 and 1 <= mo <= 12 and 1 <= da <= 31:
##                        return f"{y:04d}-{mo:02d}-{da:02d}"
##                except: pass
##    return None
##
##def parse_relative_datetime(text) -> Optional[dt.datetime]:
##    if text is None: return None
##    if isinstance(text, dt.datetime): return text
##    if isinstance(text, dt.date): return dt.datetime.combine(text, dt.time(9,0))
##    s = safe_str(text).lower()
##    return parse_natural_time(s)
##
### ---------- persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR", "PRODID:-//AlfredOrganizer//EN", "VERSION:2.0", "CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT", f"UID:{uid}", f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}", f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}", f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT", "END:VCALENDAR", ""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev = {"id": uuid.uuid4().hex, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##_load_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- main handler ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in: return
##    lower = text_in.lower()
##
##    # CREATE / SET / QUICK REMINDERS
##    if any(k in lower for k in ("remind me", "create a reminder", "create me a reminder", "set a reminder", "set reminder", "i want to remember", "can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_in)
##        except Exception:
##            msg_text = text_in
##        if isinstance(msg_text, (dt.datetime, dt.date)):
##            msg_text = msg_text.isoformat()
##        msg_text = safe_str(msg_text)
##
##        parsed_dt = parse_relative_datetime(msg_text)
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            date_value = parse_natural_date(msg_text)
##            dt_candidate = parse_natural_time(msg_text)
##            if dt_candidate:
##                if isinstance(dt_candidate, dt.datetime) and dt_candidate.date() != dt.datetime.now().date():
##                    parsed_dt = dt_candidate
##                    date_value = parsed_dt.date().isoformat()
##                    time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    time_value = dt_candidate.strftime("%H:%M")
##            if time_value is None:
##                tstr = spoken_time_to_str(msg_text)
##                if tstr: time_value = tstr
##
##        title_candidate = extract_title_from_text(msg_text)
##
##        if not date_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                dv = parse_natural_date(resp)
##                if dv: date_value = dv
##                else:
##                    ymd = spoken_date_to_ymd(resp)
##                    if ymd and ymd[0] and ymd[1] and ymd[2]:
##                        date_value = f"{ymd[0]:04d}-{ymd[1]:02d}-{ymd[2]:02d}"
##
##        if not time_value and parsed_dt is None:
##            resp = _ask_question_and_get_response("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.", attempts=3, timeout_per_attempt=15)
##            if resp:
##                rv = parse_relative_datetime(resp)
##                if rv:
##                    parsed_dt = rv; date_value = parsed_dt.date().isoformat(); time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    tv = parse_natural_time(resp)
##                    if tv:
##                        if isinstance(tv, dt.datetime):
##                            date_value = tv.date().isoformat()
##                            time_value = tv.time().strftime("%H:%M")
##                        else:
##                            time_value = tv.strftime("%H:%M")
##                    else:
##                        tstr = spoken_time_to_str(resp)
##                        if tstr: time_value = tstr
##
##        if not date_value and parsed_dt is None and not time_value:
##            _append_lines_to_file([title_candidate])
##            _speak(f"Saved quick reminder: {title_candidate}")
##            return
##
##        if parsed_dt:
##            final_dt = parsed_dt
##        else:
##            if not date_value:
##                date_value = dt.date.today().isoformat()
##            if not time_value:
##                time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                try: parsed_date = dt.datetime.strptime(date_value, "%Y-%m-%d").date()
##                except Exception: parsed_date = None
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0],hm[1]) if hm else dt.time(9,0)
##            if parsed_date is None:
##                _append_lines_to_file([f"{title_candidate} (date unknown: {msg_text})"])
##                _speak("I saved the reminder text but could not determine the date. Ask me again with a clearer date and I will schedule it.")
##                return
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12, attempts=2)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        try:
##            event = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {event.get('ics_path','(no ics)')}")
##        except Exception:
##            try:
##                ev = {"id": uuid.uuid4().hex, "title": title_candidate, "dtstart": final_dt.isoformat(), "duration_minutes": 60, "reminder_minutes": 15, "description": "Created by Alfred", "ics_path": None, "notified": False}
##                ics = _write_ics_file(ev)
##                if ics: ev['ics_path'] = ics
##                organizer_events.append(ev); _save_organizer_events()
##                _speak(f"Created calendar file for {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}.")
##            except Exception:
##                _speak("Failed to create calendar reminder.")
##        return
##
##    # READ schedule / list reminders
##    if any(k in lower for k in ("what is my schedule", "what do i have", "what are my reminders", "what are my meetings", "what do i have scheduled", "what can you remember", "what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### ---------- notifier ----------
##_NOTIFIER_THREAD = None
##def _notifier_loop(poll_seconds: int = 30):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    if ev.get("notified", False):
##                        continue
##                    dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##                    remind_before = int(ev.get("reminder_minutes", 15))
##                    notify_time = dtstart - dt.timedelta(minutes=remind_before)
##                    if now >= notify_time:
##                        _speak(f"Reminder: {ev.get('title','an event')} scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}")
##                        ev['notified'] = True
##                        changed = True
##                except Exception:
##                    continue
##            if changed: _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread():
##    global _NOTIFIER_THREAD
##    if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive(): return
##    _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds":30}, daemon=True)
##    _NOTIFIER_THREAD.start()
##
### demo if run directly
##if __name__ == "__main__":
##    print("Reminder module demo. Type a test phrase or 'quit'.")
##    start_reminder_notifier_thread()
##    while True:
##        q = input("You: ").strip()
##        if not q or q.lower() in ("quit","exit"): break
##        handle_voice_command(q)













### reminders_module.py
##from __future__ import annotations
##import re
##import os
##import json
##import base64
##import ast
##import uuid
##import time
##import threading
##from typing import List, Optional, Tuple
##import datetime as dt
##
### small helpers
##def safe_str(val) -> str:
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    try:
##        return str(val)
##    except Exception:
##        return ""
##
### ---------- safe speech/listen wrappers ----------
##def _speak(text: str):
##    try:
##        if 'speech' in globals() and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if 'listen' in globals() and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 12) -> str:
##    """
##    Try to get one short response. Uses listen.listen() if available.
##    """
##    try:
##        if 'listen' in globals() and hasattr(listen, "listen"):
##            return safe_str(listen.listen())
##    except Exception:
##        pass
##    return ""
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    """
##    Convert 'two thousand and twenty six' -> 2026, 'twenty six' -> 26.
##    Returns None if phrase contains unknown token.
##    """
##    if phrase is None:
##        return None
##    if isinstance(phrase, (dt.date, dt.datetime)):
##        return None
##    if not isinstance(phrase, str):
##        phrase = str(phrase)
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words:
##        return None
##    total = 0
##    current = 0
##    valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0:
##                current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current
##                current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    """Greedy parse numeric phrases from token list (words already tokenized)."""
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            # try single token numeric literal
##            token = words[i]
##            if re.fullmatch(r"\d+", token):
##                nums.append(int(token)); i += 1
##            else:
##                i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    """
##    Returns: message, speaker, score, gender, gender_conf
##    Accepts dicts, strings, or serialized dicts.
##    """
##    if query is None:
##        return "", None, None, None, None
##
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return safe_str(text_), (safe_str(speaker_) if speaker_ is not None else None), score_f, (safe_str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        # try base64 decode
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##
##        # heuristics fallback
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = safe_str(m_text.group("t")) if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = safe_str(m_speaker.group("s")) if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = safe_str(m_gender.group("g")) if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, (speaker_val if speaker_val else None), score_val, (gender_val if gender_val else None), gender_conf_val
##
##    # fallback for other types
##    return safe_str(query), None, None, None, None
##
### ---------- date parsing helpers ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##
##def spoken_date_to_ymd(spoken) -> Optional[Tuple[int, Optional[int], Optional[int]]]:
##    """Try to extract (year, month, day) from spoken tokens or numeric sequences."""
##    if spoken is None:
##        return None
##    if isinstance(spoken, (dt.datetime, dt.date)):
##        d = spoken.date() if isinstance(spoken, dt.datetime) else spoken
##        return (d.year, d.month, d.day)
##    s = safe_str(spoken).lower().replace("-", " ").replace("/", " ").replace(",", " ")
##    s = re.sub(r"\b(st|nd|rd|th)\b", "", s)
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    if not tokens:
##        return None
##
##    # try whole year phrase (e.g., "two thousand twenty six")
##    whole = words_to_number(" ".join(tokens))
##    if whole is not None and whole >= 1000:
##        return (whole, None, None)
##
##    nums = greedy_parse_numbers_from_words(tokens, max_window=3)
##    if not nums:
##        return None
##
##    # common pattern: year-month-day
##    if len(nums) >= 3:
##        # if first is a full year
##        if nums[0] >= 1000:
##            year = nums[0]; month = nums[1] if len(nums) > 1 else None; day = nums[2] if len(nums) > 2 else None
##            if (month is None) or (1 <= month <= 12):
##                return (year, month, day)
##        # if first two form two-digit year like '20 26 01 01' -> treat as 2026 01 01
##        # attempt compact two-digit join
##        padded = []
##        for v in nums:
##            if 0 <= v < 100:
##                padded.append(f"{v:02d}")
##            else:
##                padded.append(str(v))
##        # slide window of 4 two-digit tokens -> 'YYYYMMDD'
##        for i in range(0, max(0, len(padded) - 3)):
##            chunk = "".join(padded[i:i+4])
##            if len(chunk) == 8:
##                try:
##                    y = int(chunk[:4]); mo = int(chunk[4:6]); da = int(chunk[6:8])
##                    if 1900 <= y <= 3000 and 1 <= mo <= 12 and 1 <= da <= 31:
##                        return (y, mo, da)
##                except Exception:
##                    pass
##
##    # two-digit year + month/day
##    if len(nums) >= 2 and nums[0] < 100 and nums[1] <= 12:
##        year = 2000 + (nums[0] % 100)
##        month = nums[1]
##        day = nums[2] if len(nums) > 2 else None
##        return (year, month, day)
##
##    # fallback: single small number -> treat as year (20 -> 2020-ish)
##    if len(nums) == 1 and 0 <= nums[0] < 100:
##        return (2000 + nums[0], None, None)
##
##    return None
##
### ---------- natural time parsing ----------
##_WEEKDAYS = {
##    "monday": 0, "tuesday": 1, "wednesday": 2,
##    "thursday": 3, "friday": 4, "saturday": 5, "sunday": 6
##}
##
##def parse_natural_time(text: str, now: Optional[dt.datetime] = None) -> Optional[dt.datetime]:
##    """
##    Convert phrases like:
##      - "in 3 hours"
##      - "in two days at 6 pm"
##      - "half past six"
##      - "six thirty pm"
##      - "13:00"
##      - "tomorrow at nine"
##    Returns a datetime or None (naive local).
##    """
##    if text is None:
##        return None
##    if isinstance(text, dt.datetime):
##        return text
##    if isinstance(text, dt.date) and not isinstance(text, dt.datetime):
##        return dt.datetime.combine(text, dt.time(9,0))
##    now = now or dt.datetime.now()
##    s = safe_str(text).lower().strip()
##
##    # Relative: "in N hours" / "after N days" etc.
##    m_rel = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s)
##    if m_rel:
##        num_phrase = m_rel.group(2).strip()
##        unit = m_rel.group(3)
##        num = None
##        try:
##            num = int(num_phrase)
##        except Exception:
##            num = words_to_number(num_phrase)
##        if num is None:
##            return None
##        unit = unit.rstrip("s")
##        if unit == "second":
##            return now + dt.timedelta(seconds=num)
##        if unit == "minute":
##            return now + dt.timedelta(minutes=num)
##        if unit == "hour":
##            return now + dt.timedelta(hours=num)
##        if unit == "day":
##            return now + dt.timedelta(days=num)
##        if unit == "week":
##            return now + dt.timedelta(weeks=num)
##
##    # Relative with 'in N days at <time>'
##    m_rel2 = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(days?)\b\s*(?:at\s+(.+))?", s)
##    if m_rel2:
##        num_phrase = m_rel2.group(2).strip()
##        try:
##            num = int(num_phrase)
##        except Exception:
##            num = words_to_number(num_phrase)
##        if num is None:
##            return None
##        base = now + dt.timedelta(days=int(num))
##        at = m_rel2.group(4)
##        if at:
##            hm = spoken_time_to_hm(at)
##            if hm:
##                return dt.datetime.combine(base.date(), dt.time(hm[0], hm[1]))
##        return base
##
##    # Today/tomorrow simple
##    if "tomorrow" in s:
##        base = now + dt.timedelta(days=1)
##        hm = spoken_time_to_hm(s)
##        if hm:
##            return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base.replace(hour=9, minute=0, second=0, microsecond=0)
##    if "today" in s:
##        base = now
##        hm = spoken_time_to_hm(s)
##        if hm:
##            return base.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        return base
##
##    # Weekdays
##    for wd, idx in _WEEKDAYS.items():
##        if re.search(rf"\b{wd}\b", s):
##            days_ahead = (idx - now.weekday()) % 7
##            if days_ahead == 0:
##                days_ahead = 7
##            target = now + dt.timedelta(days=days_ahead)
##            hm = spoken_time_to_hm(s)
##            if hm:
##                return target.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##            return target.replace(hour=9, minute=0, second=0, microsecond=0)
##
##    # Pure time only (e.g., "six pm", "18:30", "half past six")
##    hm = spoken_time_to_hm(s)
##    if hm:
##        candidate = now.replace(hour=hm[0], minute=hm[1], second=0, microsecond=0)
##        if candidate < now:
##            candidate += dt.timedelta(days=1)
##        return candidate
##
##    return None
##
### ---------- natural date parser ----------
##def parse_natural_date(text: str) -> Optional[str]:
##    """
##    Return ISO date string 'YYYY-MM-DD' for many natural phrases.
##    """
##    if text is None:
##        return None
##    if isinstance(text, (dt.datetime, dt.date)):
##        d = text.date() if isinstance(text, dt.datetime) else text
##        return d.isoformat()
##    s = safe_str(text).lower()
##    # ISO direct
##    m = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    if m:
##        return m.group(1)
##    m = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m:
##        try:
##            d = dt.datetime.strptime(m.group(1), "%d/%m/%Y").date()
##            return d.isoformat()
##        except Exception:
##            pass
##
##    today = dt.date.today()
##    if re.search(r"\btoday\b", s):
##        return today.isoformat()
##    if re.search(r"\btomorrow\b", s):
##        return (today + dt.timedelta(days=1)).isoformat()
##    if re.search(r"\b(day after tomorrow|in two days)\b", s):
##        return (today + dt.timedelta(days=2)).isoformat()
##
##    # explicit 'this monday' / 'next monday' / weekday heuristics
##    for wd, idx in _WEEKDAY_MAP.items():
##        if re.search(rf"\bthis\s+{wd}\b", s):
##            td = today.weekday(); days_ahead = (idx - td) % 7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\bnext\s+{wd}\b", s) or re.search(rf"\b{wd}\s+next\s+week\b", s):
##            td = today.weekday(); days_ahead = ((idx - td) % 7) + 7; return (today + dt.timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\b{wd}\b", s) and not re.search(r"\bthis\b", s) and not re.search(r"\bnext\b", s):
##            td = today.weekday(); days_ahead = (idx - td) % 7
##            if days_ahead == 0: days_ahead = 7
##            return (today + dt.timedelta(days=days_ahead)).isoformat()
##
##    # try spoken_date_to_ymd
##    try:
##        ymd = spoken_date_to_ymd(text)
##        if ymd:
##            y, m, d = ymd
##            if y and m and d:
##                return f"{y:04d}-{m:02d}-{d:02d}"
##            if y:
##                return f"{y:04d}-01-01"
##    except Exception:
##        pass
##
##    # fallback: attempt to parse compact numeric sequences like "20 26 01 01" -> 2026-01-01
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=2)
##    if nums:
##        # build padded two-digit strings
##        padded = []
##        for v in nums:
##            if 0 <= v < 100:
##                padded.append(f"{v:02d}")
##            else:
##                padded.append(str(v))
##        for i in range(0, max(0, len(padded) - 3)):
##            chunk = "".join(padded[i:i+4])
##            if len(chunk) == 8:
##                try:
##                    y = int(chunk[:4]); mo = int(chunk[4:6]); da = int(chunk[6:8])
##                    if 1900 <= y <= 3000 and 1 <= mo <= 12 and 1 <= da <= 31:
##                        return f"{y:04d}-{mo:02d}-{da:02d}"
##                except Exception:
##                    pass
##
##    return None
##
### ---------- relative time parsing ----------
##def parse_relative_datetime(text) -> Optional[dt.datetime]:
##    if text is None:
##        return None
##    if isinstance(text, dt.datetime):
##        return text
##    if isinstance(text, dt.date):
##        return dt.datetime.combine(text, dt.time(9,0))
##    s = safe_str(text).lower()
##    # "in 3 hours" etc. delegate to parse_natural_time which already handles many cases
##    return parse_natural_time(s)
##
### ---------- time parsing helpers ----------
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = safe_str(token).lower()
##    if not token:
##        return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = safe_str(s).lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="am"; break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="pm"; break
##    if ampm:
##        s0 = re.sub(r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening)\b", " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken) -> Optional[Tuple[int,int]]:
##    if spoken is None:
##        return None
##    if isinstance(spoken, dt.datetime):
##        return (spoken.hour, spoken.minute)
##    if isinstance(spoken, dt.time):
##        return (spoken.hour, spoken.minute)
##    s = safe_str(spoken).lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    s = re.sub(r"\b(o'clock)\b", "", s); s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    # half past X
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24; minute = 30
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    # quarter past/to
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h) % 24
##        if typ == "past":
##            minute = 15
##        else:
##            minute = 45
##            hour = (hour - 1) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##
##    # cluster like 0630 or 1830
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster) == 3:
##                h = int(cluster[0]); m = int(cluster[1:])
##            else:
##                h = int(cluster[:2]); m = int(cluster[2:])
##            if 0 <= h < 24 and 0 <= m < 60:
##                if ampm == "pm" and h < 12: h += 12
##                if ampm == "am" and h == 12: h = 0
##                return (h, m)
##        except Exception:
##            pass
##
##    # token-by-token numbers: "six thirty", "eighteen thirty"
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None:
##            num_list.append(v)
##    if len(num_list) >= 2:
##        hour = int(num_list[0]) % 24; minute = int(num_list[1]) % 60
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, minute)
##    if len(num_list) == 1:
##        hour = int(num_list[0]) % 24
##        if ampm == "pm" and hour < 12: hour += 12
##        if ampm == "am" and hour == 12: hour = 0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm:
##        return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events = []
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + dt.timedelta(minutes=ev.get('duration_minutes', 60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR", "PRODID:-//AlfredOrganizer//EN", "VERSION:2.0", "CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT", f"UID:{uid}", f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}", f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}", f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT", "END:VCALENDAR", ""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e)
##        return None
##
##def add_organizer_event(title: str, date_text: str, time_text: str = "09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        # date_text expected as ISO 'YYYY-MM-DD' or dt.date
##        if isinstance(date_text, str):
##            ymd = dt.date.fromisoformat(date_text)
##        elif isinstance(date_text, dt.date):
##            ymd = date_text
##        else:
##            raise ValueError("Invalid date_text")
##        hh, mm = 9, 0
##        try:
##            if isinstance(time_text, str) and ":" in time_text:
##                hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##            elif isinstance(time_text, dt.time):
##                hh = time_text.hour; mm = time_text.minute
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev = {"id": uuid.uuid4().hex, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        ics = _write_ics_file(ev)
##        if ics:
##            ev['ics_path'] = ics
##        organizer_events.append(ev)
##        _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e)
##        raise
##
##_load_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines:
##        return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines:
##                f.write(safe_str(ln).rstrip() + "\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path):
##            return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e)
##        return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = safe_str(text)
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- confirmation helper ----------
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12) -> bool:
##    _speak(confirm_text)
##    _send_bluetooth(confirm_text)
##    resp = _listen_once(timeout=timeout)
##    if not resp:
##        return False
##    low = resp.lower()
##    if any(w in low for w in ("yes", "yep", "yeah", "confirm", "do it", "sure", "please")):
##        return True
##    return False
##
### ---------- main handler (with relative times + confirmation) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = safe_str(AlfredQueryOffline)
##    if not text_in:
##        return
##    lower = text_in.lower()
##
##    # CREATION / SET / QUICK REMINDERS / SCHEDULE QUERY
##    if any(k in lower for k in ("remind me", "create a reminder", "create me a reminder", "set a reminder", "set reminder", "i want to remember", "can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_in)
##        except Exception:
##            msg_text = text_in
##
##        # Defensive normalization for msg_text (string or datetime)
##        if isinstance(msg_text, (dt.datetime, dt.date)):
##            msg_text = msg_text.isoformat()
##        msg_text = safe_str(msg_text)
##
##        # 1) Try relative datetime first
##        parsed_dt = None
##        parsed_dt = parse_relative_datetime(msg_text)
##        date_value = None; time_value = None
##        if parsed_dt:
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            # try natural parsers
##            date_value = parse_natural_date(msg_text)
##            dt_candidate = parse_natural_time(msg_text)
##            if dt_candidate:
##                # if parse_natural_time returns a full datetime (with date) use it
##                if isinstance(dt_candidate, dt.datetime) and dt_candidate.date() != dt.datetime.now().date():
##                    parsed_dt = dt_candidate
##                    date_value = parsed_dt.date().isoformat()
##                    time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    # parse_natural_time might return a time-of-day (datetime candidate)
##                    time_value = dt_candidate.strftime("%H:%M")
##
##            # fallback: spoken_time helper to get HH:MM
##            if time_value is None:
##                tstr = spoken_time_to_str(msg_text)
##                if tstr:
##                    time_value = tstr
##
##        title_candidate = extract_title_from_text(msg_text)
##
##        # Ask for date if missing
##        if not date_value and parsed_dt is None:
##            _speak("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date.")
##            _send_bluetooth("On which date should I set this reminder?")
##            resp = _listen_once()
##            if resp:
##                dv = parse_natural_date(resp)
##                if dv:
##                    date_value = dv
##                else:
##                    ymd = spoken_date_to_ymd(resp)
##                    if ymd and ymd[0] and ymd[1] and ymd[2]:
##                        date_value = f"{ymd[0]:04d}-{ymd[1]:02d}-{ymd[2]:02d}"
##
##        # Ask for time if missing
##        if not time_value and parsed_dt is None:
##            _speak("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.")
##            _send_bluetooth("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.")
##            resp = _listen_once()
##            if resp:
##                rv = parse_relative_datetime(resp)
##                if rv:
##                    parsed_dt = rv; date_value = parsed_dt.date().isoformat(); time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    tv = parse_natural_time(resp)
##                    if tv:
##                        # parse_natural_time returns datetime  use its time & date if provided
##                        if isinstance(tv, dt.datetime):
##                            date_value = tv.date().isoformat()
##                            time_value = tv.time().strftime("%H:%M")
##                        else:
##                            time_value = tv.strftime("%H:%M")
##                    else:
##                        tstr = spoken_time_to_str(resp)
##                        if tstr:
##                            time_value = tstr
##
##        # If still no date/time -> save as quick reminder (free text)
##        if not date_value and parsed_dt is None and not time_value:
##            _append_lines_to_file([title_candidate])
##            _speak(f"Saved quick reminder: {title_candidate}")
##            return
##
##        # Build final datetime
##        if parsed_dt:
##            final_dt = parsed_dt
##        else:
##            if not date_value:
##                date_value = dt.date.today().isoformat()
##            if not time_value:
##                time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                try:
##                    parsed_date = dt.datetime.strptime(date_value, "%Y-%m-%d").date()
##                except Exception:
##                    parsed_date = None
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0], hm[1]) if hm else dt.time(9, 0)
##            if parsed_date is None:
##                _append_lines_to_file([f"{title_candidate} (date unknown: {msg_text})"])
##                _speak("I saved the reminder text but could not determine the date. Ask me again with a clearer date and I will schedule it.")
##                return
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##
##        # Confirmation
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Create event
##        try:
##            event = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {event.get('ics_path','(no ics)')}")
##        except Exception:
##            try:
##                ev = {"id": uuid.uuid4().hex, "title": title_candidate, "dtstart": final_dt.isoformat(), "duration_minutes": 60, "reminder_minutes": 15, "description": "Created by Alfred", "ics_path": None, "notified": False}
##                ics = _write_ics_file(ev)
##                if ics: ev['ics_path'] = ics
##                organizer_events.append(ev); _save_organizer_events()
##                _speak(f"Created calendar file for {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}.")
##            except Exception:
##                _speak("Failed to create calendar reminder.")
##        return
##
##    # READ schedule / list reminders
##    if any(k in lower for k in ("what is my schedule", "what do i have", "what are my reminders", "what are my meetings", "what do i have scheduled", "what can you remember", "what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### ---------- Background notifier thread ----------
##_NOTIFIER_THREAD = None
##def _notifier_loop(poll_seconds: int = 30):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    if ev.get("notified", False):
##                        continue
##                    dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##                    remind_before = int(ev.get("reminder_minutes", 15))
##                    notify_time = dtstart - dt.timedelta(minutes=remind_before)
##                    if now >= notify_time:
##                        _speak(f"Reminder: {ev.get('title','an event')} scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}")
##                        ev['notified'] = True
##                        changed = True
##                except Exception:
##                    continue
##            if changed:
##                _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread():
##    global _NOTIFIER_THREAD
##    if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##        return
##    _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds":30}, daemon=True)
##    _NOTIFIER_THREAD.start()
##
### ---------- module demo when run directly ----------
##if __name__ == "__main__":
##    print("Reminder module demo. Type a test phrase or 'quit'.")
##    start_reminder_notifier_thread()
##    while True:
##        q = input("You: ").strip()
##        if not q or q.lower() in ("quit", "exit"):
##            break
##        handle_voice_command(q)
##



































### reminders_module.py
##from __future__ import annotations
##import re, os, json, base64, ast, uuid, time, threading
##from typing import List, Optional, Tuple
##import datetime as dt
##from datetime import timedelta
##
##
##
##
##
##
##def safe_str(val):
##    if val is None:
##        return ""
##    if isinstance(val, str):
##        return val.strip()
##    return str(val)
##
##
##
### ---------- safe speech/listen wrappers ----------
##def _speak(text: str):
##    try:
##        if 'speech' in globals() and hasattr(speech, "AlfredSpeak"):
##            speech.AlfredSpeak(str(text))
##            return
##    except Exception:
##        pass
##    print("[ALFRED SPEAK]", text)
##
##def _send_bluetooth(text: str):
##    try:
##        if 'listen' in globals() and hasattr(listen, "send_bluetooth"):
##            listen.send_bluetooth(str(text))
##    except Exception:
##        pass
##
##def _listen_once(timeout: int = 12) -> str:
##    """
##    Try to get one short response. Uses listen.listen() if available.
##    If your listen implementation blocks longer than `timeout`, you may want to adapt.
##    """
##    try:
##        if 'listen' in globals() and hasattr(listen, "listen"):
##            return str(listen.listen() or "").strip()
##    except Exception:
##        pass
##    return ""
##
### ---------- words -> numbers ----------
##_UNITS = {
##    "zero":0,"oh":0,"o":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,
##    "ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,
##    "seventeen":17,"eighteen":18,"nineteen":19
##}
##_TENS = {"twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90}
##_SCALES = {"hundred":100,"thousand":1000,"million":1_000_000}
##
##def words_to_number(phrase: str) -> Optional[int]:
##    if not phrase or not isinstance(phrase, str):
##        return None
##    words = re.findall(r"[a-z]+", phrase.lower())
##    if not words:
##        return None
##    total = 0
##    current = 0
##    valid = False
##    for w in words:
##        if w in _UNITS:
##            current += _UNITS[w]; valid = True
##        elif w in _TENS:
##            current += _TENS[w]; valid = True
##        elif w in _SCALES:
##            scale = _SCALES[w]
##            if current == 0:
##                current = 1
##            current *= scale
##            if scale >= 1000:
##                total += current
##                current = 0
##            valid = True
##        elif w == "and":
##            continue
##        else:
##            return None
##    return (total + current) if valid else None
##
##def greedy_parse_numbers_from_words(words: List[str], max_window: int = 3) -> List[int]:
##    i = 0; n = len(words); nums: List[int] = []
##    while i < n:
##        parsed = None; parsed_len = 0
##        for window in range(max_window, 0, -1):
##            if i + window > n: continue
##            phrase = " ".join(words[i:i+window])
##            val = words_to_number(phrase)
##            if val is not None:
##                parsed = val; parsed_len = window; break
##        if parsed is not None:
##            nums.append(parsed); i += parsed_len
##        else:
##            i += 1
##    return nums
##
### ---------- extractor that accepts dicts & stringified dicts ----------
##def extract_text_from_query(query) -> Tuple[str, Optional[str], Optional[float], Optional[str], Optional[float]]:
##    if query is None:
##        return "", None, None, None, None
##    if isinstance(query, dict):
##        text_ = query.get("text") or query.get("query") or query.get("message") or query.get("q") or ""
##        speaker_ = query.get("username") or query.get("speaker") or query.get("user")
##        score_ = query.get("score")
##        gender_ = query.get("gender")
##        gender_conf_ = query.get("gender_conf")
##        if isinstance(speaker_, str):
##            s = re.sub(r"\s+(home|office|work|phone)$", "", speaker_.strip(), flags=re.I)
##            if s.lower().startswith("none "): s = s[5:].strip()
##            speaker_ = None if s.lower() == "none" else s
##        try: score_f = float(score_) if score_ is not None else None
##        except: score_f = None
##        try: gconf_f = float(gender_conf_) if gender_conf_ is not None else None
##        except: gconf_f = None
##        return str(text_).strip(), (str(speaker_).strip() if speaker_ is not None else None), score_f, (str(gender_) if gender_ is not None else None), gconf_f
##
##    if isinstance(query, str):
##        s = query.strip()
##        # try base64 decode
##        try:
##            if len(s) > 50 and re.fullmatch(r'[A-Za-z0-9+/=\s]+', s) and '\n' not in s:
##                try:
##                    decoded = base64.b64decode(s).decode('utf-8')
##                    if decoded: s = decoded.strip()
##                except Exception:
##                    pass
##        except Exception:
##            pass
##        looks_like_dict = s.startswith("{") and ("'text'" in s or '"text"' in s or "'speaker'" in s or '"speaker"' in s)
##        if looks_like_dict:
##            try:
##                parsed = ast.literal_eval(s)
##                if isinstance(parsed, dict):
##                    return extract_text_from_query(parsed)
##            except Exception:
##                try:
##                    parsed = json.loads(s)
##                    if isinstance(parsed, dict):
##                        return extract_text_from_query(parsed)
##                except Exception:
##                    pass
##        # heuristics fallback
##        m_text = re.search(r"(?:'text'|\"text\"|text)\s*[:=]\s*['\"](?P<t>.*?)['\"]", s)
##        text_val = m_text.group("t").strip() if m_text else s
##        m_speaker = re.search(r"(?:'speaker'|\"speaker\"|username|user)\s*[:=]\s*['\"]?(?P<s>[^'\"\n,}]+)['\"]?", s)
##        speaker_val = m_speaker.group("s").strip() if m_speaker else None
##        if speaker_val:
##            speaker_val = re.sub(r"\s+(home|office|work|phone)$", "", speaker_val, flags=re.I)
##            if speaker_val.lower().startswith("none "): speaker_val = speaker_val[5:].strip()
##            if speaker_val.lower() == "none": speaker_val = None
##        m_score = re.search(r"'score'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"score"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        score_val = float(m_score.group(1)) if m_score else None
##        m_gender = re.search(r"'gender'\s*[:=]\s*['\"]?(?P<g>[^'\"\n,}]+)['\"]?", s) or re.search(r'"gender"\s*[:=]\s*["]?(?P<g>[^"]+)["]?', s)
##        gender_val = m_gender.group("g").strip() if m_gender else None
##        m_gconf = re.search(r"'gender_conf'\s*[:=]\s*([0-9]*\.?[0-9]+)", s) or re.search(r'"gender_conf"\s*[:=]\s*([0-9]*\.?[0-9]+)', s)
##        gender_conf_val = float(m_gconf.group(1)) if m_gconf else None
##        return text_val, speaker_val, score_val, gender_val, gender_conf_val
##
##    return str(query).strip(), None, None, None, None
##
### ---------- date parsing ----------
##_WEEKDAY_MAP = {"monday":0,"tuesday":1,"wednesday":2,"thursday":3,"friday":4,"saturday":5,"sunday":6}
##
##def spoken_date_to_ymd(spoken: str) -> Optional[Tuple[int, Optional[int], Optional[int]]]:
##    if not spoken: return None
##    s = spoken.lower().replace("-", " ").replace("/", " ").replace(",", " ")
##    s = re.sub(r"\b(st|nd|rd|th)\b", "", s)
##    tokens = re.findall(r"[a-z]+|\d+", s)
##    whole = words_to_number(" ".join(tokens))
##    if whole is not None and whole >= 1000:
##        return (whole, None, None)
##    nums = greedy_parse_numbers_from_words(tokens, max_window=3)
##    if not nums: return None
##    for i,x in enumerate(nums):
##        if 1000 <= x <= 9999:
##            year=x; month = nums[i+1] if i+1<len(nums) else None; day = nums[i+2] if i+2<len(nums) else None
##            if month is not None and not (1<=month<=12): month=None
##            if day is not None and not (1<=day<=31): day=None
##            return (year, month, day)
##    if len(nums)>=2 and nums[0]<100 and nums[1]<100:
##        yc = nums[0]*100 + (nums[1]%100)
##        if 1900<=yc<=2100:
##            year=yc; month= nums[2] if len(nums)>2 else None; day = nums[3] if len(nums)>3 else None
##            if month and not (1<=month<=12): month=None
##            if day and not (1<=day<=31): day=None
##            return (year, month, day)
##    if len(nums)>=3:
##        a,b,c = nums[0],nums[1],nums[2]
##        if a<100 and 1<=b<=12 and 1<=c<=31:
##            y=2000+(a%100); return (y,b,c)
##        if a>=1000:
##            return (a, b if 1<=b<=12 else None, c if 1<=c<=31 else None)
##    if len(nums)==1 and 0<=nums[0]<100:
##        return (2000+nums[0], None, None)
##    return None
##
##from datetime import datetime, timedelta
##import re
##
##_WEEKDAYS = {
##    "monday": 0, "tuesday": 1, "wednesday": 2,
##    "thursday": 3, "friday": 4, "saturday": 5, "sunday": 6
##}
##
##def parse_natural_time(text: str, now: datetime | None = None):
##    """
##    Parse natural language date/time expressions into a datetime.
##    Returns datetime or None.
##    """
##    if not text:
##        return None
##
##    if now is None:
##        now = datetime.now()
##
##    s = text.lower().strip()
##
##    # ---------------- RELATIVE TIMES ----------------
##    # "in 3 hours", "in two days at 6 pm"
##    m = re.search(r"in ([a-z0-9 ]+)", s)
##    if m:
##        chunk = m.group(1)
##
##        tokens = re.findall(r"[a-z]+|\d+", chunk)
##        amount = None
##        unit = None
##
##        for i, t in enumerate(tokens):
##            n = words_to_number(t) if t.isalpha() else int(t) if t.isdigit() else None
##            if n is not None and i + 1 < len(tokens):
##                amount = n
##                unit = tokens[i + 1]
##                break
##
##        if amount and unit:
##            dt = now
##            if unit.startswith("hour"):
##                dt += timedelta(hours=amount)
##            elif unit.startswith("day"):
##                dt += timedelta(days=amount)
##            elif unit.startswith("week"):
##                dt += timedelta(weeks=amount)
##
##            # optional "at <time>"
##            hm = spoken_time_to_hm(s)
##            if hm:
##                h, m = hm
##                dt = dt.replace(hour=h, minute=m, second=0, microsecond=0)
##
##            return dt
##
##    # ---------------- TODAY / TOMORROW ----------------
##    if "tomorrow" in s:
##        base = now + timedelta(days=1)
##    elif "today" in s:
##        base = now
##    else:
##        base = None
##
##    if base:
##        hm = spoken_time_to_hm(s)
##        if hm:
##            h, m = hm
##        else:
##            h, m = 9, 0  # default time
##        return base.replace(hour=h, minute=m, second=0, microsecond=0)
##
##    # ---------------- WEEKDAYS ----------------
##    for wd, idx in _WEEKDAYS.items():
##        if wd in s:
##            days_ahead = (idx - now.weekday()) % 7
##            if days_ahead == 0:
##                days_ahead = 7
##            target = now + timedelta(days=days_ahead)
##
##            hm = spoken_time_to_hm(s)
##            if hm:
##                h, m = hm
##            else:
##                h, m = 9, 0
##
##            return target.replace(hour=h, minute=m, second=0, microsecond=0)
##
##    # ---------------- PURE TIME ONLY ----------------
##    hm = spoken_time_to_hm(s)
##    if hm:
##        h, m = hm
##        candidate = now.replace(hour=h, minute=m, second=0, microsecond=0)
##        if candidate < now:
##            candidate += timedelta(days=1)
##        return candidate
##
##    return None
##
##
##def parse_natural_date(text: str) -> Optional[str]:
##    if not text: return None
##    s = text.lower()
##    m = re.search(r"(\d{4}-\d{2}-\d{2})", s)
##    if m: return m.group(1)
##    m = re.search(r"(\d{1,2}/\d{1,2}/\d{4})", s)
##    if m:
##        try: d = dt.datetime.strptime(m.group(1), "%d/%m/%Y").date(); return d.isoformat()
##        except: pass
##    today = dt.date.today()
##    if re.search(r"\btoday\b", s): return today.isoformat()
##    if re.search(r"\btomorrow\b", s): return (today+timedelta(days=1)).isoformat()
##    if re.search(r"\b(day after tomorrow|in two days)\b", s): return (today+timedelta(days=2)).isoformat()
##    for wd, idx in _WEEKDAY_MAP.items():
##        if re.search(rf"\bthis\s+{wd}\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7; return (today+timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\bnext\s+{wd}\b", s) or re.search(rf"\b{wd}\s+next\s+week\b", s):
##            td = today.weekday(); days_ahead = ((idx-td)%7)+7; return (today+timedelta(days=days_ahead)).isoformat()
##        if re.search(rf"\b{wd}\b", s) and not re.search(r"\bthis\b", s) and not re.search(r"\bnext\b", s):
##            td = today.weekday(); days_ahead = (idx-td)%7
##            if days_ahead == 0: days_ahead = 7
##            return (today+timedelta(days=days_ahead)).isoformat()
##    try:
##        ymd = spoken_date_to_ymd(text)
##        if ymd:
##            y,m,d = ymd
##            if y and m and d: return f"{y:04d}-{m:02d}-{d:02d}"
##            if y: return f"{y:04d}-01-01"
##    except: pass
##    return None
##
### ---------- relative time parsing ----------
##def parse_relative_datetime(text: str) -> Optional[dt.datetime]:
##    """
##    Recognize 'in N hours', 'in N days at 6 pm', 'after 3 hours', etc.
##    Returns a concrete datetime (naive local).
##    """
##    if not text: return None
##    s = text.lower()
##    # capture "in X (seconds|minutes|hours|days|weeks)"
##    m = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(seconds?|minutes?|hours?|days?|weeks?)\b", s)
##    if m:
##        num_phrase = m.group(2).strip()
##        unit = m.group(3)
##        # try number from words or digits
##        num = None
##        try:
##            num = int(num_phrase)
##        except Exception:
##            num = words_to_number(num_phrase)
##        if num is None:
##            return None
##        now = dt.datetime.now()
##        unit = unit.rstrip("s")
##        if unit == "second": return now + timedelta(seconds=num)
##        if unit == "minute": return now + timedelta(minutes=num)
##        if unit == "hour": return now + timedelta(hours=num)
##        if unit == "day": return now + timedelta(days=num)
##        if unit == "week": return now + timedelta(weeks=num)
##    # "in N days at ..." pattern
##    m2 = re.search(r"\b(in|after)\s+([a-z0-9\s-]+?)\s+(days?)\b\s*(?:at\s+(.+))?", s)
##    if m2:
##        num_phrase = m2.group(2).strip()
##        num = None
##        try: num = int(num_phrase)
##        except: num = words_to_number(num_phrase)
##        if num is None: return None
##        date = dt.datetime.now() + timedelta(days=int(num))
##        # if 'at X' present parse time
##        at = m2.group(4)
##        if at:
##            t = spoken_time_to_hm(at)
##            if t:
##                return dt.datetime.combine(date.date(), dt.time(t[0], t[1]))
##        return date
##    return None
##
### ---------- time parsing ----------
##_AM_WORDS = {"am","a.m.","a.m","morning","in the morning"}
##_PM_WORDS = {"pm","p.m.","p.m","pm.","evening","afternoon","night","in the evening"}
##
##def _token_to_number(token: str) -> Optional[int]:
##    token = token.strip().lower()
##    if not token: return None
##    if re.fullmatch(r"\d+", token):
##        try: return int(token)
##        except: return None
##    if token in _UNITS: return _UNITS[token]
##    if token in _TENS: return _TENS[token]
##    if "-" in token:
##        parts = token.split("-"); vals = [_token_to_number(p) for p in parts]
##        if all(v is not None for v in vals): return sum(vals)
##    return words_to_number(token)
##
##def _detect_ampm_and_remove(s: str) -> Tuple[str, Optional[str]]:
##    s0 = s.lower()
##    ampm = None
##    for w in _AM_WORDS:
##        if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="am"; break
##    if ampm is None:
##        for w in _PM_WORDS:
##            if re.search(r"\b"+re.escape(w)+r"\b", s0): ampm="pm"; break
##    if ampm:
##        s0 = re.sub(r"\b(a\.?m\.?|p\.?m\.?|am|pm|morning|afternoon|evening|night|in the morning|in the evening)\b", " ", s0)
##        s0 = re.sub(r"\s+", " ", s0).strip()
##    return s0, ampm
##
##def spoken_time_to_hm(spoken: str) -> Optional[Tuple[int,int]]:
##    if not spoken: return None
##    s = spoken.strip().lower().replace("-", " ").replace(".", " ").replace(",", " ")
##    s = re.sub(r"\b(o'clock)\b", "", s); s = re.sub(r"\s+", " ", s).strip()
##    s_no_ampm, ampm = _detect_ampm_and_remove(s)
##    m = re.search(r"\bhalf past ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        hour_token = m.group(1).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24; minute=30
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    m = re.search(r"\bquarter (past|to) ([a-z0-9 ]+)$", s_no_ampm)
##    if m:
##        typ = m.group(1); hour_token = m.group(2).strip(); h = _token_to_number(hour_token)
##        if h is None: return None
##        hour = int(h)%24
##        if typ=="past": minute=15
##        else: minute=45; hour=(hour-1)%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    digits_cluster = re.search(r"\b(\d{3,4})\b", s_no_ampm)
##    if digits_cluster:
##        cluster = digits_cluster.group(1)
##        try:
##            if len(cluster)==3: h=int(cluster[0]); m=int(cluster[1:])
##            else: h=int(cluster[:2]); m=int(cluster[2:])
##            if 0<=h<24 and 0<=m<60:
##                if ampm=="pm" and h<12: h+=12
##                if ampm=="am" and h==12: h=0
##                return (h,m)
##        except: pass
##    tokens = re.findall(r"[a-z]+|\d+", s_no_ampm.lower())
##    num_list: List[int] = []
##    for t in tokens:
##        v = _token_to_number(t)
##        if v is not None: num_list.append(v)
##    if len(num_list)>=2:
##        hour=int(num_list[0])%24; minute=int(num_list[1])%60
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, minute)
##    if len(num_list)==1:
##        hour=int(num_list[0])%24
##        if ampm=="pm" and hour<12: hour+=12
##        if ampm=="am" and hour==12: hour=0
##        return (hour, 0)
##    return None
##
##def spoken_time_to_str(spoken: str) -> Optional[str]:
##    hm = spoken_time_to_hm(spoken)
##    if not hm: return None
##    return f"{hm[0]:02d}:{hm[1]:02d}"
##
### ---------- simple persistence/organizer ----------
##ORGANIZER_DIR = os.path.join(os.path.expanduser("~"), ".alfred_reminders")
##os.makedirs(ORGANIZER_DIR, exist_ok=True)
##ORGANIZER_DB = os.path.join(ORGANIZER_DIR, "events.json")
##organizer_events: List[dict] = []
##
##def _load_organizer_events():
##    global organizer_events
##    try:
##        if os.path.exists(ORGANIZER_DB):
##            with open(ORGANIZER_DB, "r", encoding="utf-8") as f:
##                organizer_events = json.load(f)
##    except Exception as e:
##        print("Organizer load failed:", e); organizer_events=[]
##
##def _save_organizer_events():
##    try:
##        with open(ORGANIZER_DB, "w", encoding="utf-8") as f:
##            json.dump(organizer_events, f, indent=2, default=str)
##    except Exception as e:
##        print("Organizer save failed:", e)
##
##def _write_ics_file(ev: dict) -> Optional[str]:
##    try:
##        dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##        dtend = dtstart + timedelta(minutes=ev.get('duration_minutes',60))
##        uid = ev['id']
##        ics_text = "\r\n".join([
##            "BEGIN:VCALENDAR","PRODID:-//AlfredOrganizer//EN","VERSION:2.0","CALSCALE:GREGORIAN",
##            "BEGIN:VEVENT",f"UID:{uid}",f"DTSTAMP:{dt.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}",
##            f"DTSTART:{dtstart.strftime('%Y%m%dT%H%M%S')}",f"DTEND:{dtend.strftime('%Y%m%dT%H%M%S')}",
##            f"SUMMARY:{ev['title']}",f"DESCRIPTION:{ev.get('description','')}",
##            "END:VEVENT","END:VCALENDAR",""
##        ])
##        ics_path = os.path.join(ORGANIZER_DIR, f"reminder_{uid}.ics")
##        with open(ics_path, "w", encoding="utf-8", newline="\r\n") as f:
##            f.write(ics_text)
##        return ics_path
##    except Exception as e:
##        print("Error writing ics:", e); return None
##
##def add_organizer_event(title: str, date_text: str, time_text: str="09:00",
##                        duration_minutes: int = 60, reminder_minutes: int = 15,
##                        description: str = "", event_type: str = "reminder") -> dict:
##    try:
##        ymd = dt.date.fromisoformat(date_text) if isinstance(date_text, str) else date_text
##        hh, mm = 9,0
##        try:
##            hh = int(time_text.split(":")[0]); mm = int(time_text.split(":")[1])
##        except Exception:
##            pass
##        dtstart = dt.datetime.combine(ymd, dt.time(hh, mm))
##        ev = {"id": uuid.uuid4().hex, "title": title, "dtstart": dtstart.isoformat(),
##              "duration_minutes": int(duration_minutes), "reminder_minutes": int(reminder_minutes),
##              "description": description, "ics_path": None, "notified": False}
##        ics = _write_ics_file(ev)
##        if ics: ev['ics_path'] = ics
##        organizer_events.append(ev); _save_organizer_events()
##        return ev
##    except Exception as e:
##        print("add_organizer_event failed:", e); raise
##
##_load_organizer_events()
##
### ---------- quick reminders ----------
##_QUICK_REMINDERS = os.path.join(os.getcwd(), "data.txt")
##def _append_lines_to_file(lines: List[str], path: str = _QUICK_REMINDERS):
##    if not lines: return
##    try:
##        with open(path, "a", encoding="utf-8") as f:
##            for ln in lines: f.write(ln.rstrip()+"\n")
##    except Exception as e:
##        print("Failed to save quick reminders:", e)
##
##def _read_all_reminders(path: str = _QUICK_REMINDERS) -> List[str]:
##    try:
##        if not os.path.exists(path): return []
##        with open(path, "r", encoding="utf-8") as f:
##            return [ln.strip() for ln in f.readlines() if ln.strip()]
##    except Exception as e:
##        print("Failed to read reminders:", e); return []
##
### ---------- title extraction ----------
##def extract_title_from_text(text: str) -> str:
##    s = text.strip()
##    s = re.sub(r"^(set a reminder (for|to)|set reminder (for|to)|remind me to|create (me )?a reminder for|please remind me to)\s+", "", s, flags=re.I)
##    s = re.sub(r"\bon\s+(\d{4}-\d{2}-\d{2}|\d{1,2}/\d{1,2}/\d{4}|\w+\s+\d{1,2})\b", "", s, flags=re.I)
##    s = re.sub(r"\bat\s+([0-9apm:\s]+|[a-z0-9 ]+ hours)\b", "", s, flags=re.I)
##    s = s.strip(" ,.")
##    return s or "Reminder"
##
### ---------- confirmation helper ----------
##def _ask_confirm_and_listen(confirm_text: str, timeout: int = 12) -> bool:
##    _speak(confirm_text)
##    _send_bluetooth(confirm_text)
##    resp = _listen_once(timeout=timeout)
##    if not resp:
##        # no response -> treat as NO
##        return False
##    low = resp.lower()
##    if any(w in low for w in ("yes","yep","yeah","confirm","do it","sure","please")):
##        return True
##    return False
##
### ---------- main handler (with relative times + confirmation) ----------
##def handle_voice_command(AlfredQueryOffline: str, gui=None):
##    text_in = (AlfredQueryOffline or "").strip()
##    if not text_in: return
##    lower = text_in.lower()
##
##    if any(k in lower for k in ("remind me","create a reminder","create me a reminder","set a reminder","i want to remember","can you remember")):
##        _speak("Okay  I will create a reminder.")
##        try:
##            msg_text, speaker, score, gender, gender_conf = extract_text_from_query(text_in)
##        except Exception:
##            msg_text = text_in
##
##        # Try relative datetime first
##        rel_dt = parse_relative_datetime(msg_text)
##        date_value = None; time_value = None; parsed_dt = None
##        if rel_dt:
##            parsed_dt = rel_dt
##            date_value = parsed_dt.date().isoformat()
##            time_value = parsed_dt.time().strftime("%H:%M")
##        else:
##            date_value = parse_natural_date(msg_text)
##            time_value = parse_natural_time(msg_text)
##            # if time parse returns "HH:MM", keep it, else check spoken_time helper
##            if time_value is None:
##                tstr = spoken_time_to_str(msg_text)
##                if tstr: time_value = tstr
##
##        title_candidate = extract_title_from_text(msg_text)
##
##        # If both missing, ask interactively (date first)
##        if not date_value and parsed_dt is None:
##            _speak("On which date should I set this reminder? Say 'tomorrow', 'today', a weekday, or a numeric date.")
##            _send_bluetooth("On which date should I set this reminder?")
##            resp = _listen_once()
##            if resp:
##                dv = parse_natural_date(resp)
##                if dv: date_value = dv
##                else:
##                    ymd = spoken_date_to_ymd(resp)
##                    if ymd and ymd[0] and ymd[1] and ymd[2]:
##                        date_value = f"{ymd[0]:04d}-{ymd[1]:02d}-{ymd[2]:02d}"
##
##        if not time_value and parsed_dt is None:
##            _speak("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.")
##            _send_bluetooth("At what time? Say 'half past six', '13:00', 'six pm', or 'in three hours'.")
##            resp = _listen_once()
##            if resp:
##                rv = parse_relative_datetime(resp)
##                if rv:
##                    parsed_dt = rv; date_value = parsed_dt.date().isoformat(); time_value = parsed_dt.time().strftime("%H:%M")
##                else:
##                    tv = parse_natural_time(resp)
##                    if tv: time_value = tv
##                    else:
##                        tstr = spoken_time_to_str(resp)
##                        if tstr: time_value = tstr
##
##        # If still neither -> save as quick reminder
##        if not date_value and parsed_dt is None and not time_value:
##            _append_lines_to_file([title_candidate])
##            _speak(f"Saved quick reminder: {title_candidate}")
##            return
##
##        # if parsed_dt exists we already have exact datetime
##        if parsed_dt:
##            final_dt = parsed_dt
##        else:
##            # normalize defaults
##            if not date_value:
##                date_value = dt.date.today().isoformat()
##            if not time_value:
##                time_value = "09:00"
##            try:
##                parsed_date = dt.date.fromisoformat(date_value)
##            except Exception:
##                try: parsed_date = dt.datetime.strptime(date_value, "%Y-%m-%d").date()
##                except Exception: parsed_date = None
##            try:
##                parsed_time = dt.datetime.strptime(time_value, "%H:%M").time()
##            except Exception:
##                hm = spoken_time_to_hm(time_value)
##                parsed_time = dt.time(hm[0],hm[1]) if hm else dt.time(9,0)
##            if parsed_date is None:
##                _append_lines_to_file([f"{title_candidate} (date unknown: {msg_text})"])
##                _speak("I saved the reminder text but could not determine the date. Ask me again with a clearer date and I will schedule it.")
##                return
##            final_dt = dt.datetime.combine(parsed_date, parsed_time)
##
##        # Confirmation step
##        confirm_text = f"Set reminder '{title_candidate}' on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}  confirm?"
##        confirmed = _ask_confirm_and_listen(confirm_text, timeout=12)
##        if not confirmed:
##            _speak("Okay, I will not save that reminder.")
##            return
##
##        # Create event and persist
##        try:
##            event = add_organizer_event(title_candidate, final_dt.date().isoformat(), final_dt.strftime("%H:%M"), duration_minutes=60, reminder_minutes=15, description="Created by Alfred", event_type="reminder")
##            _speak(f"Reminder set: {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}")
##            if gui is not None and hasattr(gui, "log_query"):
##                gui.log_query(f"Organizer created: {title_candidate} -> {event.get('ics_path','(no ics)')}")
##        except Exception as e:
##            # fallback minimal event creation
##            try:
##                ev = {"id": uuid.uuid4().hex,"title": title_candidate,"dtstart": final_dt.isoformat(),"duration_minutes":60,"reminder_minutes":15,"description":"Created by Alfred","ics_path":None,"notified":False}
##                ics = _write_ics_file(ev)
##                if ics: ev['ics_path']=ics
##                organizer_events.append(ev); _save_organizer_events()
##                _speak(f"Created calendar file for {title_candidate} on {final_dt.date().isoformat()} at {final_dt.strftime('%H:%M')}.")
##            except Exception:
##                _speak("Failed to create calendar reminder.")
##        return
##
##    # READ schedule
##    if any(k in lower for k in ("what is my schedule","what do i have","what are my reminders","what are my meetings","what do i have scheduled","what can you remember","what did i tell you")):
##        _speak("Checking your reminders and schedule.")
##        quick = _read_all_reminders()
##        dated = []
##        for ev in organizer_events:
##            try:
##                dobj = dt.datetime.fromisoformat(ev.get("dtstart"))
##                dated.append(f"{ev.get('title','(no title)')} at {dobj.strftime('%Y-%m-%d %H:%M')}")
##            except Exception:
##                dated.append(ev.get('title','(no title)'))
##        out_parts = []
##        if quick: out_parts.append("Quick reminders: " + " ; ".join(quick))
##        if dated: out_parts.append("Scheduled: " + " ; ".join(dated))
##        if out_parts:
##            out = " . ".join(out_parts)
##            _speak(out); _send_bluetooth(out)
##        else:
##            _speak("You have no reminders or scheduled events I can see right now.")
##        return
##
### ---------- Background notifier thread ----------
##_NOTIFIER_THREAD = None
##def _notifier_loop(poll_seconds: int = 30):
##    while True:
##        try:
##            now = dt.datetime.now()
##            changed = False
##            for ev in organizer_events:
##                try:
##                    if ev.get("notified", False):
##                        continue
##                    dtstart = dt.datetime.fromisoformat(ev['dtstart'])
##                    remind_before = int(ev.get("reminder_minutes", 15))
##                    notify_time = dtstart - timedelta(minutes=remind_before)
##                    # if now >= notify_time and not yet notified
##                    if now >= notify_time:
##                        # announce
##                        _speak(f"Reminder: {ev.get('title','an event')} scheduled for {dtstart.strftime('%Y-%m-%d %H:%M')}")
##                        ev['notified'] = True
##                        changed = True
##                except Exception:
##                    continue
##            if changed: _save_organizer_events()
##        except Exception as e:
##            print("Notifier loop error:", e)
##        time.sleep(poll_seconds)
##
##def start_reminder_notifier_thread():
##    global _NOTIFIER_THREAD
##    if _NOTIFIER_THREAD and _NOTIFIER_THREAD.is_alive():
##        return
##    _NOTIFIER_THREAD = threading.Thread(target=_notifier_loop, kwargs={"poll_seconds":30}, daemon=True)
##    _NOTIFIER_THREAD.start()
##
### ---------- module demo when run directly ----------
##if __name__ == "__main__":
##    print("Reminder module demo. Type a test phrase or 'quit'.")
##    start_reminder_notifier_thread()
##    while True:
##        q = input("You: ").strip()
##        if not q or q.lower() in ("quit","exit"): break
##        handle_voice_command(q)

